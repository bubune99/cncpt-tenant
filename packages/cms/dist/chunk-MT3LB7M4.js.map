{"version":3,"sources":["/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-MT3LB7M4.js","../src/lib/email/providers/smtp.ts","../src/lib/email/providers/sendgrid.ts","../src/lib/email/providers/resend.ts","../src/lib/email/providers/mailgun.ts","../src/lib/email/providers/ses.ts","../src/lib/email/merge-tags.ts","../src/lib/encryption/index.ts","../src/lib/settings/types.ts","../src/lib/settings/index.ts","../src/lib/email/tracking.ts","../src/lib/email/webhooks.ts","../src/lib/email/subscriptions.ts","../src/lib/email/queue.ts","../src/lib/email/index.ts"],"names":["formatAddress","match","confirmationToken"],"mappings":"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;AACH,MAAA;AACA,MAAA;AACA,MAAA;AACD,IAAA;AACH,EAAA;AAAA;AAAA;AAAA;AAKoE,EAAA;AArNtE,IAAA;AAsN4C,IAAA;AAGrB,IAAA;AACF,MAAA;AACjB,IAAA;AACsB,IAAA;AACF,MAAA;AACpB,IAAA;AAGuB,IAAA;AACW,MAAA;AAClC,IAAA;AAG6C,IAAA;AAC7B,IAAA;AACE,IAAA;AAE0B,IAAA;AACP,MAAA;AAEnB,QAAA;AACC,QAAA;AAChB,MAAA;AAEY,MAAA;AACS,QAAA;AACJ,QAAA;AACE,QAAA;AACJ,QAAA;AACf,MAAA;AAEmB,MAAA;AAClB,QAAA;AACK,MAAA;AACL,QAAA;AACF,MAAA;AACF,IAAA;AAEO,IAAA;AACoB,MAAA;AACN,MAAA;AACnB,MAAA;AACA,MAAA;AACA,MAAA;AACoB,MAAA;AACtB,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAY4B,EAAA;AAnR9B,IAAA;AAoR4C,IAAA;AAGrB,IAAA;AACF,MAAA;AACjB,IAAA;AAG6C,IAAA;AAC7B,IAAA;AACE,IAAA;AAE0B,IAAA;AACE,MAAA;AAEL,MAAA;AACH,MAAA;AACA,MAAA;AAED,MAAA;AAEnB,QAAA;AACd,QAAA;AACA,QAAA;AACA,QAAA;AACe,QAAA;AAChB,MAAA;AAEY,MAAA;AACS,QAAA;AACJ,QAAA;AACE,QAAA;AACJ,QAAA;AACf,MAAA;AAEmB,MAAA;AAClB,QAAA;AACK,MAAA;AACL,QAAA;AACF,MAAA;AACF,IAAA;AAEO,IAAA;AACoB,MAAA;AACN,MAAA;AACnB,MAAA;AACA,MAAA;AACA,MAAA;AACoB,MAAA;AACtB,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAKiC,EAAA;AACS,IAAA;AACjB,IAAA;AACzB,EAAA;AAAA;AAAA;AAAA;AAKgD,EAAA;AACN,IAAA;AACxB,IAAA;AAClB,EAAA;AAAA;AAAA;AAAA;AAK6B,EAAA;AA3V/B,IAAA;AA4VuB,IAAA;AACS,MAAA;AAC5B,IAAA;AACgB,IAAA;AAGZ,IAAA;AAC2B,MAAA;AAC/B,IAAA;AACmB,IAAA;AACG,IAAA;AACxB,EAAA;AACF;AAG6C;AAGoC;AAC/C,EAAA;AAClC;AAEyF;AACnD,EAAA;AACtC;AAS4B;AACyB,EAAA;AACrD;AdspFsD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-MT3LB7M4.js","sourcesContent":[null,"/**\n * SMTP Email Provider\n *\n * Uses nodemailer for SMTP email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SmtpConfig,\n  EmailAddress,\n} from '../types'\n\n// We'll use dynamic import for nodemailer to avoid issues if not installed\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet nodemailer: any = null\n\nasync function getNodemailer() {\n  if (!nodemailer) {\n    try {\n      nodemailer = await import('nodemailer')\n    } catch {\n      throw new Error('nodemailer is not installed. Run: npm install nodemailer')\n    }\n  }\n  return nodemailer\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `\"${addr.name}\" <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress).join(', ')\n}\n\nexport class SmtpProvider implements IEmailProvider {\n  readonly name = 'smtp' as const\n  private config: SmtpConfig\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private transporter: any = null\n\n  constructor(config: SmtpConfig) {\n    this.config = config\n  }\n\n  private async getTransporter() {\n    if (this.transporter) return this.transporter\n\n    const nm = await getNodemailer()\n    this.transporter = nm.createTransport({\n      host: this.config.host,\n      port: this.config.port,\n      secure: this.config.secure ?? this.config.port === 465,\n      auth: this.config.user\n        ? {\n            user: this.config.user,\n            pass: this.config.pass,\n          }\n        : undefined,\n      pool: this.config.pool ?? true,\n      maxConnections: this.config.maxConnections ?? 5,\n    })\n\n    return this.transporter\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    try {\n      const transporter = await this.getTransporter()\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const mailOptions: any = {\n        from: message.from ? formatAddress(message.from) : undefined,\n        to: formatAddresses(message.to),\n        subject: message.subject,\n        text: message.text,\n        html: message.html,\n        replyTo: message.replyTo ? formatAddress(message.replyTo) : undefined,\n        cc: message.cc ? formatAddresses(message.cc) : undefined,\n        bcc: message.bcc ? formatAddresses(message.bcc) : undefined,\n        headers: message.headers,\n        attachments: message.attachments?.map((att) => ({\n          filename: att.filename,\n          content: att.content,\n          contentType: att.contentType,\n          encoding: att.encoding as BufferEncoding | undefined,\n          cid: att.cid,\n        })),\n      }\n\n      const result = await transporter.sendMail(mailOptions)\n\n      return {\n        success: true,\n        messageId: result.messageId,\n        provider: 'smtp',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'smtp',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    // SMTP doesn't support true bulk sending, so we send individually\n    for (const recipient of message.recipients) {\n      const result = await this.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: 'smtp',\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const transporter = await this.getTransporter()\n      await transporter.verify()\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.transporter) {\n      this.transporter.close()\n      this.transporter = null\n    }\n  }\n}\n","/**\n * SendGrid Email Provider\n *\n * Uses SendGrid API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SendGridConfig,\n  EmailAddress,\n} from '../types'\n\ninterface SendGridMailContent {\n  type: string\n  value: string\n}\n\ninterface SendGridPersonalization {\n  to: Array<{ email: string; name?: string }>\n  cc?: Array<{ email: string; name?: string }>\n  bcc?: Array<{ email: string; name?: string }>\n  subject?: string\n  substitutions?: Record<string, string>\n  custom_args?: Record<string, string>\n}\n\ninterface SendGridMailRequest {\n  personalizations: SendGridPersonalization[]\n  from: { email: string; name?: string }\n  reply_to?: { email: string; name?: string }\n  subject: string\n  content: SendGridMailContent[]\n  attachments?: Array<{\n    content: string\n    filename: string\n    type?: string\n    disposition?: string\n    content_id?: string\n  }>\n  headers?: Record<string, string>\n  categories?: string[]\n  custom_args?: Record<string, string>\n  mail_settings?: {\n    sandbox_mode?: { enable: boolean }\n  }\n  tracking_settings?: {\n    click_tracking?: { enable: boolean }\n    open_tracking?: { enable: boolean }\n  }\n}\n\nfunction toSendGridAddress(addr: EmailAddress): { email: string; name?: string } {\n  return { email: addr.email, name: addr.name }\n}\n\nfunction toSendGridAddresses(addrs: EmailAddress | EmailAddress[]): Array<{ email: string; name?: string }> {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(toSendGridAddress)\n}\n\nexport class SendGridProvider implements IEmailProvider {\n  readonly name = 'sendgrid' as const\n  private config: SendGridConfig\n\n  constructor(config: SendGridConfig) {\n    this.config = config\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'sendgrid',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const personalization: SendGridPersonalization = {\n        to: toSendGridAddresses(message.to),\n      }\n\n      if (message.cc) {\n        personalization.cc = toSendGridAddresses(message.cc)\n      }\n      if (message.bcc) {\n        personalization.bcc = toSendGridAddresses(message.bcc)\n      }\n      if (message.metadata) {\n        personalization.custom_args = message.metadata\n      }\n\n      const content: SendGridMailContent[] = []\n      if (message.text) {\n        content.push({ type: 'text/plain', value: message.text })\n      }\n      if (message.html) {\n        content.push({ type: 'text/html', value: message.html })\n      }\n\n      const request: SendGridMailRequest = {\n        personalizations: [personalization],\n        from: toSendGridAddress(message.from),\n        subject: message.subject,\n        content,\n      }\n\n      if (message.replyTo) {\n        request.reply_to = toSendGridAddress(message.replyTo)\n      }\n\n      if (message.headers) {\n        request.headers = message.headers\n      }\n\n      if (message.tags) {\n        request.categories = message.tags\n      }\n\n      if (message.attachments) {\n        request.attachments = message.attachments.map((att) => ({\n          content: typeof att.content === 'string' ? att.content : att.content.toString('base64'),\n          filename: att.filename,\n          type: att.contentType,\n          content_id: att.cid,\n        }))\n      }\n\n      // Tracking settings\n      request.tracking_settings = {\n        click_tracking: { enable: message.trackClicks ?? true },\n        open_tracking: { enable: message.trackOpens ?? true },\n      }\n\n      if (this.config.sandboxMode) {\n        request.mail_settings = { sandbox_mode: { enable: true } }\n      }\n\n      // Campaign attribution\n      if (message.campaignId || message.recipientId) {\n        request.custom_args = {\n          ...request.custom_args,\n          ...(message.campaignId && { campaign_id: message.campaignId }),\n          ...(message.recipientId && { recipient_id: message.recipientId }),\n        }\n      }\n\n      const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      })\n\n      if (!response.ok) {\n        const errorBody = await response.text()\n        return {\n          success: false,\n          provider: 'sendgrid',\n          error: `SendGrid API error: ${response.status} - ${errorBody}`,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n        }\n      }\n\n      const messageId = response.headers.get('x-message-id') || undefined\n\n      return {\n        success: true,\n        messageId,\n        provider: 'sendgrid',\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'sendgrid',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'sendgrid',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // SendGrid supports up to 1000 personalizations per request\n      const batchSize = 1000\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const personalizations: SendGridPersonalization[] = batch.map((recipient) => ({\n          to: [toSendGridAddress(recipient.to)],\n          substitutions: recipient.substitutions,\n          custom_args: recipient.metadata,\n        }))\n\n        const content: SendGridMailContent[] = []\n        if (message.text) {\n          content.push({ type: 'text/plain', value: message.text })\n        }\n        if (message.html) {\n          content.push({ type: 'text/html', value: message.html })\n        }\n\n        const request: SendGridMailRequest = {\n          personalizations,\n          from: toSendGridAddress(message.from),\n          subject: message.subject,\n          content,\n          tracking_settings: {\n            click_tracking: { enable: message.trackClicks ?? true },\n            open_tracking: { enable: message.trackOpens ?? true },\n          },\n        }\n\n        if (message.replyTo) {\n          request.reply_to = toSendGridAddress(message.replyTo)\n        }\n\n        if (this.config.sandboxMode) {\n          request.mail_settings = { sandbox_mode: { enable: true } }\n        }\n\n        const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${this.config.apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(request),\n        })\n\n        if (response.ok) {\n          const messageId = response.headers.get('x-message-id') || undefined\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: true,\n              messageId,\n            })\n            totalSent++\n          }\n        } else {\n          const errorBody = await response.text()\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: `SendGrid API error: ${response.status} - ${errorBody}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'sendgrid',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'sendgrid',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      // Verify by checking API key validity\n      const response = await fetch('https://api.sendgrid.com/v3/user/profile', {\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Resend Email Provider\n *\n * Uses Resend API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  ResendConfig,\n  EmailAddress,\n} from '../types'\n\ninterface ResendEmailRequest {\n  from: string\n  to: string | string[]\n  subject: string\n  html?: string\n  text?: string\n  cc?: string | string[]\n  bcc?: string | string[]\n  reply_to?: string | string[]\n  headers?: Record<string, string>\n  attachments?: Array<{\n    filename: string\n    content: string\n  }>\n  tags?: Array<{\n    name: string\n    value: string\n  }>\n}\n\ninterface ResendBatchRequest {\n  from: string\n  to: string[]\n  subject: string\n  html?: string\n  text?: string\n  reply_to?: string\n  tags?: Array<{\n    name: string\n    value: string\n  }>\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string[] {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress)\n}\n\nexport class ResendProvider implements IEmailProvider {\n  readonly name = 'resend' as const\n  private config: ResendConfig\n\n  constructor(config: ResendConfig) {\n    this.config = config\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'resend',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const request: ResendEmailRequest = {\n        from: formatAddress(message.from),\n        to: formatAddresses(message.to),\n        subject: message.subject,\n        html: message.html,\n        text: message.text,\n      }\n\n      if (message.cc) {\n        request.cc = formatAddresses(message.cc)\n      }\n      if (message.bcc) {\n        request.bcc = formatAddresses(message.bcc)\n      }\n      if (message.replyTo) {\n        request.reply_to = formatAddress(message.replyTo)\n      }\n      if (message.headers) {\n        request.headers = message.headers\n      }\n\n      if (message.attachments) {\n        request.attachments = message.attachments.map((att) => ({\n          filename: att.filename,\n          content: typeof att.content === 'string' ? att.content : att.content.toString('base64'),\n        }))\n      }\n\n      // Add tags for tracking\n      const tags: Array<{ name: string; value: string }> = []\n      if (message.campaignId) {\n        tags.push({ name: 'campaign_id', value: message.campaignId })\n      }\n      if (message.recipientId) {\n        tags.push({ name: 'recipient_id', value: message.recipientId })\n      }\n      if (message.tags) {\n        message.tags.forEach((tag) => {\n          tags.push({ name: 'tag', value: tag })\n        })\n      }\n      if (tags.length > 0) {\n        request.tags = tags\n      }\n\n      const response = await fetch('https://api.resend.com/emails', {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      })\n\n      const result = await response.json()\n\n      if (!response.ok) {\n        return {\n          success: false,\n          provider: 'resend',\n          error: result.message || `Resend API error: ${response.status}`,\n          errorCode: result.name,\n          timestamp: new Date(),\n          raw: result,\n        }\n      }\n\n      return {\n        success: true,\n        messageId: result.id,\n        provider: 'resend',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'resend',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'resend',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Resend's batch API supports up to 100 emails per request\n      const batchSize = 100\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const batchRequests: ResendBatchRequest[] = batch.map((recipient) => ({\n          from: formatAddress(message.from!),\n          to: [formatAddress(recipient.to)],\n          subject: message.subject,\n          html: message.html,\n          text: message.text,\n          reply_to: message.replyTo ? formatAddress(message.replyTo) : undefined,\n          tags: [\n            ...(message.campaignId ? [{ name: 'campaign_id', value: message.campaignId }] : []),\n            ...(recipient.metadata?.recipientId\n              ? [{ name: 'recipient_id', value: recipient.metadata.recipientId }]\n              : []),\n          ],\n        }))\n\n        const response = await fetch('https://api.resend.com/emails/batch', {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${this.config.apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(batchRequests),\n        })\n\n        const result = await response.json()\n\n        if (response.ok && Array.isArray(result.data)) {\n          for (let j = 0; j < batch.length; j++) {\n            const itemResult = result.data[j]\n            if (itemResult?.id) {\n              allResults.push({\n                email: batch[j].to.email,\n                success: true,\n                messageId: itemResult.id,\n              })\n              totalSent++\n            } else {\n              allResults.push({\n                email: batch[j].to.email,\n                success: false,\n                error: itemResult?.message || 'Unknown error',\n              })\n              totalFailed++\n            }\n          }\n        } else {\n          // Batch failed\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: result.message || `Resend API error: ${response.status}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'resend',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'resend',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const response = await fetch('https://api.resend.com/domains', {\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Mailgun Email Provider\n *\n * Uses Mailgun API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  MailgunConfig,\n  EmailAddress,\n} from '../types'\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress).join(', ')\n}\n\nexport class MailgunProvider implements IEmailProvider {\n  readonly name = 'mailgun' as const\n  private config: MailgunConfig\n  private baseUrl: string\n\n  constructor(config: MailgunConfig) {\n    this.config = config\n    this.baseUrl =\n      config.region === 'eu'\n        ? `https://api.eu.mailgun.net/v3/${config.domain}`\n        : `https://api.mailgun.net/v3/${config.domain}`\n  }\n\n  private getAuthHeader(): string {\n    return 'Basic ' + Buffer.from(`api:${this.config.apiKey}`).toString('base64')\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'mailgun',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const formData = new FormData()\n      formData.append('from', formatAddress(message.from))\n      formData.append('to', formatAddresses(message.to))\n      formData.append('subject', message.subject)\n\n      if (message.text) {\n        formData.append('text', message.text)\n      }\n      if (message.html) {\n        formData.append('html', message.html)\n      }\n      if (message.cc) {\n        formData.append('cc', formatAddresses(message.cc))\n      }\n      if (message.bcc) {\n        formData.append('bcc', formatAddresses(message.bcc))\n      }\n      if (message.replyTo) {\n        formData.append('h:Reply-To', formatAddress(message.replyTo))\n      }\n\n      // Add custom headers\n      if (message.headers) {\n        for (const [key, value] of Object.entries(message.headers)) {\n          formData.append(`h:${key}`, value)\n        }\n      }\n\n      // Add tags\n      if (message.tags) {\n        for (const tag of message.tags) {\n          formData.append('o:tag', tag)\n        }\n      }\n\n      // Tracking options\n      formData.append('o:tracking', 'yes')\n      formData.append('o:tracking-clicks', message.trackClicks !== false ? 'yes' : 'no')\n      formData.append('o:tracking-opens', message.trackOpens !== false ? 'yes' : 'no')\n\n      // Campaign attribution\n      if (message.campaignId) {\n        formData.append('v:campaign_id', message.campaignId)\n      }\n      if (message.recipientId) {\n        formData.append('v:recipient_id', message.recipientId)\n      }\n\n      // Add metadata as custom variables\n      if (message.metadata) {\n        for (const [key, value] of Object.entries(message.metadata)) {\n          formData.append(`v:${key}`, value)\n        }\n      }\n\n      // Add attachments\n      if (message.attachments) {\n        for (const att of message.attachments) {\n          let content: string\n          if (typeof att.content === 'string') {\n            content = att.content\n          } else {\n            content = att.content.toString('base64')\n          }\n          // Use base64 encoded content directly\n          const blob = new Blob([Buffer.from(content, 'base64')], { type: att.contentType || 'application/octet-stream' })\n          if (att.cid) {\n            formData.append('inline', blob, att.filename)\n          } else {\n            formData.append('attachment', blob, att.filename)\n          }\n        }\n      }\n\n      const response = await fetch(`${this.baseUrl}/messages`, {\n        method: 'POST',\n        headers: {\n          Authorization: this.getAuthHeader(),\n        },\n        body: formData,\n      })\n\n      const result = await response.json()\n\n      if (!response.ok) {\n        return {\n          success: false,\n          provider: 'mailgun',\n          error: result.message || `Mailgun API error: ${response.status}`,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n          raw: result,\n        }\n      }\n\n      return {\n        success: true,\n        messageId: result.id,\n        provider: 'mailgun',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'mailgun',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'mailgun',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Mailgun supports batch sending with recipient variables\n      // Maximum 1000 recipients per batch\n      const batchSize = 1000\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const formData = new FormData()\n        formData.append('from', formatAddress(message.from))\n        formData.append('to', batch.map((r) => formatAddress(r.to)).join(', '))\n        formData.append('subject', message.subject)\n\n        if (message.text) {\n          formData.append('text', message.text)\n        }\n        if (message.html) {\n          formData.append('html', message.html)\n        }\n        if (message.replyTo) {\n          formData.append('h:Reply-To', formatAddress(message.replyTo))\n        }\n\n        // Tracking\n        formData.append('o:tracking', 'yes')\n        formData.append('o:tracking-clicks', message.trackClicks !== false ? 'yes' : 'no')\n        formData.append('o:tracking-opens', message.trackOpens !== false ? 'yes' : 'no')\n\n        // Add recipient variables for substitutions\n        const recipientVariables: Record<string, Record<string, string>> = {}\n        for (const recipient of batch) {\n          recipientVariables[recipient.to.email] = {\n            ...recipient.substitutions,\n            ...recipient.metadata,\n          }\n        }\n        formData.append('recipient-variables', JSON.stringify(recipientVariables))\n\n        const response = await fetch(`${this.baseUrl}/messages`, {\n          method: 'POST',\n          headers: {\n            Authorization: this.getAuthHeader(),\n          },\n          body: formData,\n        })\n\n        const result = await response.json()\n\n        if (response.ok) {\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: true,\n              messageId: result.id,\n            })\n            totalSent++\n          }\n        } else {\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: result.message || `Mailgun API error: ${response.status}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'mailgun',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'mailgun',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}`, {\n        headers: {\n          Authorization: this.getAuthHeader(),\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * AWS SES Email Provider\n *\n * Uses AWS SES API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SesConfig,\n  EmailAddress,\n} from '../types'\n\n// Simple AWS4 signature for SES\n// In production, you'd use @aws-sdk/client-ses\nasync function signRequest(\n  config: SesConfig,\n  method: string,\n  url: string,\n  body: string,\n  headers: Record<string, string>\n): Promise<Record<string, string>> {\n  const now = new Date()\n  const amzDate = now.toISOString().replace(/[:-]|\\.\\d{3}/g, '')\n  const dateStamp = amzDate.slice(0, 8)\n\n  const host = new URL(url).host\n  const service = 'ses'\n\n  // Create canonical request\n  const signedHeaders = 'content-type;host;x-amz-date'\n  const canonicalHeaders = `content-type:${headers['Content-Type']}\\nhost:${host}\\nx-amz-date:${amzDate}\\n`\n\n  const encoder = new TextEncoder()\n  const payloadHash = await crypto.subtle.digest('SHA-256', encoder.encode(body))\n  const payloadHashHex = Array.from(new Uint8Array(payloadHash))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const canonicalRequest = `${method}\\n/\\n\\n${canonicalHeaders}\\n${signedHeaders}\\n${payloadHashHex}`\n\n  const credentialScope = `${dateStamp}/${config.region}/${service}/aws4_request`\n  const canonicalRequestHash = await crypto.subtle.digest('SHA-256', encoder.encode(canonicalRequest))\n  const canonicalRequestHashHex = Array.from(new Uint8Array(canonicalRequestHash))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const stringToSign = `AWS4-HMAC-SHA256\\n${amzDate}\\n${credentialScope}\\n${canonicalRequestHashHex}`\n\n  // Calculate signature\n  async function hmac(key: ArrayBuffer | string, data: string): Promise<ArrayBuffer> {\n    const keyData = typeof key === 'string' ? encoder.encode(key) : key\n    const cryptoKey = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign'])\n    return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(data))\n  }\n\n  const kDate = await hmac(`AWS4${config.secretAccessKey}`, dateStamp)\n  const kRegion = await hmac(kDate, config.region)\n  const kService = await hmac(kRegion, service)\n  const kSigning = await hmac(kService, 'aws4_request')\n  const signature = await hmac(kSigning, stringToSign)\n  const signatureHex = Array.from(new Uint8Array(signature))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const authorizationHeader = `AWS4-HMAC-SHA256 Credential=${config.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signatureHex}`\n\n  return {\n    ...headers,\n    'X-Amz-Date': amzDate,\n    Authorization: authorizationHeader,\n  }\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string[] {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress)\n}\n\nexport class SesProvider implements IEmailProvider {\n  readonly name = 'ses' as const\n  private config: SesConfig\n  private endpoint: string\n\n  constructor(config: SesConfig) {\n    this.config = config\n    this.endpoint = `https://email.${config.region}.amazonaws.com`\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'ses',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Build the SES SendEmail parameters\n      const params = new URLSearchParams()\n      params.append('Action', 'SendEmail')\n      params.append('Version', '2010-12-01')\n      params.append('Source', formatAddress(message.from))\n\n      // To addresses\n      const toAddrs = Array.isArray(message.to) ? message.to : [message.to]\n      toAddrs.forEach((addr, i) => {\n        params.append(`Destination.ToAddresses.member.${i + 1}`, formatAddress(addr))\n      })\n\n      // CC addresses\n      if (message.cc) {\n        const ccAddrs = Array.isArray(message.cc) ? message.cc : [message.cc]\n        ccAddrs.forEach((addr, i) => {\n          params.append(`Destination.CcAddresses.member.${i + 1}`, formatAddress(addr))\n        })\n      }\n\n      // BCC addresses\n      if (message.bcc) {\n        const bccAddrs = Array.isArray(message.bcc) ? message.bcc : [message.bcc]\n        bccAddrs.forEach((addr, i) => {\n          params.append(`Destination.BccAddresses.member.${i + 1}`, formatAddress(addr))\n        })\n      }\n\n      // Subject\n      params.append('Message.Subject.Data', message.subject)\n      params.append('Message.Subject.Charset', 'UTF-8')\n\n      // Body\n      if (message.text) {\n        params.append('Message.Body.Text.Data', message.text)\n        params.append('Message.Body.Text.Charset', 'UTF-8')\n      }\n      if (message.html) {\n        params.append('Message.Body.Html.Data', message.html)\n        params.append('Message.Body.Html.Charset', 'UTF-8')\n      }\n\n      // Reply-To\n      if (message.replyTo) {\n        params.append('ReplyToAddresses.member.1', formatAddress(message.replyTo))\n      }\n\n      // Tags for tracking\n      let tagIndex = 1\n      if (message.campaignId) {\n        params.append(`Tags.member.${tagIndex}.Name`, 'campaign_id')\n        params.append(`Tags.member.${tagIndex}.Value`, message.campaignId)\n        tagIndex++\n      }\n      if (message.recipientId) {\n        params.append(`Tags.member.${tagIndex}.Name`, 'recipient_id')\n        params.append(`Tags.member.${tagIndex}.Value`, message.recipientId)\n        tagIndex++\n      }\n      if (message.tags) {\n        for (const tag of message.tags) {\n          params.append(`Tags.member.${tagIndex}.Name`, 'tag')\n          params.append(`Tags.member.${tagIndex}.Value`, tag)\n          tagIndex++\n        }\n      }\n\n      const body = params.toString()\n      const headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      }\n\n      const signedHeaders = await signRequest(this.config, 'POST', this.endpoint, body, headers)\n\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: signedHeaders,\n        body,\n      })\n\n      const responseText = await response.text()\n\n      if (!response.ok) {\n        // Parse XML error response\n        const errorMatch = responseText.match(/<Message>([^<]+)<\\/Message>/)\n        const errorMessage = errorMatch ? errorMatch[1] : `SES API error: ${response.status}`\n        return {\n          success: false,\n          provider: 'ses',\n          error: errorMessage,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n          raw: responseText,\n        }\n      }\n\n      // Parse message ID from response\n      const messageIdMatch = responseText.match(/<MessageId>([^<]+)<\\/MessageId>/)\n      const messageId = messageIdMatch ? messageIdMatch[1] : undefined\n\n      return {\n        success: true,\n        messageId,\n        provider: 'ses',\n        timestamp: new Date(),\n        raw: responseText,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'ses',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    // SES doesn't have true bulk sending in the simple API\n    // For bulk, you'd use SendBulkTemplatedEmail which requires SES templates\n    // For now, we send individually\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const result = await this.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n\n      // Basic rate limiting for SES (14 emails/second for sandbox)\n      await new Promise((resolve) => setTimeout(resolve, 100))\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: 'ses',\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const params = new URLSearchParams()\n      params.append('Action', 'GetSendQuota')\n      params.append('Version', '2010-12-01')\n\n      const body = params.toString()\n      const headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      }\n\n      const signedHeaders = await signRequest(this.config, 'POST', this.endpoint, body, headers)\n\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: signedHeaders,\n        body,\n      })\n\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Merge Tag Parser\n *\n * Handles Mailchimp-style merge tags for email personalization\n *\n * Supported formats:\n * - {{FNAME}} - Simple variable\n * - {{subscriber.firstName}} - Nested path\n * - {{product.name|default:\"Product\"}} - With default value\n * - {{order.total|currency}} - With formatter\n * - {{#if hasOrders}}...{{/if}} - Conditional blocks\n * - {{#each products}}...{{/each}} - Loops\n */\n\nexport interface MergeTagData {\n  [key: string]: string | number | boolean | null | undefined | MergeTagData | MergeTagData[]\n}\n\n// Built-in formatters\nconst formatters: Record<string, (value: unknown, ...args: string[]) => string> = {\n  // Default value if empty/undefined\n  default: (value, defaultValue = '') => {\n    if (value === null || value === undefined || value === '') {\n      return defaultValue\n    }\n    return String(value)\n  },\n\n  // Currency formatting\n  currency: (value, currency = 'USD', locale = 'en-US') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return new Intl.NumberFormat(locale, {\n      style: 'currency',\n      currency,\n    }).format(num / 100) // Assuming cents\n  },\n\n  // Date formatting\n  date: (value, format = 'short', locale = 'en-US') => {\n    const date = value instanceof Date ? value : new Date(String(value))\n    if (isNaN(date.getTime())) return String(value)\n\n    const options: Intl.DateTimeFormatOptions = {}\n    switch (format) {\n      case 'short':\n        options.dateStyle = 'short'\n        break\n      case 'medium':\n        options.dateStyle = 'medium'\n        break\n      case 'long':\n        options.dateStyle = 'long'\n        break\n      case 'full':\n        options.dateStyle = 'full'\n        break\n      default:\n        options.dateStyle = 'short'\n    }\n    return new Intl.DateTimeFormat(locale, options).format(date)\n  },\n\n  // Time formatting\n  time: (value, format = 'short', locale = 'en-US') => {\n    const date = value instanceof Date ? value : new Date(String(value))\n    if (isNaN(date.getTime())) return String(value)\n\n    const options: Intl.DateTimeFormatOptions = {}\n    switch (format) {\n      case 'short':\n        options.timeStyle = 'short'\n        break\n      case 'medium':\n        options.timeStyle = 'medium'\n        break\n      case 'long':\n        options.timeStyle = 'long'\n        break\n      default:\n        options.timeStyle = 'short'\n    }\n    return new Intl.DateTimeFormat(locale, options).format(date)\n  },\n\n  // Number formatting\n  number: (value, locale = 'en-US') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return new Intl.NumberFormat(locale).format(num)\n  },\n\n  // Percent formatting\n  percent: (value, decimals = '0') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return `${(num * 100).toFixed(parseInt(decimals))}%`\n  },\n\n  // Uppercase\n  upper: (value) => String(value).toUpperCase(),\n\n  // Lowercase\n  lower: (value) => String(value).toLowerCase(),\n\n  // Capitalize first letter\n  capitalize: (value) => {\n    const str = String(value)\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()\n  },\n\n  // Title case\n  title: (value) => {\n    return String(value)\n      .split(' ')\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ')\n  },\n\n  // Truncate\n  truncate: (value, length = '50', suffix = '...') => {\n    const str = String(value)\n    const maxLength = parseInt(length)\n    if (str.length <= maxLength) return str\n    return str.slice(0, maxLength) + suffix\n  },\n\n  // URL encode\n  urlencode: (value) => encodeURIComponent(String(value)),\n\n  // HTML escape\n  escape: (value) => {\n    return String(value)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;')\n  },\n}\n\n/**\n * Get value from nested path\n */\nfunction getNestedValue(data: MergeTagData, path: string): unknown {\n  const parts = path.split('.')\n  let current: unknown = data\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined\n    }\n    if (typeof current === 'object' && part in (current as Record<string, unknown>)) {\n      current = (current as Record<string, unknown>)[part]\n    } else {\n      return undefined\n    }\n  }\n\n  return current\n}\n\n/**\n * Parse formatter string like \"currency:USD:en-US\"\n */\nfunction parseFormatter(formatterStr: string): { name: string; args: string[] } {\n  const parts = formatterStr.split(':')\n  return {\n    name: parts[0],\n    args: parts.slice(1),\n  }\n}\n\n/**\n * Process a single merge tag\n */\nfunction processMergeTag(tag: string, data: MergeTagData): string {\n  // Remove {{ and }}\n  let content = tag.slice(2, -2).trim()\n\n  // Check for pipe (formatter)\n  let formatterStr: string | null = null\n  const pipeIndex = content.indexOf('|')\n  if (pipeIndex !== -1) {\n    formatterStr = content.slice(pipeIndex + 1).trim()\n    content = content.slice(0, pipeIndex).trim()\n  }\n\n  // Get the value\n  let value = getNestedValue(data, content)\n\n  // Handle legacy Mailchimp-style tags (all caps)\n  if (value === undefined) {\n    const mailchimpMappings: Record<string, string> = {\n      FNAME: 'subscriber.firstName',\n      LNAME: 'subscriber.lastName',\n      EMAIL: 'subscriber.email',\n      MERGE0: 'subscriber.email',\n      MERGE1: 'subscriber.firstName',\n      MERGE2: 'subscriber.lastName',\n    }\n    if (content in mailchimpMappings) {\n      value = getNestedValue(data, mailchimpMappings[content])\n    }\n  }\n\n  // Apply formatter if present\n  if (formatterStr) {\n    // Handle default with quotes: default:\"value\"\n    const defaultMatch = formatterStr.match(/^default:\"([^\"]*)\"$/)\n    if (defaultMatch) {\n      return formatters.default(value, defaultMatch[1])\n    }\n\n    const { name, args } = parseFormatter(formatterStr)\n    const formatter = formatters[name]\n    if (formatter) {\n      return formatter(value, ...args)\n    }\n  }\n\n  // Return value or empty string\n  if (value === null || value === undefined) {\n    return ''\n  }\n\n  return String(value)\n}\n\n/**\n * Process conditional blocks: {{#if condition}}...{{/if}}\n */\nfunction processConditionals(template: string, data: MergeTagData): string {\n  // Simple if blocks\n  const ifRegex = /\\{\\{#if\\s+([^}]+)\\}\\}([\\s\\S]*?)\\{\\{\\/if\\}\\}/g\n\n  return template.replace(ifRegex, (_, condition, content) => {\n    const value = getNestedValue(data, condition.trim())\n    const isTruthy = Boolean(value) && value !== '' && value !== 0 && value !== '0'\n\n    // Check for else block\n    const parts = content.split(/\\{\\{else\\}\\}/)\n    if (isTruthy) {\n      return parts[0] || ''\n    } else {\n      return parts[1] || ''\n    }\n  })\n}\n\n/**\n * Process loop blocks: {{#each items}}...{{/each}}\n */\nfunction processLoops(template: string, data: MergeTagData): string {\n  const eachRegex = /\\{\\{#each\\s+([^}]+)\\}\\}([\\s\\S]*?)\\{\\{\\/each\\}\\}/g\n\n  return template.replace(eachRegex, (_, arrayPath, content) => {\n    const items = getNestedValue(data, arrayPath.trim())\n    if (!Array.isArray(items)) {\n      return ''\n    }\n\n    return items\n      .map((item, index) => {\n        // Create context with item, index, and @first/@last\n        const itemData: MergeTagData = {\n          ...data,\n          '@index': index,\n          '@first': index === 0,\n          '@last': index === items.length - 1,\n          this: item as MergeTagData,\n        }\n\n        // Replace {{this.property}} with item values\n        let itemContent = content.replace(/\\{\\{this\\.([^}|]+)([^}]*)?\\}\\}/g, (_: string, path: string, rest: string) => {\n          const fullTag = `{{${path}${rest || ''}}}`\n          return processMergeTag(fullTag, item as MergeTagData)\n        })\n\n        // Also support {{property}} directly (without this.)\n        itemContent = itemContent.replace(/\\{\\{([a-zA-Z_][a-zA-Z0-9_]*)([^}]*)?\\}\\}/g, (match: string, path: string, rest: string) => {\n          // Skip special tags\n          if (path.startsWith('#') || path.startsWith('/') || path === 'else') {\n            return match\n          }\n          // Check if it's an item property\n          if (typeof item === 'object' && item !== null && path in (item as Record<string, unknown>)) {\n            const fullTag = `{{${path}${rest || ''}}}`\n            return processMergeTag(fullTag, item as MergeTagData)\n          }\n          return match\n        })\n\n        return processMergeTagsInternal(itemContent, itemData)\n      })\n      .join('')\n  })\n}\n\n/**\n * Internal merge tag processing (after conditionals and loops)\n */\nfunction processMergeTagsInternal(template: string, data: MergeTagData): string {\n  // Match {{...}} tags\n  const tagRegex = /\\{\\{([^#/}][^}]*)\\}\\}/g\n\n  return template.replace(tagRegex, (match) => processMergeTag(match, data))\n}\n\n/**\n * Parse and replace all merge tags in a template\n */\nexport function parseMergeTags(template: string, data: MergeTagData): string {\n  let result = template\n\n  // Process loops first (they may contain conditionals and simple tags)\n  result = processLoops(result, data)\n\n  // Process conditionals\n  result = processConditionals(result, data)\n\n  // Process remaining simple tags\n  result = processMergeTagsInternal(result, data)\n\n  return result\n}\n\n/**\n * Extract all merge tags from a template\n */\nexport function extractMergeTags(template: string): string[] {\n  const tags = new Set<string>()\n\n  // Simple tags\n  const simpleRegex = /\\{\\{([^#/}][^}|]*)/g\n  let match\n  while ((match = simpleRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  // Conditional tags\n  const ifRegex = /\\{\\{#if\\s+([^}]+)\\}\\}/g\n  while ((match = ifRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  // Loop tags\n  const eachRegex = /\\{\\{#each\\s+([^}]+)\\}\\}/g\n  while ((match = eachRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  return Array.from(tags)\n}\n\n/**\n * Validate that all required merge tags have data\n */\nexport function validateMergeTagData(template: string, data: MergeTagData): { valid: boolean; missing: string[] } {\n  const tags = extractMergeTags(template)\n  const missing: string[] = []\n\n  for (const tag of tags) {\n    const value = getNestedValue(data, tag)\n    if (value === undefined) {\n      missing.push(tag)\n    }\n  }\n\n  return {\n    valid: missing.length === 0,\n    missing,\n  }\n}\n\n/**\n * Register a custom formatter\n */\nexport function registerFormatter(name: string, formatter: (value: unknown, ...args: string[]) => string): void {\n  formatters[name] = formatter\n}\n\n/**\n * Get all available formatters\n */\nexport function getFormatters(): string[] {\n  return Object.keys(formatters)\n}\n","/**\n * Encryption Utilities\n *\n * Provides AES-256-GCM encryption for storing sensitive data in the database\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto'\n\nconst ALGORITHM = 'aes-256-gcm'\nconst IV_LENGTH = 16\nconst SALT_LENGTH = 32\nconst TAG_LENGTH = 16\nconst KEY_LENGTH = 32\n\n// Get encryption key from environment or generate a warning\nfunction getEncryptionKey(): Buffer {\n  const key = process.env.ENCRYPTION_KEY\n\n  if (!key) {\n    console.warn(\n      'WARNING: ENCRYPTION_KEY not set. Using fallback key. Set ENCRYPTION_KEY in production!'\n    )\n    // Fallback key for development only - DO NOT use in production\n    return scryptSync('development-fallback-key', 'salt', KEY_LENGTH)\n  }\n\n  // If key is hex string, convert to buffer\n  if (key.length === 64) {\n    return Buffer.from(key, 'hex')\n  }\n\n  // Otherwise derive key from provided string\n  return scryptSync(key, 'nextjs-cms-salt', KEY_LENGTH)\n}\n\n/**\n * Encrypt a string value\n * Returns format: salt:iv:tag:encrypted (all hex encoded)\n */\nexport function encrypt(plaintext: string): string {\n  const key = getEncryptionKey()\n  const iv = randomBytes(IV_LENGTH)\n  const salt = randomBytes(SALT_LENGTH)\n\n  // Derive a unique key for this encryption using salt\n  const derivedKey = scryptSync(key, salt, KEY_LENGTH)\n\n  const cipher = createCipheriv(ALGORITHM, derivedKey, iv)\n\n  let encrypted = cipher.update(plaintext, 'utf8', 'hex')\n  encrypted += cipher.final('hex')\n\n  const tag = cipher.getAuthTag()\n\n  // Combine salt, iv, tag, and encrypted data\n  return `${salt.toString('hex')}:${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`\n}\n\n/**\n * Decrypt an encrypted string\n * Expects format: salt:iv:tag:encrypted (all hex encoded)\n */\nexport function decrypt(encryptedData: string): string {\n  const key = getEncryptionKey()\n\n  const parts = encryptedData.split(':')\n  if (parts.length !== 4) {\n    throw new Error('Invalid encrypted data format')\n  }\n\n  const [saltHex, ivHex, tagHex, encrypted] = parts\n\n  const salt = Buffer.from(saltHex, 'hex')\n  const iv = Buffer.from(ivHex, 'hex')\n  const tag = Buffer.from(tagHex, 'hex')\n\n  // Derive the same key using the stored salt\n  const derivedKey = scryptSync(key, salt, KEY_LENGTH)\n\n  const decipher = createDecipheriv(ALGORITHM, derivedKey, iv)\n  decipher.setAuthTag(tag)\n\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8')\n  decrypted += decipher.final('utf8')\n\n  return decrypted\n}\n\n/**\n * Check if a value is encrypted (matches our format)\n */\nexport function isEncrypted(value: string): boolean {\n  const parts = value.split(':')\n  if (parts.length !== 4) return false\n\n  // Check if all parts are valid hex\n  return parts.every((part) => /^[0-9a-f]+$/i.test(part))\n}\n\n/**\n * Safely encrypt - returns original if encryption fails\n */\nexport function safeEncrypt(value: string): string {\n  try {\n    return encrypt(value)\n  } catch (error) {\n    console.error('Encryption failed:', error)\n    return value\n  }\n}\n\n/**\n * Safely decrypt - returns original if decryption fails\n */\nexport function safeDecrypt(value: string): string {\n  try {\n    if (!isEncrypted(value)) {\n      return value\n    }\n    return decrypt(value)\n  } catch (error) {\n    console.error('Decryption failed:', error)\n    return value\n  }\n}\n\n/**\n * Hash a value (one-way, for comparison only)\n */\nexport function hash(value: string): string {\n  const salt = randomBytes(16).toString('hex')\n  const hashed = scryptSync(value, salt, 64).toString('hex')\n  return `${salt}:${hashed}`\n}\n\n/**\n * Verify a value against a hash\n */\nexport function verifyHash(value: string, hashedValue: string): boolean {\n  const [salt, originalHash] = hashedValue.split(':')\n  const hashed = scryptSync(value, salt, 64).toString('hex')\n  return hashed === originalHash\n}\n","/**\n * Settings Types\n */\n\n// Setting groups\nexport type SettingGroup =\n  | 'general'\n  | 'branding'\n  | 'store'\n  | 'payments'\n  | 'shipping'\n  | 'analytics'\n  | 'seo'\n  | 'email'\n  | 'storage'\n  | 'ai'\n  | 'security'\n\n// Branding settings (white-label)\nexport interface BrandingSettings {\n  siteName: string\n  siteTagline?: string\n  logoUrl?: string\n  logoAlt?: string\n  logoDarkUrl?: string // Logo for dark mode\n  faviconUrl?: string\n  appleTouchIconUrl?: string\n  ogImageUrl?: string // Default Open Graph image\n  primaryColor?: string\n  accentColor?: string\n}\n\n// General/Store settings\nexport interface GeneralSettings {\n  siteName: string\n  siteUrl: string\n  supportEmail: string\n  supportPhone?: string\n  timezone: string\n  currency: string\n  locale: string\n  logoUrl?: string\n  faviconUrl?: string\n}\n\n// Email settings\nexport interface EmailSettings {\n  provider: 'smtp' | 'sendgrid' | 'resend' | 'mailgun' | 'ses'\n  fromName: string\n  fromEmail: string\n  replyTo?: string\n\n  // SMTP settings\n  smtpHost?: string\n  smtpPort?: number\n  smtpUser?: string\n  smtpPass?: string\n  smtpSecure?: boolean\n\n  // Provider API keys\n  sendgridApiKey?: string\n  resendApiKey?: string\n  mailgunApiKey?: string\n  mailgunDomain?: string\n\n  // AWS SES\n  sesRegion?: string\n  sesAccessKeyId?: string\n  sesSecretAccessKey?: string\n}\n\n// Storage settings\nexport interface StorageSettings {\n  provider: 's3' | 'r2' | 'local'\n  bucket?: string\n  region?: string\n  accessKeyId?: string\n  secretAccessKey?: string\n  endpoint?: string // For R2 or S3-compatible\n  publicUrl?: string\n  maxFileSize: number // in MB\n  allowedFileTypes: string[]\n}\n\n// AI settings\nexport interface AiSettings {\n  enabled: boolean\n  provider: 'openai' | 'anthropic' | 'google'\n  apiKey?: string\n  model: string\n  maxTokens: number\n  temperature: number\n}\n\n// Security settings\nexport interface SecuritySettings {\n  allowRegistration: boolean\n  requireEmailVerification: boolean\n  sessionTimeout: number // in minutes\n  maxLoginAttempts: number\n  lockoutDuration: number // in minutes\n  twoFactorEnabled: boolean\n  passwordMinLength: number\n  passwordRequireUppercase: boolean\n  passwordRequireNumbers: boolean\n  passwordRequireSymbols: boolean\n}\n\n// Environment variable status\nexport interface EnvVarStatus {\n  name: string\n  configured: boolean\n  required: boolean\n  group: SettingGroup\n  description: string\n}\n\n// All settings combined\nexport interface AllSettings {\n  general: GeneralSettings\n  payments: import('../stripe/types').StripeSettings\n  shipping: import('../shippo/types').ShippingSettings\n  analytics: import('../analytics/types').AnalyticsSettings\n  seo: import('../seo/types').SeoConfig\n  email: EmailSettings\n  storage: StorageSettings\n  ai: AiSettings\n  security: SecuritySettings\n}\n\n// Default settings\nexport const DEFAULT_BRANDING_SETTINGS: BrandingSettings = {\n  siteName: process.env.NEXT_PUBLIC_SITE_NAME || 'My Site',\n  siteTagline: 'Welcome to our platform',\n  primaryColor: '#0066cc',\n  accentColor: '#6366f1',\n}\n\nexport const DEFAULT_GENERAL_SETTINGS: GeneralSettings = {\n  siteName: 'My Store',\n  siteUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n  supportEmail: 'support@example.com',\n  timezone: 'America/New_York',\n  currency: 'USD',\n  locale: 'en-US',\n}\n\nexport const DEFAULT_EMAIL_SETTINGS: EmailSettings = {\n  provider: 'smtp',\n  fromName: 'My Store',\n  fromEmail: 'noreply@example.com',\n}\n\nexport const DEFAULT_STORAGE_SETTINGS: StorageSettings = {\n  provider: 's3',\n  maxFileSize: 10, // 10MB\n  allowedFileTypes: ['image/*', 'application/pdf'],\n}\n\nexport const DEFAULT_AI_SETTINGS: AiSettings = {\n  enabled: false,\n  provider: 'openai',\n  model: 'gpt-4o',\n  maxTokens: 4096,\n  temperature: 0.7,\n}\n\nexport const DEFAULT_SECURITY_SETTINGS: SecuritySettings = {\n  allowRegistration: true,\n  requireEmailVerification: true,\n  sessionTimeout: 60,\n  maxLoginAttempts: 5,\n  lockoutDuration: 15,\n  twoFactorEnabled: false,\n  passwordMinLength: 8,\n  passwordRequireUppercase: true,\n  passwordRequireNumbers: true,\n  passwordRequireSymbols: false,\n}\n\n// Required environment variables\nexport const REQUIRED_ENV_VARS: EnvVarStatus[] = [\n  // Database\n  { name: 'DATABASE_URL', configured: false, required: true, group: 'general', description: 'PostgreSQL connection string' },\n\n  // Auth\n  { name: 'NEXTAUTH_SECRET', configured: false, required: true, group: 'security', description: 'NextAuth secret for session encryption' },\n  { name: 'NEXTAUTH_URL', configured: false, required: true, group: 'security', description: 'Application URL for auth callbacks' },\n\n  // Stripe\n  { name: 'STRIPE_SECRET_KEY', configured: false, required: false, group: 'payments', description: 'Stripe API secret key' },\n  { name: 'STRIPE_WEBHOOK_SECRET', configured: false, required: false, group: 'payments', description: 'Stripe webhook signing secret' },\n  { name: 'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY', configured: false, required: false, group: 'payments', description: 'Stripe publishable key (public)' },\n\n  // Shippo\n  { name: 'SHIPPO_API_KEY', configured: false, required: false, group: 'shipping', description: 'Shippo API token' },\n  { name: 'SHIPPO_WEBHOOK_SECRET', configured: false, required: false, group: 'shipping', description: 'Shippo webhook secret' },\n\n  // Analytics\n  { name: 'NEXT_PUBLIC_GA_MEASUREMENT_ID', configured: false, required: false, group: 'analytics', description: 'Google Analytics 4 Measurement ID' },\n  { name: 'NEXT_PUBLIC_MATOMO_URL', configured: false, required: false, group: 'analytics', description: 'Matomo server URL' },\n  { name: 'NEXT_PUBLIC_MATOMO_SITE_ID', configured: false, required: false, group: 'analytics', description: 'Matomo site ID' },\n\n  // Storage (S3/R2)\n  { name: 'S3_BUCKET', configured: false, required: false, group: 'storage', description: 'S3 bucket name' },\n  { name: 'S3_REGION', configured: false, required: false, group: 'storage', description: 'S3 region' },\n  { name: 'S3_ACCESS_KEY_ID', configured: false, required: false, group: 'storage', description: 'S3 access key ID' },\n  { name: 'S3_SECRET_ACCESS_KEY', configured: false, required: false, group: 'storage', description: 'S3 secret access key' },\n  { name: 'S3_ENDPOINT', configured: false, required: false, group: 'storage', description: 'S3-compatible endpoint (for R2)' },\n\n  // AI\n  { name: 'OPENAI_API_KEY', configured: false, required: false, group: 'ai', description: 'OpenAI API key' },\n  { name: 'ANTHROPIC_API_KEY', configured: false, required: false, group: 'ai', description: 'Anthropic API key' },\n  { name: 'GOOGLE_AI_API_KEY', configured: false, required: false, group: 'ai', description: 'Google AI API key' },\n\n  // Email\n  { name: 'SMTP_HOST', configured: false, required: false, group: 'email', description: 'SMTP server host' },\n  { name: 'SMTP_PORT', configured: false, required: false, group: 'email', description: 'SMTP server port' },\n  { name: 'SMTP_USER', configured: false, required: false, group: 'email', description: 'SMTP username' },\n  { name: 'SMTP_PASS', configured: false, required: false, group: 'email', description: 'SMTP password' },\n  { name: 'SENDGRID_API_KEY', configured: false, required: false, group: 'email', description: 'SendGrid API key' },\n  { name: 'RESEND_API_KEY', configured: false, required: false, group: 'email', description: 'Resend API key' },\n]\n","/**\n * Settings Library\n *\n * Centralized settings management with database storage and encryption\n */\n\nimport { prisma } from '../db'\nimport { encrypt, safeDecrypt, isEncrypted } from '../encryption'\nimport type {\n  SettingGroup,\n  BrandingSettings,\n  GeneralSettings,\n  EmailSettings,\n  StorageSettings,\n  AiSettings,\n  SecuritySettings,\n  EnvVarStatus,\n} from './types'\nimport {\n  REQUIRED_ENV_VARS,\n  DEFAULT_BRANDING_SETTINGS,\n  DEFAULT_GENERAL_SETTINGS,\n  DEFAULT_EMAIL_SETTINGS,\n  DEFAULT_STORAGE_SETTINGS,\n  DEFAULT_AI_SETTINGS,\n  DEFAULT_SECURITY_SETTINGS,\n} from './types'\n\n// Keys that should be encrypted in the database\nconst SENSITIVE_KEYS: Record<SettingGroup, string[]> = {\n  email: ['smtpPass', 'sendgridApiKey', 'resendApiKey', 'mailgunApiKey', 'sesAccessKeyId', 'sesSecretAccessKey'],\n  storage: ['accessKeyId', 'secretAccessKey'],\n  ai: ['apiKey'],\n  payments: ['stripeSecretKey', 'stripeWebhookSecret', 'paypalClientSecret'],\n  branding: [],\n  general: [],\n  store: [],\n  shipping: [],\n  analytics: [],\n  seo: [],\n  security: [],\n}\n\n// Cache for settings\nconst settingsCache: Map<SettingGroup, { data: any; timestamp: number }> = new Map()\nconst CACHE_TTL = 60 * 1000 // 1 minute\n\n/**\n * Get settings for a specific group\n */\nexport async function getSettings<T>(\n  group: SettingGroup,\n  defaults: T\n): Promise<T> {\n  // Check cache\n  const cached = settingsCache.get(group)\n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return cached.data as T\n  }\n\n  const records = await prisma.setting.findMany({\n    where: { group },\n  })\n\n  const settings = { ...defaults } as any\n  const sensitiveKeys = SENSITIVE_KEYS[group] || []\n\n  for (const record of records) {\n    const key = record.key.replace(`${group}.`, '')\n    let value = record.value\n\n    // Decrypt if this is a sensitive key and the value is encrypted\n    if (sensitiveKeys.includes(key) && record.encrypted && isEncrypted(value)) {\n      value = safeDecrypt(value)\n    }\n\n    try {\n      // Try to parse JSON values\n      settings[key] = JSON.parse(value)\n    } catch {\n      // Use raw value if not JSON\n      settings[key] = value\n    }\n  }\n\n  // Update cache\n  settingsCache.set(group, { data: settings, timestamp: Date.now() })\n\n  return settings as T\n}\n\n/**\n * Update settings for a group\n */\nexport async function updateSettings(\n  group: SettingGroup,\n  settings: Record<string, any>\n): Promise<void> {\n  const sensitiveKeys = SENSITIVE_KEYS[group] || []\n\n  for (const [key, value] of Object.entries(settings)) {\n    if (value === undefined) continue\n\n    // Skip if value is masked (unchanged)\n    if (value === '********') continue\n\n    const fullKey = `${group}.${key}`\n    const isSensitive = sensitiveKeys.includes(key)\n\n    // Encrypt sensitive values before storing\n    let stringValue = typeof value === 'string' ? value : JSON.stringify(value)\n    if (isSensitive && stringValue && stringValue !== '') {\n      stringValue = encrypt(stringValue)\n    }\n\n    await prisma.setting.upsert({\n      where: { key: fullKey },\n      create: {\n        key: fullKey,\n        value: stringValue,\n        group,\n        encrypted: isSensitive,\n      },\n      update: {\n        value: stringValue,\n        encrypted: isSensitive,\n      },\n    })\n  }\n\n  // Clear cache for this group\n  settingsCache.delete(group)\n}\n\n/**\n * Clear settings cache\n */\nexport function clearSettingsCache(group?: SettingGroup): void {\n  if (group) {\n    settingsCache.delete(group)\n  } else {\n    settingsCache.clear()\n  }\n}\n\n// Convenience functions for each settings group\nexport async function getBrandingSettings(): Promise<BrandingSettings> {\n  return getSettings('branding', DEFAULT_BRANDING_SETTINGS)\n}\n\nexport async function getGeneralSettings(): Promise<GeneralSettings> {\n  return getSettings('general', DEFAULT_GENERAL_SETTINGS)\n}\n\nexport async function getEmailSettings(): Promise<EmailSettings> {\n  const settings = await getSettings('email', DEFAULT_EMAIL_SETTINGS)\n\n  // Fallback to environment variables\n  if (!settings.smtpHost) settings.smtpHost = process.env.SMTP_HOST\n  if (!settings.smtpPort) settings.smtpPort = parseInt(process.env.SMTP_PORT || '587')\n  if (!settings.smtpUser) settings.smtpUser = process.env.SMTP_USER\n  if (!settings.smtpPass) settings.smtpPass = process.env.SMTP_PASS\n  if (!settings.sendgridApiKey) settings.sendgridApiKey = process.env.SENDGRID_API_KEY\n  if (!settings.resendApiKey) settings.resendApiKey = process.env.RESEND_API_KEY\n\n  return settings\n}\n\nexport async function getStorageSettings(): Promise<StorageSettings> {\n  const settings = await getSettings('storage', DEFAULT_STORAGE_SETTINGS)\n\n  // Fallback to environment variables (S3 or R2)\n  if (!settings.bucket) settings.bucket = process.env.S3_BUCKET || process.env.R2_BUCKET\n  if (!settings.region) settings.region = process.env.S3_REGION || 'auto'\n  if (!settings.accessKeyId) settings.accessKeyId = process.env.S3_ACCESS_KEY_ID || process.env.R2_ACCESS_KEY_ID\n  if (!settings.secretAccessKey) settings.secretAccessKey = process.env.S3_SECRET_ACCESS_KEY || process.env.R2_SECRET_ACCESS_KEY\n\n  // Build R2 endpoint from account ID if not explicitly set\n  if (!settings.endpoint) {\n    if (process.env.S3_ENDPOINT) {\n      settings.endpoint = process.env.S3_ENDPOINT\n    } else if (process.env.R2_ACCOUNT_ID) {\n      settings.endpoint = `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`\n    }\n  }\n\n  // Public URL for R2\n  if (!settings.publicUrl) settings.publicUrl = process.env.R2_PUBLIC_URL\n\n  // Auto-detect R2 provider when R2 env vars are used\n  if (process.env.R2_BUCKET || process.env.R2_ACCOUNT_ID) {\n    settings.provider = 'r2'\n  }\n\n  return settings\n}\n\nexport async function getAiSettings(): Promise<AiSettings> {\n  const settings = await getSettings('ai', DEFAULT_AI_SETTINGS)\n\n  // Fallback to environment variables\n  if (!settings.apiKey) {\n    switch (settings.provider) {\n      case 'openai':\n        settings.apiKey = process.env.OPENAI_API_KEY\n        break\n      case 'anthropic':\n        settings.apiKey = process.env.ANTHROPIC_API_KEY\n        break\n      case 'google':\n        settings.apiKey = process.env.GOOGLE_AI_API_KEY\n        break\n    }\n  }\n\n  return settings\n}\n\nexport async function getSecuritySettings(): Promise<SecuritySettings> {\n  return getSettings('security', DEFAULT_SECURITY_SETTINGS)\n}\n\n/**\n * Check environment variable status\n */\nexport function getEnvVarStatus(): EnvVarStatus[] {\n  return REQUIRED_ENV_VARS.map((envVar) => ({\n    ...envVar,\n    configured: !!process.env[envVar.name],\n  }))\n}\n\n/**\n * Get all settings for admin dashboard\n */\nexport async function getAllSettings(): Promise<{\n  branding: BrandingSettings\n  general: GeneralSettings\n  email: EmailSettings\n  storage: StorageSettings\n  ai: AiSettings\n  security: SecuritySettings\n  envVars: EnvVarStatus[]\n}> {\n  const [branding, general, email, storage, ai, security] = await Promise.all([\n    getBrandingSettings(),\n    getGeneralSettings(),\n    getEmailSettings(),\n    getStorageSettings(),\n    getAiSettings(),\n    getSecuritySettings(),\n  ])\n\n  return {\n    branding,\n    general,\n    email: {\n      ...email,\n      // Mask sensitive values\n      smtpPass: email.smtpPass ? '********' : undefined,\n      sendgridApiKey: email.sendgridApiKey ? '********' : undefined,\n      resendApiKey: email.resendApiKey ? '********' : undefined,\n      mailgunApiKey: email.mailgunApiKey ? '********' : undefined,\n      sesSecretAccessKey: email.sesSecretAccessKey ? '********' : undefined,\n    },\n    storage: {\n      ...storage,\n      secretAccessKey: storage.secretAccessKey ? '********' : undefined,\n    },\n    ai: {\n      ...ai,\n      apiKey: ai.apiKey ? '********' : undefined,\n    },\n    security,\n    envVars: getEnvVarStatus(),\n  }\n}\n\nexport * from './types'\n","/**\n * Email Tracking Service\n *\n * Injects tracking pixels and rewrites links for email analytics\n */\n\nimport { prisma } from '../db'\nimport crypto from 'crypto'\n\nconst APP_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n\n/**\n * Generate a unique tracking token\n */\nexport function generateTrackingToken(): string {\n  return crypto.randomBytes(16).toString('hex')\n}\n\n/**\n * Create a tracking pixel URL\n */\nexport function createOpenTrackingUrl(recipientId: string, campaignId?: string): string {\n  const params = new URLSearchParams({\n    r: recipientId,\n    ...(campaignId && { c: campaignId }),\n  })\n  return `${APP_URL}/api/email/track/open?${params.toString()}`\n}\n\n/**\n * Create a click tracking URL\n */\nexport function createClickTrackingUrl(\n  recipientId: string,\n  originalUrl: string,\n  linkId?: string,\n  campaignId?: string\n): string {\n  const params = new URLSearchParams({\n    r: recipientId,\n    u: originalUrl,\n    ...(linkId && { l: linkId }),\n    ...(campaignId && { c: campaignId }),\n  })\n  return `${APP_URL}/api/email/track/click?${params.toString()}`\n}\n\n/**\n * Create an unsubscribe URL\n */\nexport function createUnsubscribeUrl(subscriberId: string, token?: string): string {\n  const params = new URLSearchParams({\n    s: subscriberId,\n    ...(token && { t: token }),\n  })\n  return `${APP_URL}/api/email/unsubscribe?${params.toString()}`\n}\n\n/**\n * Create a preference center URL\n */\nexport function createPreferenceCenterUrl(subscriberId: string, token?: string): string {\n  const params = new URLSearchParams({\n    s: subscriberId,\n    ...(token && { t: token }),\n  })\n  return `${APP_URL}/email/preferences?${params.toString()}`\n}\n\n/**\n * Inject open tracking pixel into HTML email\n */\nexport function injectOpenTrackingPixel(html: string, recipientId: string, campaignId?: string): string {\n  const trackingUrl = createOpenTrackingUrl(recipientId, campaignId)\n  const pixel = `<img src=\"${trackingUrl}\" width=\"1\" height=\"1\" alt=\"\" style=\"display:none;width:1px;height:1px;border:0;\" />`\n\n  // Inject before closing body tag, or at end if no body tag\n  if (html.includes('</body>')) {\n    return html.replace('</body>', `${pixel}</body>`)\n  }\n  return html + pixel\n}\n\n/**\n * Rewrite all links in HTML for click tracking\n */\nexport function rewriteLinksForTracking(\n  html: string,\n  recipientId: string,\n  campaignId?: string,\n  excludePatterns: RegExp[] = []\n): string {\n  // Default exclusion patterns\n  const defaultExclusions = [\n    /^mailto:/i,\n    /^tel:/i,\n    /^#/,\n    /^javascript:/i,\n    /unsubscribe/i,\n    /preference/i,\n  ]\n\n  const exclusions = [...defaultExclusions, ...excludePatterns]\n\n  // Match href attributes\n  const hrefRegex = /href=[\"']([^\"']+)[\"']/gi\n\n  return html.replace(hrefRegex, (match, url: string) => {\n    // Check if URL should be excluded\n    for (const pattern of exclusions) {\n      if (pattern.test(url)) {\n        return match\n      }\n    }\n\n    // Skip already-tracked URLs\n    if (url.includes('/api/email/track/')) {\n      return match\n    }\n\n    const trackedUrl = createClickTrackingUrl(recipientId, url, undefined, campaignId)\n    return `href=\"${trackedUrl}\"`\n  })\n}\n\n/**\n * Inject list-unsubscribe headers for email clients\n */\nexport function getUnsubscribeHeaders(subscriberId: string, token?: string): Record<string, string> {\n  const unsubscribeUrl = createUnsubscribeUrl(subscriberId, token)\n\n  return {\n    'List-Unsubscribe': `<${unsubscribeUrl}>`,\n    'List-Unsubscribe-Post': 'List-Unsubscribe=One-Click',\n  }\n}\n\n/**\n * Process HTML email for full tracking\n */\nexport function processEmailForTracking(\n  html: string,\n  recipientId: string,\n  options: {\n    campaignId?: string\n    trackOpens?: boolean\n    trackClicks?: boolean\n    excludeLinkPatterns?: RegExp[]\n  } = {}\n): string {\n  let processed = html\n\n  // Rewrite links for click tracking\n  if (options.trackClicks !== false) {\n    processed = rewriteLinksForTracking(processed, recipientId, options.campaignId, options.excludeLinkPatterns)\n  }\n\n  // Inject open tracking pixel\n  if (options.trackOpens !== false) {\n    processed = injectOpenTrackingPixel(processed, recipientId, options.campaignId)\n  }\n\n  return processed\n}\n\n/**\n * Record an email open event\n */\nexport async function recordEmailOpen(\n  recipientId: string,\n  metadata?: {\n    campaignId?: string\n    ipAddress?: string\n    userAgent?: string\n  }\n): Promise<void> {\n  const now = new Date()\n\n  // Update recipient record\n  await prisma.emailRecipient.update({\n    where: { id: recipientId },\n    data: {\n      openedAt: now,\n      openCount: { increment: 1 },\n    },\n  })\n\n  // Update campaign stats\n  if (metadata?.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: metadata.campaignId },\n      data: {\n        openCount: { increment: 1 },\n        // uniqueOpenCount handled separately with deduplication\n      },\n    })\n  }\n\n  // Update subscriber engagement\n  await prisma.$executeRaw`\n    UPDATE email_subscribers es\n    SET\n      total_opens = total_opens + 1,\n      last_engaged_at = ${now},\n      engagement_score = LEAST(engagement_score + 1, 100)\n    FROM email_recipients er\n    WHERE er.id = ${recipientId}\n    AND es.email = er.email\n  `\n}\n\n/**\n * Record an email click event\n */\nexport async function recordEmailClick(\n  recipientId: string,\n  url: string,\n  metadata?: {\n    campaignId?: string\n    linkId?: string\n    ipAddress?: string\n    userAgent?: string\n  }\n): Promise<void> {\n  const now = new Date()\n\n  // Update recipient record\n  await prisma.emailRecipient.update({\n    where: { id: recipientId },\n    data: {\n      clickedAt: now,\n      clickCount: { increment: 1 },\n    },\n  })\n\n  // Record click in EmailLinkClick if we have a linkId\n  if (metadata?.linkId) {\n    await prisma.emailLinkClick.create({\n      data: {\n        linkId: metadata.linkId,\n        recipientId,\n        clickedAt: now,\n        ipAddress: metadata.ipAddress,\n        userAgent: metadata.userAgent,\n      },\n    })\n\n    // Update link click count\n    await prisma.emailLink.update({\n      where: { id: metadata.linkId },\n      data: {\n        clickCount: { increment: 1 },\n      },\n    })\n  }\n\n  // Update campaign stats\n  if (metadata?.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: metadata.campaignId },\n      data: {\n        clickCount: { increment: 1 },\n      },\n    })\n  }\n\n  // Update subscriber engagement\n  await prisma.$executeRaw`\n    UPDATE email_subscribers es\n    SET\n      total_clicks = total_clicks + 1,\n      last_engaged_at = ${now},\n      engagement_score = LEAST(engagement_score + 2, 100)\n    FROM email_recipients er\n    WHERE er.id = ${recipientId}\n    AND es.email = er.email\n  `\n}\n\n/**\n * Get or create a tracked link\n */\nexport async function getOrCreateTrackedLink(\n  campaignId: string,\n  targetUrl: string\n): Promise<string> {\n  // Check if link exists\n  let link = await prisma.emailLink.findFirst({\n    where: {\n      campaignId,\n      url: targetUrl,\n    },\n  })\n\n  if (!link) {\n    link = await prisma.emailLink.create({\n      data: {\n        campaignId,\n        url: targetUrl,\n        clickCount: 0,\n      },\n    })\n  }\n\n  return link.id\n}\n\n/**\n * Rewrite links with database-tracked IDs\n */\nexport async function rewriteLinksWithTracking(\n  html: string,\n  recipientId: string,\n  campaignId: string,\n  excludePatterns: RegExp[] = []\n): Promise<string> {\n  const defaultExclusions = [\n    /^mailto:/i,\n    /^tel:/i,\n    /^#/,\n    /^javascript:/i,\n    /unsubscribe/i,\n    /preference/i,\n  ]\n\n  const exclusions = [...defaultExclusions, ...excludePatterns]\n\n  // Extract all links first\n  const hrefRegex = /href=[\"']([^\"']+)[\"']/gi\n  const links: string[] = []\n  let match\n\n  while ((match = hrefRegex.exec(html)) !== null) {\n    const url = match[1]\n    let shouldExclude = false\n\n    for (const pattern of exclusions) {\n      if (pattern.test(url)) {\n        shouldExclude = true\n        break\n      }\n    }\n\n    if (!shouldExclude && !url.includes('/api/email/track/')) {\n      links.push(url)\n    }\n  }\n\n  // Create tracked links in batch\n  const linkMap = new Map<string, string>()\n  for (const url of links) {\n    const linkId = await getOrCreateTrackedLink(campaignId, url)\n    linkMap.set(url, linkId)\n  }\n\n  // Replace links with tracked versions\n  return html.replace(hrefRegex, (match, url: string) => {\n    const linkId = linkMap.get(url)\n    if (!linkId) {\n      return match\n    }\n\n    const trackedUrl = createClickTrackingUrl(recipientId, url, linkId, campaignId)\n    return `href=\"${trackedUrl}\"`\n  })\n}\n","/**\n * Email Webhook Handlers\n *\n * Process bounce, complaint, and delivery events from email providers\n */\n\nimport { prisma } from '../db'\nimport type { EmailWebhookEvent, EmailProvider, EmailEventType } from './types'\nimport crypto from 'crypto'\n\n/**\n * Process an email webhook event\n */\nexport async function processEmailWebhookEvent(event: EmailWebhookEvent): Promise<void> {\n  const now = new Date()\n\n  switch (event.type) {\n    case 'bounced':\n    case 'soft_bounced':\n      await handleBounce(event)\n      break\n\n    case 'complained':\n      await handleComplaint(event)\n      break\n\n    case 'delivered':\n      await handleDelivery(event)\n      break\n\n    case 'unsubscribed':\n      await handleUnsubscribe(event)\n      break\n\n    case 'opened':\n    case 'clicked':\n      // These are typically handled by our own tracking endpoints\n      // But we can also process provider-side tracking here\n      break\n\n    case 'dropped':\n    case 'deferred':\n      await handleDropped(event)\n      break\n  }\n\n  // Log the event for debugging/analytics\n  console.log(`Email event: ${event.type} for ${event.email} via ${event.provider}`)\n}\n\n/**\n * Handle bounce events\n */\nasync function handleBounce(event: EmailWebhookEvent): Promise<void> {\n  const isHardBounce = event.bounceType === 'hard'\n\n  // Update subscriber status\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: isHardBounce ? 'BOUNCED' : 'ACTIVE',\n      unsubscribedAt: isHardBounce ? new Date() : undefined,\n    },\n  })\n\n  // Update recipient if we have messageId\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        bouncedAt: new Date(),\n        bounceType: event.bounceType,\n        errorMessage: event.bounceReason,\n      },\n    })\n  } else if (event.messageId) {\n    // Try to find by provider message ID\n    await prisma.emailRecipient.updateMany({\n      where: {\n        email: event.email,\n        providerMessageId: event.messageId,\n      },\n      data: {\n        bouncedAt: new Date(),\n        bounceType: event.bounceType,\n        errorMessage: event.bounceReason,\n      },\n    })\n  }\n\n  // Update campaign bounce count\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        bounceCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle complaint events (spam reports)\n */\nasync function handleComplaint(event: EmailWebhookEvent): Promise<void> {\n  // Mark subscriber as complained - this is serious\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: 'COMPLAINED',\n      unsubscribedAt: new Date(),\n    },\n  })\n\n  // Update recipient - mark as bounced with complaint reason\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        bouncedAt: new Date(),\n        errorMessage: `Spam complaint: ${event.complaintType || 'unknown'}`,\n      },\n    })\n  }\n\n  // Update campaign bounce count (complaints count as bounces)\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        bounceCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle delivery confirmation events\n */\nasync function handleDelivery(event: EmailWebhookEvent): Promise<void> {\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        sentAt: new Date(),\n        status: 'SENT',\n      },\n    })\n  }\n\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        sentCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle unsubscribe events from email client\n */\nasync function handleUnsubscribe(event: EmailWebhookEvent): Promise<void> {\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: 'UNSUBSCRIBED',\n      unsubscribedAt: new Date(),\n    },\n  })\n\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        unsubscribeCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle dropped/deferred events\n */\nasync function handleDropped(event: EmailWebhookEvent): Promise<void> {\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        status: 'FAILED',\n        errorMessage: event.bounceReason || `Email ${event.type}`,\n      },\n    })\n  }\n}\n\n// ==========================================\n// Provider-specific webhook parsers\n// ==========================================\n\n/**\n * Parse SendGrid webhook event\n */\nexport function parseSendGridWebhook(payload: unknown): EmailWebhookEvent[] {\n  const events: EmailWebhookEvent[] = []\n\n  if (!Array.isArray(payload)) {\n    return events\n  }\n\n  for (const item of payload) {\n    const eventType = mapSendGridEventType(item.event)\n    if (!eventType) continue\n\n    events.push({\n      type: eventType,\n      email: item.email,\n      messageId: item.sg_message_id,\n      timestamp: new Date(item.timestamp * 1000),\n      provider: 'sendgrid',\n      campaignId: item.campaign_id,\n      recipientId: item.recipient_id,\n      bounceType: item.bounce_classification === 'hard' ? 'hard' : 'soft',\n      bounceReason: item.reason,\n      linkUrl: item.url,\n      userAgent: item.useragent,\n      ipAddress: item.ip,\n      raw: item,\n    })\n  }\n\n  return events\n}\n\nfunction mapSendGridEventType(event: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    delivered: 'delivered',\n    bounce: 'bounced',\n    dropped: 'dropped',\n    spamreport: 'complained',\n    unsubscribe: 'unsubscribed',\n    open: 'opened',\n    click: 'clicked',\n    deferred: 'deferred',\n  }\n  return mapping[event] || null\n}\n\n/**\n * Parse Mailgun webhook event\n */\nexport function parseMailgunWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n  const eventData = data['event-data'] as Record<string, unknown>\n\n  if (!eventData) return null\n\n  const eventType = mapMailgunEventType(eventData.event as string)\n  if (!eventType) return null\n\n  const recipient = eventData.recipient as string\n  const message = eventData.message as Record<string, unknown>\n  const headers = message?.headers as Record<string, unknown>\n\n  return {\n    type: eventType,\n    email: recipient,\n    messageId: headers?.['message-id'] as string,\n    timestamp: new Date((eventData.timestamp as number) * 1000),\n    provider: 'mailgun',\n    campaignId: (eventData['user-variables'] as Record<string, string>)?.campaign_id,\n    recipientId: (eventData['user-variables'] as Record<string, string>)?.recipient_id,\n    bounceType: (eventData.severity as string) === 'permanent' ? 'hard' : 'soft',\n    bounceReason: (eventData['delivery-status'] as Record<string, unknown>)?.message as string,\n    linkUrl: eventData.url as string,\n    userAgent: (eventData['client-info'] as Record<string, unknown>)?.['user-agent'] as string,\n    ipAddress: eventData.ip as string,\n    raw: payload,\n  }\n}\n\nfunction mapMailgunEventType(event: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    delivered: 'delivered',\n    failed: 'bounced',\n    complained: 'complained',\n    unsubscribed: 'unsubscribed',\n    opened: 'opened',\n    clicked: 'clicked',\n  }\n  return mapping[event] || null\n}\n\n/**\n * Parse Resend webhook event\n */\nexport function parseResendWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n\n  const eventType = mapResendEventType(data.type as string)\n  if (!eventType) return null\n\n  const emailData = data.data as Record<string, unknown>\n\n  return {\n    type: eventType,\n    email: (emailData.to as string[])?.[0] || '',\n    messageId: emailData.email_id as string,\n    timestamp: new Date(data.created_at as string),\n    provider: 'resend',\n    campaignId: (emailData.tags as Array<{ name: string; value: string }>)?.find((t) => t.name === 'campaign_id')?.value,\n    recipientId: (emailData.tags as Array<{ name: string; value: string }>)?.find((t) => t.name === 'recipient_id')?.value,\n    bounceType: (emailData.bounce as Record<string, unknown>)?.type === 'permanent' ? 'hard' : 'soft',\n    bounceReason: (emailData.bounce as Record<string, unknown>)?.message as string,\n    raw: payload,\n  }\n}\n\nfunction mapResendEventType(type: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    'email.delivered': 'delivered',\n    'email.bounced': 'bounced',\n    'email.complained': 'complained',\n    'email.opened': 'opened',\n    'email.clicked': 'clicked',\n  }\n  return mapping[type] || null\n}\n\n/**\n * Parse AWS SES webhook (via SNS)\n */\nexport function parseSesWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n\n  // SNS wraps the message\n  let message: Record<string, unknown>\n  if (typeof data.Message === 'string') {\n    try {\n      message = JSON.parse(data.Message)\n    } catch {\n      return null\n    }\n  } else {\n    message = data as Record<string, unknown>\n  }\n\n  const notificationType = message.notificationType as string\n  const eventType = mapSesEventType(notificationType)\n  if (!eventType) return null\n\n  const mail = message.mail as Record<string, unknown>\n  const bounce = message.bounce as Record<string, unknown>\n  const complaint = message.complaint as Record<string, unknown>\n  const delivery = message.delivery as Record<string, unknown>\n\n  let email = ''\n  let bounceType: 'hard' | 'soft' | undefined\n  let bounceReason: string | undefined\n\n  if (bounce) {\n    const recipients = bounce.bouncedRecipients as Array<{ emailAddress: string }>\n    email = recipients?.[0]?.emailAddress || ''\n    bounceType = bounce.bounceType === 'Permanent' ? 'hard' : 'soft'\n    bounceReason = bounce.bounceSubType as string\n  } else if (complaint) {\n    const recipients = complaint.complainedRecipients as Array<{ emailAddress: string }>\n    email = recipients?.[0]?.emailAddress || ''\n  } else if (delivery) {\n    const recipients = delivery.recipients as string[]\n    email = recipients?.[0] || ''\n  }\n\n  return {\n    type: eventType,\n    email,\n    messageId: mail?.messageId as string,\n    timestamp: new Date(mail?.timestamp as string || message.timestamp as string),\n    provider: 'ses',\n    campaignId: (mail?.tags as Record<string, string[]>)?.campaign_id?.[0],\n    recipientId: (mail?.tags as Record<string, string[]>)?.recipient_id?.[0],\n    bounceType,\n    bounceReason,\n    complaintType: (complaint?.complaintFeedbackType as string),\n    raw: payload,\n  }\n}\n\nfunction mapSesEventType(type: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    Delivery: 'delivered',\n    Bounce: 'bounced',\n    Complaint: 'complained',\n    Open: 'opened',\n    Click: 'clicked',\n  }\n  return mapping[type] || null\n}\n\n// ==========================================\n// Webhook signature verification\n// ==========================================\n\n/**\n * Verify SendGrid webhook signature\n */\nexport function verifySendGridWebhook(\n  payload: string,\n  signature: string,\n  timestamp: string,\n  publicKey: string\n): boolean {\n  try {\n    const timestampPayload = timestamp + payload\n    const verify = crypto.createVerify('sha256')\n    verify.update(timestampPayload)\n    return verify.verify(publicKey, signature, 'base64')\n  } catch {\n    return false\n  }\n}\n\n/**\n * Verify Mailgun webhook signature\n */\nexport function verifyMailgunWebhook(\n  timestamp: string,\n  token: string,\n  signature: string,\n  apiKey: string\n): boolean {\n  const hmac = crypto.createHmac('sha256', apiKey)\n  hmac.update(timestamp + token)\n  const expected = hmac.digest('hex')\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))\n}\n\n/**\n * Verify Resend webhook signature\n */\nexport function verifyResendWebhook(\n  payload: string,\n  signature: string,\n  secret: string\n): boolean {\n  const hmac = crypto.createHmac('sha256', secret)\n  hmac.update(payload)\n  const expected = hmac.digest('hex')\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))\n}\n","/**\n * Email Subscription Management\n *\n * Handles subscribe, unsubscribe, and preference management\n */\n\nimport { prisma } from '../db'\nimport crypto from 'crypto'\n\nconst APP_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n\n/**\n * Generate a secure token for subscription actions\n */\nexport function generateSubscriptionToken(email: string): string {\n  const secret = process.env.ENCRYPTION_KEY || 'default-secret-key'\n  const hmac = crypto.createHmac('sha256', secret)\n  hmac.update(email + Date.now().toString())\n  return hmac.digest('hex')\n}\n\n/**\n * Verify a subscription token\n */\nexport function verifySubscriptionToken(email: string, token: string, maxAgeMs = 7 * 24 * 60 * 60 * 1000): boolean {\n  // For now, we just check if the token exists in the subscriber record\n  // A more robust implementation would include expiration timestamps\n  return token.length === 64 // SHA-256 hex length\n}\n\n/**\n * Subscribe a new email address\n */\nexport async function subscribeEmail(\n  email: string,\n  options: {\n    firstName?: string\n    lastName?: string\n    name?: string\n    source?: string\n    tags?: string[]\n    metadata?: Record<string, unknown>\n    doubleOptIn?: boolean\n    consentIp?: string\n  } = {}\n): Promise<{ success: boolean; subscriber?: unknown; needsConfirmation?: boolean; error?: string }> {\n  const normalizedEmail = email.toLowerCase().trim()\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  if (!emailRegex.test(normalizedEmail)) {\n    return { success: false, error: 'Invalid email address' }\n  }\n\n  try {\n    // Check if already subscribed\n    const existing = await prisma.emailSubscriber.findUnique({\n      where: { email: normalizedEmail },\n    })\n\n    if (existing) {\n      if (existing.status === 'ACTIVE') {\n        return { success: true, subscriber: existing, error: 'Already subscribed' }\n      }\n\n      // Resubscribe if previously unsubscribed\n      if (['UNSUBSCRIBED', 'CLEANED'].includes(existing.status)) {\n        const confirmationToken = options.doubleOptIn ? generateSubscriptionToken(normalizedEmail) : undefined\n\n        const updated = await prisma.emailSubscriber.update({\n          where: { email: normalizedEmail },\n          data: {\n            status: options.doubleOptIn ? 'PENDING' : 'ACTIVE',\n            firstName: options.firstName || existing.firstName,\n            lastName: options.lastName || existing.lastName,\n            name: options.name || existing.name,\n            source: options.source || existing.source,\n            tags: options.tags || existing.tags,\n            metadata: options.metadata ? JSON.parse(JSON.stringify(options.metadata)) : existing.metadata,\n            confirmationToken,\n            consentTimestamp: options.doubleOptIn ? undefined : new Date(),\n            consentIp: options.consentIp,\n            consentSource: options.source,\n            unsubscribedAt: null,\n          },\n        })\n\n        if (options.doubleOptIn && confirmationToken) {\n          await sendConfirmationEmail(normalizedEmail, confirmationToken)\n          return { success: true, subscriber: updated, needsConfirmation: true }\n        }\n\n        return { success: true, subscriber: updated }\n      }\n\n      // Cannot resubscribe bounced or complained\n      if (['BOUNCED', 'COMPLAINED'].includes(existing.status)) {\n        return { success: false, error: 'This email address cannot be resubscribed' }\n      }\n    }\n\n    // Create new subscriber\n    const confirmationToken = options.doubleOptIn ? generateSubscriptionToken(normalizedEmail) : undefined\n\n    const subscriber = await prisma.emailSubscriber.create({\n      data: {\n        email: normalizedEmail,\n        firstName: options.firstName,\n        lastName: options.lastName,\n        name: options.name,\n        status: options.doubleOptIn ? 'PENDING' : 'ACTIVE',\n        source: options.source,\n        tags: options.tags || [],\n        metadata: options.metadata ? JSON.parse(JSON.stringify(options.metadata)) : undefined,\n        confirmationToken,\n        consentTimestamp: options.doubleOptIn ? undefined : new Date(),\n        consentIp: options.consentIp,\n        consentSource: options.source,\n      },\n    })\n\n    if (options.doubleOptIn && confirmationToken) {\n      await sendConfirmationEmail(normalizedEmail, confirmationToken)\n      return { success: true, subscriber, needsConfirmation: true }\n    }\n\n    return { success: true, subscriber }\n  } catch (error) {\n    console.error('Error subscribing email:', error)\n    return { success: false, error: 'Failed to subscribe' }\n  }\n}\n\n/**\n * Confirm email subscription (double opt-in)\n */\nexport async function confirmSubscription(\n  token: string\n): Promise<{ success: boolean; subscriber?: unknown; error?: string }> {\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { confirmationToken: token },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Invalid or expired confirmation token' }\n    }\n\n    if (subscriber.status === 'ACTIVE') {\n      return { success: true, subscriber, error: 'Already confirmed' }\n    }\n\n    const updated = await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        status: 'ACTIVE',\n        confirmedAt: new Date(),\n        consentTimestamp: new Date(),\n        confirmationToken: null,\n      },\n    })\n\n    return { success: true, subscriber: updated }\n  } catch (error) {\n    console.error('Error confirming subscription:', error)\n    return { success: false, error: 'Failed to confirm subscription' }\n  }\n}\n\n/**\n * Unsubscribe an email address\n */\nexport async function unsubscribeEmail(\n  email: string,\n  options: {\n    token?: string\n    reason?: string\n    campaignId?: string\n  } = {}\n): Promise<{ success: boolean; error?: string }> {\n  const normalizedEmail = email.toLowerCase().trim()\n\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { email: normalizedEmail },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    if (subscriber.status === 'UNSUBSCRIBED') {\n      return { success: true, error: 'Already unsubscribed' }\n    }\n\n    await prisma.emailSubscriber.update({\n      where: { email: normalizedEmail },\n      data: {\n        status: 'UNSUBSCRIBED',\n        unsubscribedAt: new Date(),\n        metadata: {\n          ...(subscriber.metadata as Record<string, unknown> || {}),\n          unsubscribeReason: options.reason,\n          unsubscribeCampaignId: options.campaignId,\n        },\n      },\n    })\n\n    // Update campaign unsubscribe count\n    if (options.campaignId) {\n      await prisma.emailCampaign.update({\n        where: { id: options.campaignId },\n        data: {\n          unsubscribeCount: { increment: 1 },\n        },\n      })\n    }\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error unsubscribing email:', error)\n    return { success: false, error: 'Failed to unsubscribe' }\n  }\n}\n\n/**\n * Unsubscribe by subscriber ID\n */\nexport async function unsubscribeById(\n  subscriberId: string,\n  options: {\n    token?: string\n    reason?: string\n    campaignId?: string\n  } = {}\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberId },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    return unsubscribeEmail(subscriber.email, options)\n  } catch (error) {\n    console.error('Error unsubscribing by ID:', error)\n    return { success: false, error: 'Failed to unsubscribe' }\n  }\n}\n\n/**\n * Get subscriber preferences\n */\nexport async function getSubscriberPreferences(\n  subscriberIdOrEmail: string\n): Promise<{\n  success: boolean\n  subscriber?: {\n    id: string\n    email: string\n    firstName?: string | null\n    lastName?: string | null\n    status: string\n    tags: string[]\n    preferences: Record<string, unknown>\n  }\n  error?: string\n}> {\n  try {\n    // Try to find by ID first, then by email\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    return {\n      success: true,\n      subscriber: {\n        id: subscriber.id,\n        email: subscriber.email,\n        firstName: subscriber.firstName,\n        lastName: subscriber.lastName,\n        status: subscriber.status,\n        tags: subscriber.tags,\n        preferences: (subscriber.preferences as Record<string, unknown>) || {},\n      },\n    }\n  } catch (error) {\n    console.error('Error getting subscriber preferences:', error)\n    return { success: false, error: 'Failed to get preferences' }\n  }\n}\n\n/**\n * Update subscriber preferences\n */\nexport async function updateSubscriberPreferences(\n  subscriberIdOrEmail: string,\n  preferences: {\n    firstName?: string\n    lastName?: string\n    emailPreferences?: {\n      marketing?: boolean\n      transactional?: boolean\n      productUpdates?: boolean\n      newsletter?: boolean\n      frequency?: 'daily' | 'weekly' | 'monthly'\n    }\n    tags?: string[]\n  }\n): Promise<{ success: boolean; subscriber?: unknown; error?: string }> {\n  try {\n    // Try to find by ID first, then by email\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const currentPrefs = (subscriber.preferences as Record<string, unknown>) || {}\n\n    const updated = await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        firstName: preferences.firstName ?? subscriber.firstName,\n        lastName: preferences.lastName ?? subscriber.lastName,\n        tags: preferences.tags ?? subscriber.tags,\n        preferences: {\n          ...currentPrefs,\n          ...preferences.emailPreferences,\n        },\n      },\n    })\n\n    return { success: true, subscriber: updated }\n  } catch (error) {\n    console.error('Error updating subscriber preferences:', error)\n    return { success: false, error: 'Failed to update preferences' }\n  }\n}\n\n/**\n * Send confirmation email for double opt-in\n */\nasync function sendConfirmationEmail(email: string, token: string): Promise<void> {\n  // Import dynamically to avoid circular dependency\n  const { sendEmail } = await import('./index')\n\n  const confirmUrl = `${APP_URL}/api/email/confirm?token=${token}`\n\n  await sendEmail({\n    to: { email },\n    subject: 'Please confirm your subscription',\n    html: `\n      <!DOCTYPE html>\n      <html>\n      <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      </head>\n      <body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5;\">\n        <div style=\"max-width: 600px; margin: 0 auto; background: white; border-radius: 8px; padding: 40px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\">\n          <h1 style=\"margin: 0 0 20px; color: #333; font-size: 24px;\">Confirm your subscription</h1>\n          <p style=\"margin: 0 0 20px; color: #666; line-height: 1.6;\">\n            Thank you for subscribing! Please click the button below to confirm your email address.\n          </p>\n          <a href=\"${confirmUrl}\" style=\"display: inline-block; background: #0066cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: 600;\">\n            Confirm Subscription\n          </a>\n          <p style=\"margin: 20px 0 0; color: #999; font-size: 14px;\">\n            If you didn't subscribe, you can safely ignore this email.\n          </p>\n        </div>\n      </body>\n      </html>\n    `,\n    text: `\n      Confirm your subscription\n\n      Thank you for subscribing! Please click the link below to confirm your email address:\n\n      ${confirmUrl}\n\n      If you didn't subscribe, you can safely ignore this email.\n    `,\n  })\n}\n\n/**\n * Add tags to a subscriber\n */\nexport async function addSubscriberTags(\n  subscriberIdOrEmail: string,\n  tags: string[]\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const currentTags = new Set(subscriber.tags)\n    tags.forEach((tag) => currentTags.add(tag))\n\n    await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        tags: Array.from(currentTags),\n      },\n    })\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error adding subscriber tags:', error)\n    return { success: false, error: 'Failed to add tags' }\n  }\n}\n\n/**\n * Remove tags from a subscriber\n */\nexport async function removeSubscriberTags(\n  subscriberIdOrEmail: string,\n  tags: string[]\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const tagsToRemove = new Set(tags)\n    const newTags = subscriber.tags.filter((tag) => !tagsToRemove.has(tag))\n\n    await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        tags: newTags,\n      },\n    })\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error removing subscriber tags:', error)\n    return { success: false, error: 'Failed to remove tags' }\n  }\n}\n","/**\n * Email Queue Service\n *\n * Async email queue with retry logic, rate limiting, and batch processing.\n * Uses in-memory queue with optional database persistence for reliability.\n */\n\nimport { prisma } from '../db'\nimport { sendEmail, sendBulkEmail, EmailMessage, BulkEmailMessage, EmailSendResult, BulkEmailResult } from './index'\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport type EmailPriority = 'high' | 'normal' | 'low'\nexport type EmailStatus = 'pending' | 'processing' | 'sent' | 'failed' | 'cancelled'\n\nexport interface QueuedEmail {\n  id: string\n  message: EmailMessage\n  priority: EmailPriority\n  status: EmailStatus\n  attempts: number\n  maxAttempts: number\n  scheduledFor?: Date\n  lastAttemptAt?: Date\n  lastError?: string\n  createdAt: Date\n  sentAt?: Date\n  result?: EmailSendResult\n}\n\nexport interface QueueOptions {\n  /** Maximum concurrent sends */\n  concurrency?: number\n  /** Rate limit: max emails per second */\n  rateLimit?: number\n  /** Default max retry attempts */\n  maxAttempts?: number\n  /** Base delay between retries in ms (doubles each attempt) */\n  retryDelay?: number\n  /** Process interval in ms */\n  processInterval?: number\n  /** Enable database persistence */\n  persistToDb?: boolean\n}\n\nexport interface EnqueueOptions {\n  priority?: EmailPriority\n  maxAttempts?: number\n  scheduledFor?: Date\n  /** Unique key to prevent duplicates */\n  deduplicationKey?: string\n}\n\nexport interface QueueStats {\n  pending: number\n  processing: number\n  sent: number\n  failed: number\n  total: number\n  averageProcessingTime?: number\n}\n\n// =============================================================================\n// EMAIL QUEUE CLASS\n// =============================================================================\n\nexport class EmailQueue {\n  private queue: Map<string, QueuedEmail> = new Map()\n  private processing: Set<string> = new Set()\n  private deduplicationKeys: Set<string> = new Set()\n  private isProcessing = false\n  private processTimer: NodeJS.Timeout | null = null\n  private options: Required<QueueOptions>\n  private lastSendTime = 0\n  private sendCount = 0\n  private totalProcessingTime = 0\n  private processedCount = 0\n\n  constructor(options: QueueOptions = {}) {\n    this.options = {\n      concurrency: options.concurrency ?? 5,\n      rateLimit: options.rateLimit ?? 10, // 10 emails/second default\n      maxAttempts: options.maxAttempts ?? 3,\n      retryDelay: options.retryDelay ?? 1000,\n      processInterval: options.processInterval ?? 1000,\n      persistToDb: options.persistToDb ?? false,\n    }\n  }\n\n  /**\n   * Enqueue an email for sending\n   */\n  async enqueue(message: EmailMessage, options: EnqueueOptions = {}): Promise<string> {\n    const id = this.generateId()\n    const now = new Date()\n\n    // Check deduplication\n    if (options.deduplicationKey) {\n      if (this.deduplicationKeys.has(options.deduplicationKey)) {\n        throw new Error(`Duplicate email: ${options.deduplicationKey}`)\n      }\n      this.deduplicationKeys.add(options.deduplicationKey)\n    }\n\n    const queuedEmail: QueuedEmail = {\n      id,\n      message,\n      priority: options.priority ?? 'normal',\n      status: 'pending',\n      attempts: 0,\n      maxAttempts: options.maxAttempts ?? this.options.maxAttempts,\n      scheduledFor: options.scheduledFor,\n      createdAt: now,\n    }\n\n    this.queue.set(id, queuedEmail)\n\n    // Persist to database if enabled\n    if (this.options.persistToDb) {\n      await this.persistEmail(queuedEmail)\n    }\n\n    // Start processing if not already running\n    this.startProcessing()\n\n    return id\n  }\n\n  /**\n   * Enqueue multiple emails\n   */\n  async enqueueBatch(\n    messages: EmailMessage[],\n    options: EnqueueOptions = {}\n  ): Promise<string[]> {\n    const ids: string[] = []\n\n    for (const message of messages) {\n      const id = await this.enqueue(message, options)\n      ids.push(id)\n    }\n\n    return ids\n  }\n\n  /**\n   * Get email status by ID\n   */\n  getStatus(id: string): QueuedEmail | undefined {\n    return this.queue.get(id)\n  }\n\n  /**\n   * Cancel a pending email\n   */\n  cancel(id: string): boolean {\n    const email = this.queue.get(id)\n    if (!email || email.status !== 'pending') {\n      return false\n    }\n\n    email.status = 'cancelled'\n    return true\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getStats(): QueueStats {\n    const stats: QueueStats = {\n      pending: 0,\n      processing: 0,\n      sent: 0,\n      failed: 0,\n      total: this.queue.size,\n    }\n\n    for (const email of this.queue.values()) {\n      switch (email.status) {\n        case 'pending':\n          stats.pending++\n          break\n        case 'processing':\n          stats.processing++\n          break\n        case 'sent':\n          stats.sent++\n          break\n        case 'failed':\n          stats.failed++\n          break\n      }\n    }\n\n    if (this.processedCount > 0) {\n      stats.averageProcessingTime = this.totalProcessingTime / this.processedCount\n    }\n\n    return stats\n  }\n\n  /**\n   * Start queue processing\n   */\n  start(): void {\n    this.startProcessing()\n  }\n\n  /**\n   * Stop queue processing\n   */\n  stop(): void {\n    this.isProcessing = false\n    if (this.processTimer) {\n      clearTimeout(this.processTimer)\n      this.processTimer = null\n    }\n  }\n\n  /**\n   * Clear completed/failed emails from queue\n   */\n  clear(options: { keepPending?: boolean } = {}): number {\n    const { keepPending = true } = options\n    let cleared = 0\n\n    for (const [id, email] of this.queue.entries()) {\n      if (email.status === 'sent' || email.status === 'failed' || email.status === 'cancelled') {\n        this.queue.delete(id)\n        cleared++\n      } else if (!keepPending && email.status === 'pending') {\n        this.queue.delete(id)\n        cleared++\n      }\n    }\n\n    return cleared\n  }\n\n  /**\n   * Retry failed emails\n   */\n  async retryFailed(): Promise<number> {\n    let retriedCount = 0\n\n    for (const email of this.queue.values()) {\n      if (email.status === 'failed' && email.attempts < email.maxAttempts) {\n        email.status = 'pending'\n        email.lastError = undefined\n        retriedCount++\n      }\n    }\n\n    if (retriedCount > 0) {\n      this.startProcessing()\n    }\n\n    return retriedCount\n  }\n\n  // =============================================================================\n  // PRIVATE METHODS\n  // =============================================================================\n\n  private generateId(): string {\n    return `email_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n  }\n\n  private startProcessing(): void {\n    if (this.isProcessing) return\n\n    this.isProcessing = true\n    this.scheduleProcess()\n  }\n\n  private scheduleProcess(): void {\n    if (!this.isProcessing) return\n\n    this.processTimer = setTimeout(async () => {\n      await this.process()\n      this.scheduleProcess()\n    }, this.options.processInterval)\n  }\n\n  private async process(): Promise<void> {\n    // Get pending emails sorted by priority\n    const pending = this.getPendingEmails()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    // Respect rate limiting\n    const now = Date.now()\n    if (now - this.lastSendTime < 1000) {\n      if (this.sendCount >= this.options.rateLimit) {\n        return // Rate limited\n      }\n    } else {\n      this.sendCount = 0\n      this.lastSendTime = now\n    }\n\n    // Process up to concurrency limit\n    const toProcess = pending.slice(0, this.options.concurrency - this.processing.size)\n\n    const promises = toProcess.map(email => this.processEmail(email))\n    await Promise.allSettled(promises)\n  }\n\n  private getPendingEmails(): QueuedEmail[] {\n    const now = new Date()\n    const pending: QueuedEmail[] = []\n\n    for (const email of this.queue.values()) {\n      if (email.status !== 'pending') continue\n      if (this.processing.has(email.id)) continue\n      if (email.scheduledFor && email.scheduledFor > now) continue\n\n      // Check retry delay\n      if (email.lastAttemptAt) {\n        const delay = this.calculateRetryDelay(email.attempts)\n        const nextAttempt = new Date(email.lastAttemptAt.getTime() + delay)\n        if (nextAttempt > now) continue\n      }\n\n      pending.push(email)\n    }\n\n    // Sort by priority (high > normal > low)\n    const priorityOrder: Record<EmailPriority, number> = {\n      high: 0,\n      normal: 1,\n      low: 2,\n    }\n\n    pending.sort((a, b) => {\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority]\n      if (priorityDiff !== 0) return priorityDiff\n      return a.createdAt.getTime() - b.createdAt.getTime()\n    })\n\n    return pending\n  }\n\n  private calculateRetryDelay(attempts: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, etc.\n    return this.options.retryDelay * Math.pow(2, attempts)\n  }\n\n  private async processEmail(email: QueuedEmail): Promise<void> {\n    if (this.processing.has(email.id)) return\n\n    this.processing.add(email.id)\n    email.status = 'processing'\n    const startTime = Date.now()\n\n    try {\n      const result = await sendEmail(email.message)\n\n      email.attempts++\n      email.lastAttemptAt = new Date()\n      email.result = result\n\n      if (result.success) {\n        email.status = 'sent'\n        email.sentAt = new Date()\n        this.sendCount++\n      } else {\n        email.lastError = result.error\n        if (email.attempts >= email.maxAttempts) {\n          email.status = 'failed'\n        } else {\n          email.status = 'pending' // Will retry\n        }\n      }\n\n      // Update stats\n      this.processedCount++\n      this.totalProcessingTime += Date.now() - startTime\n\n      // Update database if persisting\n      if (this.options.persistToDb) {\n        await this.updatePersistedEmail(email)\n      }\n    } catch (error) {\n      email.attempts++\n      email.lastAttemptAt = new Date()\n      email.lastError = error instanceof Error ? error.message : 'Unknown error'\n\n      if (email.attempts >= email.maxAttempts) {\n        email.status = 'failed'\n      } else {\n        email.status = 'pending'\n      }\n    } finally {\n      this.processing.delete(email.id)\n    }\n  }\n\n  private async persistEmail(email: QueuedEmail): Promise<void> {\n    try {\n      await prisma.emailQueueItem.create({\n        data: {\n          id: email.id,\n          message: email.message as never,\n          priority: email.priority,\n          status: email.status,\n          attempts: email.attempts,\n          maxAttempts: email.maxAttempts,\n          scheduledFor: email.scheduledFor,\n          createdAt: email.createdAt,\n        },\n      })\n    } catch (error) {\n      console.error('Failed to persist email to database:', error)\n    }\n  }\n\n  private async updatePersistedEmail(email: QueuedEmail): Promise<void> {\n    try {\n      await prisma.emailQueueItem.update({\n        where: { id: email.id },\n        data: {\n          status: email.status,\n          attempts: email.attempts,\n          lastAttemptAt: email.lastAttemptAt,\n          lastError: email.lastError,\n          sentAt: email.sentAt,\n          result: email.result as never,\n        },\n      })\n    } catch (error) {\n      console.error('Failed to update persisted email:', error)\n    }\n  }\n\n  /**\n   * Load pending emails from database on startup\n   */\n  async loadFromDatabase(): Promise<number> {\n    if (!this.options.persistToDb) return 0\n\n    try {\n      const items = await prisma.emailQueueItem.findMany({\n        where: {\n          status: { in: ['pending', 'processing'] },\n        },\n      })\n\n      for (const item of items) {\n        const queuedEmail: QueuedEmail = {\n          id: item.id,\n          message: item.message as unknown as EmailMessage,\n          priority: item.priority as EmailPriority,\n          status: 'pending', // Reset processing items to pending\n          attempts: item.attempts,\n          maxAttempts: item.maxAttempts,\n          scheduledFor: item.scheduledFor ?? undefined,\n          lastAttemptAt: item.lastAttemptAt ?? undefined,\n          lastError: item.lastError ?? undefined,\n          createdAt: item.createdAt,\n        }\n\n        this.queue.set(item.id, queuedEmail)\n      }\n\n      if (items.length > 0) {\n        this.startProcessing()\n      }\n\n      return items.length\n    } catch (error) {\n      console.error('Failed to load emails from database:', error)\n      return 0\n    }\n  }\n}\n\n// =============================================================================\n// SINGLETON INSTANCE\n// =============================================================================\n\nlet queueInstance: EmailQueue | null = null\n\nexport function getEmailQueue(options?: QueueOptions): EmailQueue {\n  if (!queueInstance) {\n    queueInstance = new EmailQueue(options)\n  }\n  return queueInstance\n}\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Queue an email for async sending\n */\nexport async function queueEmail(\n  message: EmailMessage,\n  options?: EnqueueOptions\n): Promise<string> {\n  const queue = getEmailQueue()\n  return queue.enqueue(message, options)\n}\n\n/**\n * Queue multiple emails for async sending\n */\nexport async function queueEmails(\n  messages: EmailMessage[],\n  options?: EnqueueOptions\n): Promise<string[]> {\n  const queue = getEmailQueue()\n  return queue.enqueueBatch(messages, options)\n}\n\n/**\n * Queue a high-priority email\n */\nexport async function queueUrgentEmail(\n  message: EmailMessage,\n  options?: Omit<EnqueueOptions, 'priority'>\n): Promise<string> {\n  return queueEmail(message, { ...options, priority: 'high' })\n}\n\n/**\n * Schedule an email for later\n */\nexport async function scheduleEmail(\n  message: EmailMessage,\n  sendAt: Date,\n  options?: EnqueueOptions\n): Promise<string> {\n  return queueEmail(message, { ...options, scheduledFor: sendAt })\n}\n\n/**\n * Get queue status\n */\nexport function getQueueStats(): QueueStats {\n  const queue = getEmailQueue()\n  return queue.getStats()\n}\n\n/**\n * Check email status\n */\nexport function checkEmailStatus(id: string): QueuedEmail | undefined {\n  const queue = getEmailQueue()\n  return queue.getStatus(id)\n}\n","/**\n * Email Service\n *\n * Multi-provider email sending abstraction with tracking support\n */\n\nimport type {\n  EmailProvider,\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  EmailServiceConfig,\n  SmtpConfig,\n  SendGridConfig,\n  ResendConfig,\n  MailgunConfig,\n  SesConfig,\n  EmailAddress,\n} from './types'\nimport { SmtpProvider, SendGridProvider, ResendProvider, MailgunProvider, SesProvider } from './providers'\nimport { parseMergeTags, type MergeTagData } from './merge-tags'\nimport { getEmailSettings, type EmailSettings } from '../settings'\n\nexport * from './types'\nexport * from './merge-tags'\nexport * from './tracking'\nexport * from './webhooks'\nexport * from './subscriptions'\nexport * from './queue'\n\n// Singleton provider instance\nlet providerInstance: IEmailProvider | null = null\nlet currentProviderName: EmailProvider | null = null\n\n/**\n * Create a provider instance based on configuration\n */\nfunction createProvider(settings: EmailSettings): IEmailProvider {\n  switch (settings.provider) {\n    case 'smtp':\n      return new SmtpProvider({\n        host: settings.smtpHost!,\n        port: settings.smtpPort!,\n        secure: settings.smtpSecure,\n        user: settings.smtpUser,\n        pass: settings.smtpPass,\n      })\n\n    case 'sendgrid':\n      return new SendGridProvider({\n        apiKey: settings.sendgridApiKey!,\n      })\n\n    case 'resend':\n      return new ResendProvider({\n        apiKey: settings.resendApiKey!,\n      })\n\n    case 'mailgun':\n      return new MailgunProvider({\n        apiKey: settings.mailgunApiKey!,\n        domain: settings.mailgunDomain!,\n      })\n\n    case 'ses':\n      return new SesProvider({\n        region: settings.sesRegion!,\n        accessKeyId: settings.sesAccessKeyId!,\n        secretAccessKey: settings.sesSecretAccessKey!,\n      })\n\n    default:\n      throw new Error(`Unknown email provider: ${settings.provider}`)\n  }\n}\n\n/**\n * Get the email provider instance\n */\nasync function getProvider(): Promise<IEmailProvider> {\n  const settings = await getEmailSettings()\n\n  // If provider changed, recreate instance\n  if (currentProviderName !== settings.provider) {\n    if (providerInstance?.close) {\n      await providerInstance.close()\n    }\n    providerInstance = null\n    currentProviderName = null\n  }\n\n  if (!providerInstance) {\n    providerInstance = createProvider(settings)\n    currentProviderName = settings.provider\n  }\n\n  return providerInstance\n}\n\n/**\n * Get default from address from settings\n */\nasync function getDefaultFrom(): Promise<EmailAddress> {\n  const settings = await getEmailSettings()\n  return {\n    email: settings.fromEmail || 'noreply@example.com',\n    name: settings.fromName,\n  }\n}\n\n/**\n * Get default reply-to from settings\n */\nasync function getDefaultReplyTo(): Promise<EmailAddress | undefined> {\n  const settings = await getEmailSettings()\n  return settings.replyTo ? { email: settings.replyTo } : undefined\n}\n\n/**\n * Email Service Class\n */\nexport class EmailService {\n  private provider: IEmailProvider | null = null\n  private config: EmailServiceConfig | null = null\n\n  /**\n   * Initialize with explicit configuration (for testing)\n   */\n  initWithConfig(\n    providerType: EmailProvider,\n    providerConfig: SmtpConfig | SendGridConfig | ResendConfig | MailgunConfig | SesConfig,\n    serviceConfig: Partial<EmailServiceConfig>\n  ): void {\n    switch (providerType) {\n      case 'smtp':\n        this.provider = new SmtpProvider(providerConfig as SmtpConfig)\n        break\n      case 'sendgrid':\n        this.provider = new SendGridProvider(providerConfig as SendGridConfig)\n        break\n      case 'resend':\n        this.provider = new ResendProvider(providerConfig as ResendConfig)\n        break\n      case 'mailgun':\n        this.provider = new MailgunProvider(providerConfig as MailgunConfig)\n        break\n      case 'ses':\n        this.provider = new SesProvider(providerConfig as SesConfig)\n        break\n    }\n\n    this.config = {\n      provider: providerType,\n      defaultFrom: serviceConfig.defaultFrom || { email: 'noreply@example.com' },\n      ...serviceConfig,\n    }\n  }\n\n  /**\n   * Get provider (lazy load from settings if not initialized)\n   */\n  private async getProvider(): Promise<IEmailProvider> {\n    if (this.provider) {\n      return this.provider\n    }\n    return getProvider()\n  }\n\n  /**\n   * Send a single email\n   */\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n    if (!message.replyTo) {\n      message.replyTo = this.config?.defaultReplyTo || (await getDefaultReplyTo())\n    }\n\n    return provider.send(message)\n  }\n\n  /**\n   * Send email with merge tags\n   */\n  async sendWithMergeTags(\n    message: Omit<EmailMessage, 'subject' | 'html' | 'text'> & {\n      subjectTemplate: string\n      htmlTemplate?: string\n      textTemplate?: string\n    },\n    data: MergeTagData\n  ): Promise<EmailSendResult> {\n    const subject = parseMergeTags(message.subjectTemplate, data)\n    const html = message.htmlTemplate ? parseMergeTags(message.htmlTemplate, data) : undefined\n    const text = message.textTemplate ? parseMergeTags(message.textTemplate, data) : undefined\n\n    return this.send({\n      ...message,\n      subject,\n      html,\n      text,\n    })\n  }\n\n  /**\n   * Send bulk emails\n   */\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n    if (!message.replyTo) {\n      message.replyTo = this.config?.defaultReplyTo || (await getDefaultReplyTo())\n    }\n\n    // Use bulk if available, otherwise send individually\n    if (provider.sendBulk) {\n      return provider.sendBulk(message)\n    }\n\n    // Fallback to individual sends\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const result = await provider.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: provider.name,\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  /**\n   * Send bulk emails with per-recipient merge tags\n   */\n  async sendBulkWithMergeTags(\n    message: Omit<BulkEmailMessage, 'subject' | 'html' | 'text'> & {\n      subjectTemplate: string\n      htmlTemplate?: string\n      textTemplate?: string\n    },\n    recipientData: Map<string, MergeTagData>\n  ): Promise<BulkEmailResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n\n    // For bulk with merge tags, we need to send individually to process templates\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const data = recipientData.get(recipient.to.email) || {}\n\n      const subject = parseMergeTags(message.subjectTemplate, data)\n      const html = message.htmlTemplate ? parseMergeTags(message.htmlTemplate, data) : undefined\n      const text = message.textTemplate ? parseMergeTags(message.textTemplate, data) : undefined\n\n      const result = await provider.send({\n        ...message,\n        to: recipient.to,\n        subject,\n        html,\n        text,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: provider.name,\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  /**\n   * Verify provider configuration\n   */\n  async verify(): Promise<boolean> {\n    const provider = await this.getProvider()\n    return provider.verify()\n  }\n\n  /**\n   * Get current provider name\n   */\n  async getProviderName(): Promise<EmailProvider> {\n    const provider = await this.getProvider()\n    return provider.name\n  }\n\n  /**\n   * Close provider connections\n   */\n  async close(): Promise<void> {\n    if (this.provider?.close) {\n      await this.provider.close()\n    }\n    this.provider = null\n\n    // Also close singleton\n    if (providerInstance?.close) {\n      await providerInstance.close()\n    }\n    providerInstance = null\n    currentProviderName = null\n  }\n}\n\n// Export singleton instance\nexport const emailService = new EmailService()\n\n// Convenience functions\nexport async function sendEmail(message: EmailMessage): Promise<EmailSendResult> {\n  return emailService.send(message)\n}\n\nexport async function sendBulkEmail(message: BulkEmailMessage): Promise<BulkEmailResult> {\n  return emailService.sendBulk(message)\n}\n\nexport async function sendEmailWithMergeTags(\n  message: Omit<EmailMessage, 'subject' | 'html' | 'text'> & {\n    subjectTemplate: string\n    htmlTemplate?: string\n    textTemplate?: string\n  },\n  data: MergeTagData\n): Promise<EmailSendResult> {\n  return emailService.sendWithMergeTags(message, data)\n}\n"]}