{"version":3,"sources":["../../src/lib/mcp/auth.ts","../../src/lib/mcp/context.ts","../../src/lib/mcp/utils.ts","../../src/lib/mcp/index.ts"],"sourcesContent":["/**\n * MCP Auth Utilities\n *\n * Provides API key generation, hashing, and validation for MCP clients.\n * Keys use the format: cms_<32 base64url chars>\n */\n\nimport crypto from \"crypto\"\n\n/**\n * Key prefix for CMS MCP API keys\n */\nexport const API_KEY_PREFIX = \"cms_\"\n\n/**\n * Generate a new API key\n * Format: cms_<32 random base64url characters>\n *\n * @returns Object with raw key (show once) and hash (store in DB)\n */\nexport function generateApiKey(): { key: string; hash: string; prefix: string } {\n  // Generate 24 random bytes = 32 base64url characters\n  const randomBytes = crypto.randomBytes(24)\n  const keyBody = randomBytes\n    .toString(\"base64url\")\n    .replace(/[+/=]/g, (c) =>\n      c === \"+\" ? \"-\" : c === \"/\" ? \"_\" : \"\"\n    )\n\n  const key = `${API_KEY_PREFIX}${keyBody}`\n  const hash = hashApiKey(key)\n  const prefix = key.substring(0, 8) // \"cms_xxxx\"\n\n  return { key, hash, prefix }\n}\n\n/**\n * Hash an API key for storage/comparison\n * Uses SHA-256 for fast, secure hashing\n */\nexport function hashApiKey(key: string): string {\n  return crypto.createHash(\"sha256\").update(key).digest(\"hex\")\n}\n\n/**\n * Validate API key format\n */\nexport function isValidApiKeyFormat(key: string): boolean {\n  if (!key.startsWith(API_KEY_PREFIX)) {\n    return false\n  }\n\n  // cms_ + 32 base64url chars = 36 total\n  if (key.length < 36) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Extract key from Authorization header\n * Supports: \"Bearer cms_xxx\" or just \"cms_xxx\"\n */\nexport function extractApiKey(authHeader: string | null): string | null {\n  if (!authHeader) return null\n\n  // Handle Bearer token format\n  if (authHeader.startsWith(\"Bearer \")) {\n    return authHeader.replace(\"Bearer \", \"\").trim()\n  }\n\n  // Handle raw key\n  if (authHeader.startsWith(API_KEY_PREFIX)) {\n    return authHeader.trim()\n  }\n\n  return null\n}\n","/**\n * MCP Request Context\n *\n * Provides request-scoped user context for MCP tools using AsyncLocalStorage.\n * This allows tools to access the authenticated user's ID without passing it\n * through every function call.\n */\n\nimport { AsyncLocalStorage } from \"async_hooks\"\nimport { prisma } from \"../db\"\nimport { hashApiKey, extractApiKey, isValidApiKeyFormat } from \"./auth\"\n\n/**\n * MCP-specific context including user info and permissions\n */\nexport interface McpContext {\n  /** Internal database user ID */\n  userId: string\n  /** API key ID used for authentication */\n  apiKeyId: string\n  /** Scopes granted to this API key */\n  scopes: string[]\n  /** User's email (for logging) */\n  email?: string\n}\n\n// AsyncLocalStorage for request-scoped context\nconst mcpContextStorage = new AsyncLocalStorage<McpContext>()\n\n/**\n * Validate an MCP API key and return context\n *\n * Accepts keys in format: cms_<32 base64url chars>\n * Via headers: X-API-Key or Authorization: Bearer\n */\nexport async function validateMcpApiKey(\n  apiKeyOrHeader: string | null\n): Promise<McpContext | null> {\n  const apiKey = extractApiKey(apiKeyOrHeader)\n\n  if (!apiKey || !isValidApiKeyFormat(apiKey)) {\n    return null\n  }\n\n  const keyHash = hashApiKey(apiKey)\n\n  try {\n    const keyRecord = await prisma.apiKey.findFirst({\n      where: {\n        keyHash,\n        revokedAt: null,\n        OR: [\n          { expiresAt: null },\n          { expiresAt: { gt: new Date() } }\n        ]\n      },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true\n          }\n        }\n      }\n    })\n\n    if (!keyRecord) {\n      return null\n    }\n\n    // Update last_used_at asynchronously (don't await)\n    prisma.apiKey.update({\n      where: { id: keyRecord.id },\n      data: { lastUsedAt: new Date() }\n    }).catch((err) =>\n      console.error(\"Failed to update MCP API key last_used_at:\", err)\n    )\n\n    return {\n      userId: keyRecord.userId,\n      apiKeyId: keyRecord.id,\n      scopes: keyRecord.scopes || [\"read\", \"write\"],\n      email: keyRecord.user.email\n    }\n  } catch (error) {\n    console.error(\"MCP API key validation error:\", error)\n    return null\n  }\n}\n\n/**\n * Run a function with MCP context\n *\n * Usage:\n * ```ts\n * await runWithMcpContext(context, async () => {\n *   // Tools can call getMcpContext() here\n * });\n * ```\n */\nexport function runWithMcpContext<T>(\n  context: McpContext,\n  fn: () => T | Promise<T>\n): T | Promise<T> {\n  return mcpContextStorage.run(context, fn)\n}\n\n/**\n * Get the current MCP context\n *\n * @throws Error if called outside of MCP context\n */\nexport function getMcpContext(): McpContext {\n  const context = mcpContextStorage.getStore()\n  if (!context) {\n    throw new Error(\"MCP context not available - called outside of MCP request\")\n  }\n  return context\n}\n\n/**\n * Get the current MCP context (nullable version)\n *\n * Returns null if called outside of MCP context\n */\nexport function getMcpContextOrNull(): McpContext | null {\n  return mcpContextStorage.getStore() || null\n}\n\n/**\n * Get the current user ID from MCP context\n *\n * @throws Error if called outside of MCP context\n */\nexport function getMcpUserId(): string {\n  return getMcpContext().userId\n}\n\n/**\n * Check if the current MCP context has a specific scope\n */\nexport function hasMcpScope(scope: string): boolean {\n  const context = getMcpContextOrNull()\n  if (!context) return false\n  return context.scopes.includes(scope)\n}\n\n/**\n * Require a specific scope, throwing if not present\n *\n * @throws Error if scope not present\n */\nexport function requireMcpScope(scope: string): void {\n  if (!hasMcpScope(scope)) {\n    throw new Error(`MCP operation requires '${scope}' scope`)\n  }\n}\n","/**\n * MCP Utility Functions\n *\n * Token optimization and response helpers for MCP tools.\n */\n\n/**\n * Compact JSON response - removes whitespace for ~30-40% token savings\n */\nexport function compactJson(data: unknown): string {\n  return JSON.stringify(data)\n}\n\n/**\n * Truncate string to max length with ellipsis\n */\nexport function truncate(\n  str: string | null | undefined,\n  maxLength: number\n): string | null {\n  if (!str) return null\n  if (str.length <= maxLength) return str\n  return str.substring(0, maxLength - 3) + \"...\"\n}\n\n/**\n * Pick only specified fields from an object\n */\nexport function pickFields<T extends Record<string, unknown>>(\n  obj: T,\n  fields: string[]\n): Partial<T> {\n  const result: Partial<T> = {}\n  for (const field of fields) {\n    if (field in obj) {\n      result[field as keyof T] = obj[field as keyof T]\n    }\n  }\n  return result\n}\n\n/**\n * Standard MCP response wrapper - always compact\n */\nexport function mcpResponse(data: unknown) {\n  return {\n    content: [{ type: \"text\" as const, text: compactJson(data) }]\n  }\n}\n\n/**\n * Standard MCP error response\n */\nexport function mcpError(message: string) {\n  return {\n    content: [{ type: \"text\" as const, text: compactJson({ error: message }) }]\n  }\n}\n\n// Default pagination limits\nexport const DEFAULT_LIMIT = 20\nexport const MAX_LIMIT = 100\n\n/**\n * Normalize pagination parameters\n */\nexport function normalizePagination(\n  limit?: number,\n  offset?: number\n): { limit: number; offset: number } {\n  return {\n    limit: Math.min(limit || DEFAULT_LIMIT, MAX_LIMIT),\n    offset: offset || 0\n  }\n}\n","/**\n * MCP (Model Context Protocol) Server Utilities\n *\n * This module provides utilities for building MCP servers that expose\n * CMS functionality to AI agents (Claude Code, Cursor, Windsurf, etc.)\n *\n * Key exports:\n * - Auth: API key generation and validation\n * - Context: Request-scoped user context via AsyncLocalStorage\n * - Utils: Response formatting and token optimization helpers\n */\n\n// Auth utilities\nexport {\n  API_KEY_PREFIX,\n  generateApiKey,\n  hashApiKey,\n  isValidApiKeyFormat,\n  extractApiKey\n} from \"./auth\"\n\n// Context utilities\nexport {\n  type McpContext,\n  validateMcpApiKey,\n  runWithMcpContext,\n  getMcpContext,\n  getMcpContextOrNull,\n  getMcpUserId,\n  hasMcpScope,\n  requireMcpScope\n} from \"./context\"\n\n// Response utilities\nexport {\n  compactJson,\n  truncate,\n  pickFields,\n  mcpResponse,\n  mcpError,\n  DEFAULT_LIMIT,\n  MAX_LIMIT,\n  normalizePagination\n} from \"./utils\"\n\n// Stub implementations for MCP server management\n// These functions provide safe defaults until full MCP integration is implemented\n\nexport interface McpServerStatus {\n  name: string;\n  connected: boolean;\n  toolCount: number;\n  source: 'file' | 'database';\n}\n\nexport interface McpConfig {\n  mcpServers: Record<string, unknown>;\n}\n\n/**\n * Load MCP configuration from file and database\n * Returns null if no MCP servers are configured\n */\nexport async function loadMcpConfig(): Promise<McpConfig | null> {\n  // TODO: Implement MCP config loading from .mcp.json and database\n  return null;\n}\n\n/**\n * Get status of all configured MCP servers\n */\nexport async function getMcpServerStatus(): Promise<McpServerStatus[]> {\n  // TODO: Implement MCP server status checking\n  return [];\n}\n\n/**\n * Get tools from all connected MCP servers\n * Returns an empty object if no MCP servers are connected\n */\nexport async function getMcpTools(): Promise<Record<string, unknown>> {\n  // TODO: Implement MCP tool fetching\n  return {};\n}\n\n/**\n * Invalidate cache for a specific MCP server\n * Called when server config is updated or deleted\n */\nexport async function invalidateMcpServerCache(_serverName: string): Promise<void> {\n  // TODO: Implement cache invalidation\n  return;\n}\n"],"mappings":"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","names":[]}