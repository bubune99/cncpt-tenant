{"version":3,"sources":["../src/lib/workflows/context.ts","../src/lib/workflows/primitive-adapter.ts","../src/lib/workflows/engine.ts"],"sourcesContent":["/**\n * Workflow Context & State Management\n *\n * Manages execution context, variable resolution, and state\n * throughout workflow execution.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  WorkflowContext,\n  WorkflowEvent,\n  InputMapping,\n  WorkflowCondition,\n} from './types';\n\n// =============================================================================\n// CONTEXT CREATION\n// =============================================================================\n\n/**\n * Create a new workflow execution context\n */\nexport function createWorkflowContext(\n  workflowId: string,\n  trigger: {\n    type: string;\n    data: unknown;\n    event?: WorkflowEvent;\n  },\n  initialVariables?: Record<string, unknown>\n): WorkflowContext {\n  return {\n    executionId: uuidv4(),\n    workflowId,\n    startedAt: new Date(),\n    trigger,\n    variables: initialVariables || {},\n    nodeOutputs: {},\n    executedNodes: [],\n    errors: [],\n  };\n}\n\n// =============================================================================\n// VARIABLE RESOLUTION\n// =============================================================================\n\n/**\n * Resolve a value from context using path notation\n * Supports: trigger.data.field, variables.name, nodes.nodeId.field\n */\nexport function resolveValue(context: WorkflowContext, path: string): unknown {\n  const parts = path.split('.');\n  let current: unknown = context;\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (typeof current !== 'object') {\n      return undefined;\n    }\n\n    // Handle special prefixes\n    if (part === 'trigger') {\n      current = context.trigger;\n    } else if (part === 'variables') {\n      current = context.variables;\n    } else if (part === 'nodes') {\n      current = context.nodeOutputs;\n    } else if (part === 'event') {\n      current = context.trigger.event;\n    } else {\n      current = (current as Record<string, unknown>)[part];\n    }\n  }\n\n  return current;\n}\n\n/**\n * Resolve input mapping to actual value\n */\nexport function resolveInputMapping(\n  mapping: string | InputMapping,\n  context: WorkflowContext\n): unknown {\n  // Simple string path\n  if (typeof mapping === 'string') {\n    // Check if it's a template string\n    if (mapping.includes('{{')) {\n      return resolveTemplate(mapping, context);\n    }\n    return resolveValue(context, mapping);\n  }\n\n  // Input mapping object\n  switch (mapping.type) {\n    case 'static':\n      return mapping.value;\n\n    case 'reference':\n      return resolveValue(context, mapping.path || mapping.value);\n\n    case 'expression':\n      return evaluateExpression(mapping.value, context);\n\n    case 'template':\n      return resolveTemplate(mapping.value, context);\n\n    default:\n      return mapping.value;\n  }\n}\n\n/**\n * Resolve all input mappings for a node\n */\nexport function resolveNodeInputs(\n  inputMapping: Record<string, string | InputMapping> | undefined,\n  context: WorkflowContext\n): Record<string, unknown> {\n  if (!inputMapping) return {};\n\n  const resolved: Record<string, unknown> = {};\n\n  for (const [key, mapping] of Object.entries(inputMapping)) {\n    resolved[key] = resolveInputMapping(mapping, context);\n  }\n\n  return resolved;\n}\n\n/**\n * Resolve template string with {{path}} placeholders\n */\nexport function resolveTemplate(template: string, context: WorkflowContext): string {\n  return template.replace(/\\{\\{([^}]+)\\}\\}/g, (_, path) => {\n    const value = resolveValue(context, path.trim());\n    return value !== undefined && value !== null ? String(value) : '';\n  });\n}\n\n// =============================================================================\n// EXPRESSION EVALUATION\n// =============================================================================\n\n/**\n * Safely evaluate an expression against context\n * Supports basic operations and context references\n */\nexport function evaluateExpression(expression: string, context: WorkflowContext): unknown {\n  // Create a safe evaluation context\n  const safeContext = {\n    trigger: context.trigger,\n    variables: context.variables,\n    nodes: context.nodeOutputs,\n    event: context.trigger.event,\n    // Helper functions\n    $get: (path: string) => resolveValue(context, path),\n    $len: (arr: unknown) => Array.isArray(arr) ? arr.length : 0,\n    $exists: (path: string) => resolveValue(context, path) !== undefined,\n    $empty: (val: unknown) => val === undefined || val === null || val === '' || (Array.isArray(val) && val.length === 0),\n    $now: () => new Date().toISOString(),\n    $lower: (str: unknown) => typeof str === 'string' ? str.toLowerCase() : str,\n    $upper: (str: unknown) => typeof str === 'string' ? str.toUpperCase() : str,\n    $trim: (str: unknown) => typeof str === 'string' ? str.trim() : str,\n    $number: (val: unknown) => Number(val),\n    $string: (val: unknown) => String(val),\n    $json: (val: unknown) => JSON.stringify(val),\n    $parse: (str: unknown) => typeof str === 'string' ? JSON.parse(str) : str,\n  };\n\n  try {\n    // Create function with safe context\n    const fn = new Function(\n      ...Object.keys(safeContext),\n      `\"use strict\"; return (${expression});`\n    );\n\n    return fn(...Object.values(safeContext));\n  } catch (error) {\n    console.error('[WorkflowContext] Expression evaluation error:', error);\n    return undefined;\n  }\n}\n\n// =============================================================================\n// CONDITION EVALUATION\n// =============================================================================\n\n/**\n * Evaluate a workflow condition\n */\nexport function evaluateCondition(\n  condition: WorkflowCondition,\n  context: WorkflowContext\n): boolean {\n  switch (condition.type) {\n    case 'simple':\n      return evaluateSimpleCondition(condition, context);\n\n    case 'expression':\n      return Boolean(evaluateExpression(condition.expression || 'false', context));\n\n    case 'all':\n      return (condition.conditions || []).every((c) => evaluateCondition(c, context));\n\n    case 'any':\n      return (condition.conditions || []).some((c) => evaluateCondition(c, context));\n\n    case 'none':\n      return !(condition.conditions || []).some((c) => evaluateCondition(c, context));\n\n    default:\n      return true;\n  }\n}\n\n/**\n * Evaluate a simple condition\n */\nfunction evaluateSimpleCondition(\n  condition: WorkflowCondition,\n  context: WorkflowContext\n): boolean {\n  const fieldValue = condition.field ? resolveValue(context, condition.field) : undefined;\n  const compareValue = condition.value;\n\n  switch (condition.operator) {\n    case 'eq':\n      return fieldValue === compareValue;\n\n    case 'neq':\n      return fieldValue !== compareValue;\n\n    case 'gt':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue > compareValue;\n\n    case 'gte':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue >= compareValue;\n\n    case 'lt':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue < compareValue;\n\n    case 'lte':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue <= compareValue;\n\n    case 'contains':\n      if (typeof fieldValue === 'string' && typeof compareValue === 'string') {\n        return fieldValue.includes(compareValue);\n      }\n      if (Array.isArray(fieldValue)) {\n        return fieldValue.includes(compareValue);\n      }\n      return false;\n\n    case 'startsWith':\n      return typeof fieldValue === 'string' && typeof compareValue === 'string' && fieldValue.startsWith(compareValue);\n\n    case 'endsWith':\n      return typeof fieldValue === 'string' && typeof compareValue === 'string' && fieldValue.endsWith(compareValue);\n\n    case 'in':\n      return Array.isArray(compareValue) && compareValue.includes(fieldValue);\n\n    case 'notIn':\n      return Array.isArray(compareValue) && !compareValue.includes(fieldValue);\n\n    case 'exists':\n      return compareValue ? fieldValue !== undefined && fieldValue !== null : fieldValue === undefined || fieldValue === null;\n\n    default:\n      return true;\n  }\n}\n\n// =============================================================================\n// CONTEXT MUTATION\n// =============================================================================\n\n/**\n * Update context with node output\n */\nexport function setNodeOutput(\n  context: WorkflowContext,\n  nodeId: string,\n  output: unknown\n): WorkflowContext {\n  return {\n    ...context,\n    nodeOutputs: {\n      ...context.nodeOutputs,\n      [nodeId]: output,\n    },\n    executedNodes: [...context.executedNodes, nodeId],\n    currentNodeId: nodeId,\n  };\n}\n\n/**\n * Set a variable in context\n */\nexport function setVariable(\n  context: WorkflowContext,\n  name: string,\n  value: unknown\n): WorkflowContext {\n  return {\n    ...context,\n    variables: {\n      ...context.variables,\n      [name]: value,\n    },\n  };\n}\n\n/**\n * Add an error to context\n */\nexport function addError(\n  context: WorkflowContext,\n  nodeId: string,\n  error: string\n): WorkflowContext {\n  return {\n    ...context,\n    errors: [\n      ...context.errors,\n      {\n        nodeId,\n        error,\n        timestamp: new Date(),\n      },\n    ],\n  };\n}\n\n// =============================================================================\n// LOOP CONTEXT\n// =============================================================================\n\n/**\n * Create iteration context for loop execution\n */\nexport function createIterationContext(\n  context: WorkflowContext,\n  itemVariable: string,\n  item: unknown,\n  indexVariable: string | undefined,\n  index: number\n): WorkflowContext {\n  const variables = {\n    ...context.variables,\n    [itemVariable]: item,\n  };\n\n  if (indexVariable) {\n    variables[indexVariable] = index;\n  }\n\n  return {\n    ...context,\n    variables,\n  };\n}\n\n// =============================================================================\n// CONTEXT SERIALIZATION\n// =============================================================================\n\n/**\n * Serialize context for storage (e.g., for pause/resume)\n */\nexport function serializeContext(context: WorkflowContext): string {\n  return JSON.stringify({\n    ...context,\n    startedAt: context.startedAt.toISOString(),\n    errors: context.errors.map((e) => ({\n      ...e,\n      timestamp: e.timestamp.toISOString(),\n    })),\n  });\n}\n\n/**\n * Deserialize context from storage\n */\nexport function deserializeContext(serialized: string): WorkflowContext {\n  const parsed = JSON.parse(serialized);\n  return {\n    ...parsed,\n    startedAt: new Date(parsed.startedAt),\n    errors: parsed.errors.map((e: { nodeId: string; error: string; timestamp: string }) => ({\n      ...e,\n      timestamp: new Date(e.timestamp),\n    })),\n  };\n}\n\n// =============================================================================\n// CONTEXT UTILITIES\n// =============================================================================\n\n/**\n * Get a summary of context for logging\n */\nexport function getContextSummary(context: WorkflowContext): Record<string, unknown> {\n  return {\n    executionId: context.executionId,\n    workflowId: context.workflowId,\n    triggerType: context.trigger.type,\n    executedNodes: context.executedNodes.length,\n    variableCount: Object.keys(context.variables).length,\n    errorCount: context.errors.length,\n    hasErrors: context.errors.length > 0,\n  };\n}\n\n/**\n * Clone context for branch execution\n */\nexport function cloneContext(context: WorkflowContext): WorkflowContext {\n  return JSON.parse(JSON.stringify(context));\n}\n","/**\n * Primitive Adapter\n *\n * Bridges the workflow engine with the primitive execution system.\n * Handles primitive loading, validation, and execution logging.\n */\n\nimport { prisma } from '../db';\nimport type { Primitive, PrimitiveExecution } from '@prisma/client';\nimport Ajv from 'ajv';\n\n// =============================================================================\n// PRIMITIVE CACHE\n// =============================================================================\n\nconst primitiveCache = new Map<string, Primitive>();\nconst ajv = new Ajv({ allErrors: true, useDefaults: true });\n\n/**\n * Clear primitive cache (useful for testing)\n */\nexport function clearPrimitiveCache(): void {\n  primitiveCache.clear();\n}\n\n// =============================================================================\n// PRIMITIVE LOADING\n// =============================================================================\n\n/**\n * Get a primitive by ID with caching\n */\nexport async function getPrimitive(primitiveId: string): Promise<Primitive | null> {\n  // Check cache\n  if (primitiveCache.has(primitiveId)) {\n    return primitiveCache.get(primitiveId)!;\n  }\n\n  // Load from database\n  const primitive = await prisma.primitive.findUnique({\n    where: { id: primitiveId },\n  });\n\n  if (primitive) {\n    primitiveCache.set(primitiveId, primitive);\n  }\n\n  return primitive;\n}\n\n/**\n * Get a primitive by name\n */\nexport async function getPrimitiveByName(name: string): Promise<Primitive | null> {\n  // Check cache by name\n  for (const primitive of primitiveCache.values()) {\n    if (primitive.name === name) {\n      return primitive;\n    }\n  }\n\n  // Load from database\n  const primitive = await prisma.primitive.findUnique({\n    where: { name },\n  });\n\n  if (primitive) {\n    primitiveCache.set(primitive.id, primitive);\n  }\n\n  return primitive;\n}\n\n/**\n * Get all primitives for a category\n */\nexport async function getPrimitivesByCategory(category: string): Promise<Primitive[]> {\n  return prisma.primitive.findMany({\n    where: {\n      category,\n      enabled: true,\n    },\n    orderBy: { name: 'asc' },\n  });\n}\n\n/**\n * Get all available primitives\n */\nexport async function getAllPrimitives(): Promise<Primitive[]> {\n  return prisma.primitive.findMany({\n    where: { enabled: true },\n    orderBy: { category: 'asc' },\n  });\n}\n\n// =============================================================================\n// INPUT VALIDATION\n// =============================================================================\n\n/**\n * Validate input against primitive's JSON Schema\n */\nexport function validatePrimitiveInput(\n  primitive: Primitive,\n  input: unknown\n): { valid: boolean; errors?: string[] } {\n  const schema = primitive.inputSchema as Record<string, unknown>;\n\n  if (!schema || Object.keys(schema).length === 0) {\n    return { valid: true };\n  }\n\n  try {\n    const validate = ajv.compile(schema);\n    const valid = validate(input);\n\n    if (!valid && validate.errors) {\n      return {\n        valid: false,\n        errors: validate.errors.map(\n          (e) => `${(e as { instancePath?: string }).instancePath || 'input'} ${e.message}`\n        ),\n      };\n    }\n\n    return { valid: true };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [`Schema validation error: ${error instanceof Error ? error.message : 'Unknown'}`],\n    };\n  }\n}\n\n// =============================================================================\n// PRIMITIVE EXECUTION\n// =============================================================================\n\ninterface ExecutionContext {\n  workflowExecutionId?: string;\n  workflowId?: string;\n  userId?: string;\n  agentId?: string;\n}\n\n/**\n * Execute a primitive by ID\n */\nexport async function executePrimitive(\n  primitiveId: string,\n  input: Record<string, unknown>,\n  context?: ExecutionContext\n): Promise<unknown> {\n  const startedAt = new Date();\n  const startTime = Date.now();\n\n  // Load primitive\n  const primitive = await getPrimitive(primitiveId);\n  if (!primitive) {\n    throw new Error(`Primitive not found: ${primitiveId}`);\n  }\n\n  if (!primitive.enabled) {\n    throw new Error(`Primitive is disabled: ${primitive.name}`);\n  }\n\n  // Validate input\n  const validation = validatePrimitiveInput(primitive, input);\n  if (!validation.valid) {\n    throw new Error(`Invalid input: ${validation.errors?.join(', ')}`);\n  }\n\n  let output: unknown;\n  let success = true;\n  let errorMessage: string | undefined;\n\n  try {\n    // Execute the primitive handler\n    output = await executeHandler(primitive, input);\n  } catch (error) {\n    success = false;\n    errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    throw error;\n  } finally {\n    // Log execution\n    const completedAt = new Date();\n    const executionTime = Date.now() - startTime;\n\n    await logPrimitiveExecution({\n      primitiveId,\n      workflowExecutionId: context?.workflowExecutionId,\n      userId: context?.userId,\n      agentId: context?.agentId,\n      input,\n      output,\n      success,\n      error: errorMessage,\n      startedAt,\n      completedAt,\n      executionTime,\n    });\n  }\n\n  return output;\n}\n\n/**\n * Execute a primitive by name\n */\nexport async function executePrimitiveByName(\n  name: string,\n  input: Record<string, unknown>,\n  context?: ExecutionContext\n): Promise<unknown> {\n  const primitive = await getPrimitiveByName(name);\n  if (!primitive) {\n    throw new Error(`Primitive not found: ${name}`);\n  }\n\n  return executePrimitive(primitive.id, input, context);\n}\n\n// =============================================================================\n// HANDLER EXECUTION\n// =============================================================================\n\n/**\n * Execute the primitive handler code\n */\nasync function executeHandler(\n  primitive: Primitive,\n  input: Record<string, unknown>\n): Promise<unknown> {\n  const handler = primitive.handler;\n\n  // Create a sandboxed execution context\n  const context = createExecutionContext(primitive);\n\n  try {\n    // Wrap handler in async function\n    const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    const fn = new AsyncFunction('input', 'context', handler);\n\n    // Execute with timeout\n    const result = await Promise.race([\n      fn(input, context),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Execution timeout')), primitive.timeout)\n      ),\n    ]);\n\n    return result;\n  } catch (error) {\n    console.error(`[PrimitiveAdapter] Handler error for ${primitive.name}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Create execution context for handler\n */\nfunction createExecutionContext(primitive: Primitive): Record<string, unknown> {\n  return {\n    // Primitive metadata\n    primitiveId: primitive.id,\n    primitiveName: primitive.name,\n    primitiveVersion: primitive.version,\n\n    // Utilities\n    log: (...args: unknown[]) => console.log(`[${primitive.name}]`, ...args),\n    error: (...args: unknown[]) => console.error(`[${primitive.name}]`, ...args),\n\n    // HTTP helpers (if needed by handler)\n    fetch: globalThis.fetch,\n\n    // Environment (filtered for security)\n    env: {\n      NODE_ENV: process.env.NODE_ENV,\n    },\n  };\n}\n\n// =============================================================================\n// EXECUTION LOGGING\n// =============================================================================\n\ninterface LogExecutionParams {\n  primitiveId: string;\n  workflowExecutionId?: string;\n  userId?: string;\n  agentId?: string;\n  input: unknown;\n  output: unknown;\n  success: boolean;\n  error?: string;\n  startedAt: Date;\n  completedAt: Date;\n  executionTime: number;\n}\n\n/**\n * Log primitive execution to database\n */\nasync function logPrimitiveExecution(params: LogExecutionParams): Promise<PrimitiveExecution> {\n  return prisma.primitiveExecution.create({\n    data: {\n      primitiveId: params.primitiveId,\n      workflowExecutionId: params.workflowExecutionId,\n      userId: params.userId,\n      agentId: params.agentId,\n      input: params.input as never,\n      output: params.output as never,\n      success: params.success,\n      error: params.error,\n      startedAt: params.startedAt,\n      completedAt: params.completedAt,\n      executionTime: params.executionTime,\n    },\n  });\n}\n\n/**\n * Get execution history for a primitive\n */\nexport async function getPrimitiveExecutionHistory(\n  primitiveId: string,\n  options?: {\n    limit?: number;\n    success?: boolean;\n    workflowExecutionId?: string;\n  }\n): Promise<PrimitiveExecution[]> {\n  return prisma.primitiveExecution.findMany({\n    where: {\n      primitiveId,\n      ...(options?.success !== undefined && { success: options.success }),\n      ...(options?.workflowExecutionId && {\n        workflowExecutionId: options.workflowExecutionId,\n      }),\n    },\n    orderBy: { startedAt: 'desc' },\n    take: options?.limit || 50,\n  });\n}\n\n// =============================================================================\n// PRIMITIVE UTILITIES\n// =============================================================================\n\n/**\n * Get primitive categories\n */\nexport async function getPrimitiveCategories(): Promise<string[]> {\n  const primitives = await prisma.primitive.findMany({\n    where: { enabled: true },\n    select: { category: true },\n    distinct: ['category'],\n  });\n\n  return primitives\n    .map((p: { category: string | null }) => p.category)\n    .filter((c: string | null): c is string => c !== null)\n    .sort();\n}\n\n/**\n * Check if a primitive exists and is enabled\n */\nexport async function isPrimitiveAvailable(primitiveId: string): Promise<boolean> {\n  const primitive = await getPrimitive(primitiveId);\n  return primitive !== null && primitive.enabled;\n}\n\n/**\n * Get primitive input schema for UI rendering\n */\nexport async function getPrimitiveInputSchema(\n  primitiveId: string\n): Promise<Record<string, unknown> | null> {\n  const primitive = await getPrimitive(primitiveId);\n  if (!primitive) return null;\n\n  return primitive.inputSchema as Record<string, unknown>;\n}\n","/**\n * Workflow Execution Engine\n *\n * Executes workflows by traversing nodes, evaluating conditions,\n * and running primitives/actions.\n */\n\nimport { prisma } from '../db';\nimport type { Workflow, WorkflowExecution } from '@prisma/client';\nimport {\n  createWorkflowContext,\n  setNodeOutput,\n  addError,\n  evaluateCondition,\n  resolveNodeInputs,\n  createIterationContext,\n} from './context';\nimport { executePrimitive } from './primitive-adapter';\nimport type {\n  WorkflowContext,\n  WorkflowExecutionResult,\n  NodeExecutionResult,\n  WorkflowTemplateNode,\n  WorkflowTemplateEdge,\n  WorkflowNodeConfig,\n  WorkflowEvent,\n} from './types';\n\n// =============================================================================\n// WORKFLOW EXECUTION\n// =============================================================================\n\ninterface ExecuteWorkflowOptions {\n  triggeredBy: 'manual' | 'schedule' | 'webhook' | 'event' | 'agent';\n  userId?: string;\n  agentId?: string;\n  eventData?: unknown;\n  variables?: Record<string, unknown>;\n}\n\n/**\n * Execute a workflow by ID\n */\nexport async function executeWorkflow(\n  workflowId: string,\n  options: ExecuteWorkflowOptions\n): Promise<WorkflowExecutionResult> {\n  // Load workflow\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId },\n    include: {\n      workflowNodes: {\n        include: { primitive: true },\n      },\n    },\n  });\n\n  if (!workflow) {\n    throw new Error(`Workflow not found: ${workflowId}`);\n  }\n\n  if (!workflow.enabled) {\n    throw new Error(`Workflow is disabled: ${workflowId}`);\n  }\n\n  return executeWorkflowInstance(workflow, options);\n}\n\n/**\n * Execute a workflow instance\n */\nexport async function executeWorkflowInstance(\n  workflow: Workflow,\n  options: ExecuteWorkflowOptions\n): Promise<WorkflowExecutionResult> {\n  const nodes = workflow.nodes as unknown as WorkflowTemplateNode[];\n  const edges = workflow.edges as unknown as WorkflowTemplateEdge[];\n  const workflowVariables = workflow.variables as Record<string, unknown> | null;\n\n  // Create execution record\n  const execution = await prisma.workflowExecution.create({\n    data: {\n      workflowId: workflow.id,\n      triggeredBy: options.triggeredBy,\n      userId: options.userId,\n      agentId: options.agentId,\n      eventData: options.eventData as never,\n      status: 'RUNNING',\n    },\n  });\n\n  // Create execution context\n  let context = createWorkflowContext(\n    workflow.id,\n    {\n      type: options.triggeredBy,\n      data: options.eventData,\n      event: options.eventData as WorkflowEvent | undefined,\n    },\n    { ...workflowVariables, ...options.variables }\n  );\n\n  // Override executionId to match DB record\n  context = { ...context, executionId: execution.id };\n\n  const nodeResults: NodeExecutionResult[] = [];\n  const startTime = Date.now();\n\n  try {\n    // Find trigger node (starting point)\n    const triggerNode = nodes.find((n) => n.data.nodeType === 'trigger');\n    if (!triggerNode) {\n      throw new Error('No trigger node found in workflow');\n    }\n\n    // Execute from trigger node\n    const result = await executeNode(\n      triggerNode,\n      nodes,\n      edges,\n      context,\n      nodeResults,\n      workflow.id\n    );\n\n    // Update execution record\n    const completedAt = new Date();\n    await prisma.workflowExecution.update({\n      where: { id: execution.id },\n      data: {\n        status: 'COMPLETED',\n        result: result.output as never,\n        completedAt,\n      },\n    });\n\n    // Update workflow lastRunAt\n    await prisma.workflow.update({\n      where: { id: workflow.id },\n      data: { lastRunAt: completedAt },\n    });\n\n    return {\n      executionId: execution.id,\n      workflowId: workflow.id,\n      status: 'COMPLETED',\n      startedAt: execution.startedAt,\n      completedAt,\n      duration: Date.now() - startTime,\n      result: result.output,\n      nodeResults,\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    // Update execution record with error\n    await prisma.workflowExecution.update({\n      where: { id: execution.id },\n      data: {\n        status: 'FAILED',\n        error: errorMessage,\n        completedAt: new Date(),\n      },\n    });\n\n    return {\n      executionId: execution.id,\n      workflowId: workflow.id,\n      status: 'FAILED',\n      startedAt: execution.startedAt,\n      completedAt: new Date(),\n      duration: Date.now() - startTime,\n      error: errorMessage,\n      nodeResults,\n    };\n  }\n}\n\n// =============================================================================\n// NODE EXECUTION\n// =============================================================================\n\n/**\n * Execute a node and its downstream nodes\n */\nasync function executeNode(\n  node: WorkflowTemplateNode,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<{ output: unknown; context: WorkflowContext }> {\n  const nodeStartTime = Date.now();\n  const config = node.data.config as WorkflowNodeConfig | undefined;\n\n  let output: unknown;\n  let updatedContext = context;\n\n  try {\n    // Execute based on node type\n    switch (node.data.nodeType) {\n      case 'trigger':\n        // Trigger nodes just pass through the trigger data\n        output = context.trigger.data;\n        break;\n\n      case 'primitive':\n        output = await executePrimitiveNode(node, config, context, workflowId);\n        break;\n\n      case 'condition':\n        output = await executeConditionNode(node, config, context);\n        break;\n\n      case 'loop':\n        const loopResult = await executeLoopNode(\n          node,\n          config,\n          allNodes,\n          allEdges,\n          context,\n          nodeResults,\n          workflowId\n        );\n        output = loopResult.output;\n        updatedContext = loopResult.context;\n        break;\n\n      case 'delay':\n        output = await executeDelayNode(config);\n        break;\n\n      case 'parallel':\n        output = await executeParallelNode(\n          node,\n          allNodes,\n          allEdges,\n          context,\n          nodeResults,\n          workflowId\n        );\n        break;\n\n      case 'output':\n        // Output nodes collect final results\n        output = resolveNodeInputs(config?.inputMapping, context);\n        break;\n\n      default:\n        output = null;\n    }\n\n    // Update context with node output\n    updatedContext = setNodeOutput(updatedContext, node.id, output);\n\n    // Record success\n    nodeResults.push({\n      nodeId: node.id,\n      success: true,\n      output,\n      duration: Date.now() - nodeStartTime,\n    });\n\n    // Find and execute downstream nodes\n    const outgoingEdges = allEdges.filter((e) => e.source === node.id);\n\n    for (const edge of outgoingEdges) {\n      // Check edge condition if present\n      if (edge.data?.condition) {\n        const conditionMet = evaluateCondition(edge.data.condition, updatedContext);\n        if (!conditionMet) continue;\n      }\n\n      // For condition nodes, check the sourceHandle\n      if (node.data.nodeType === 'condition' && edge.sourceHandle) {\n        const conditionResult = output as boolean;\n        if (edge.sourceHandle === 'true' && !conditionResult) continue;\n        if (edge.sourceHandle === 'false' && conditionResult) continue;\n      }\n\n      const targetNode = allNodes.find((n) => n.id === edge.target);\n      if (targetNode) {\n        const result = await executeNode(\n          targetNode,\n          allNodes,\n          allEdges,\n          updatedContext,\n          nodeResults,\n          workflowId\n        );\n        updatedContext = result.context;\n        // Use last node's output as final output\n        output = result.output;\n      }\n    }\n\n    return { output, context: updatedContext };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    nodeResults.push({\n      nodeId: node.id,\n      success: false,\n      error: errorMessage,\n      duration: Date.now() - nodeStartTime,\n    });\n\n    updatedContext = addError(updatedContext, node.id, errorMessage);\n    throw error;\n  }\n}\n\n// =============================================================================\n// NODE TYPE HANDLERS\n// =============================================================================\n\n/**\n * Execute a primitive node\n */\nasync function executePrimitiveNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  context: WorkflowContext,\n  workflowId: string\n): Promise<unknown> {\n  const primitiveId = node.data.primitiveId;\n  if (!primitiveId) {\n    throw new Error(`Primitive node ${node.id} has no primitive assigned`);\n  }\n\n  // Resolve inputs from context\n  const inputs = resolveNodeInputs(config?.inputMapping, context);\n\n  // Merge with static config\n  const finalInputs = {\n    ...config?.primitiveConfig,\n    ...inputs,\n  };\n\n  // Execute primitive\n  return executePrimitive(primitiveId, finalInputs, {\n    workflowExecutionId: context.executionId,\n    workflowId,\n  });\n}\n\n/**\n * Execute a condition node\n */\nasync function executeConditionNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  context: WorkflowContext\n): Promise<boolean> {\n  if (!config?.condition) {\n    return true;\n  }\n\n  return evaluateCondition(config.condition, context);\n}\n\n/**\n * Execute a loop node\n */\nasync function executeLoopNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<{ output: unknown[]; context: WorkflowContext }> {\n  if (!config?.loop) {\n    return { output: [], context };\n  }\n\n  const { collection, itemVariable, indexVariable } = config.loop;\n\n  // Get collection from context\n  const items = context.variables[collection] as unknown[];\n  if (!Array.isArray(items)) {\n    throw new Error(`Loop collection \"${collection}\" is not an array`);\n  }\n\n  // Find loop body nodes (nodes connected from this loop node)\n  const loopBodyEdges = allEdges.filter(\n    (e) => e.source === node.id && e.sourceHandle === 'body'\n  );\n\n  const results: unknown[] = [];\n  let currentContext = context;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n\n    // Create iteration context\n    const iterContext = createIterationContext(\n      currentContext,\n      itemVariable,\n      item,\n      indexVariable,\n      i\n    );\n\n    // Execute loop body\n    for (const edge of loopBodyEdges) {\n      const bodyNode = allNodes.find((n) => n.id === edge.target);\n      if (bodyNode) {\n        const result = await executeNode(\n          bodyNode,\n          allNodes,\n          allEdges,\n          iterContext,\n          nodeResults,\n          workflowId\n        );\n        results.push(result.output);\n        // Carry forward context changes (except iteration variables)\n        currentContext = {\n          ...result.context,\n          variables: {\n            ...result.context.variables,\n            [itemVariable]: undefined,\n            ...(indexVariable ? { [indexVariable]: undefined } : {}),\n          },\n        };\n      }\n    }\n  }\n\n  return { output: results, context: currentContext };\n}\n\n/**\n * Execute a delay node\n */\nasync function executeDelayNode(\n  config: WorkflowNodeConfig | undefined\n): Promise<{ delayed: boolean; duration: number }> {\n  if (!config?.delay) {\n    return { delayed: false, duration: 0 };\n  }\n\n  const { duration, unit } = config.delay;\n  let ms = duration;\n\n  switch (unit) {\n    case 'minutes':\n      ms = duration * 60 * 1000;\n      break;\n    case 'hours':\n      ms = duration * 60 * 60 * 1000;\n      break;\n    case 'days':\n      ms = duration * 24 * 60 * 60 * 1000;\n      break;\n    default:\n      ms = duration * 1000;\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, ms));\n\n  return { delayed: true, duration: ms };\n}\n\n/**\n * Execute a parallel node (fan-out)\n */\nasync function executeParallelNode(\n  node: WorkflowTemplateNode,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<unknown[]> {\n  // Find all outgoing edges from parallel node\n  const outgoingEdges = allEdges.filter((e) => e.source === node.id);\n\n  // Execute all branches in parallel\n  const promises = outgoingEdges.map(async (edge) => {\n    const targetNode = allNodes.find((n) => n.id === edge.target);\n    if (!targetNode) return null;\n\n    const result = await executeNode(\n      targetNode,\n      allNodes,\n      allEdges,\n      context,\n      nodeResults,\n      workflowId\n    );\n    return result.output;\n  });\n\n  const results = await Promise.all(promises);\n  return results.filter((r) => r !== null);\n}\n\n// =============================================================================\n// WORKFLOW MANAGEMENT\n// =============================================================================\n\n/**\n * Cancel a running workflow execution\n */\nexport async function cancelWorkflowExecution(executionId: string): Promise<void> {\n  await prisma.workflowExecution.update({\n    where: { id: executionId },\n    data: {\n      status: 'CANCELLED',\n      completedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get workflow execution status\n */\nexport async function getWorkflowExecutionStatus(\n  executionId: string\n): Promise<WorkflowExecution | null> {\n  return prisma.workflowExecution.findUnique({\n    where: { id: executionId },\n  });\n}\n\n/**\n * Get recent workflow executions\n */\nexport async function getWorkflowExecutions(\n  workflowId: string,\n  options?: {\n    limit?: number;\n    status?: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';\n  }\n): Promise<WorkflowExecution[]> {\n  return prisma.workflowExecution.findMany({\n    where: {\n      workflowId,\n      ...(options?.status && { status: options.status }),\n    },\n    orderBy: { startedAt: 'desc' },\n    take: options?.limit || 50,\n  });\n}\n\n// =============================================================================\n// WORKFLOW TRIGGER HELPERS\n// =============================================================================\n\n/**\n * Trigger a workflow manually\n */\nexport async function triggerWorkflowManually(\n  workflowId: string,\n  data?: unknown,\n  userId?: string\n): Promise<WorkflowExecutionResult> {\n  return executeWorkflow(workflowId, {\n    triggeredBy: 'manual',\n    userId,\n    eventData: data,\n  });\n}\n\n/**\n * Trigger a workflow via webhook\n */\nexport async function triggerWorkflowByWebhook(\n  workflowSlug: string,\n  payload: unknown\n): Promise<WorkflowExecutionResult> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { slug: workflowSlug },\n  });\n\n  if (!workflow) {\n    throw new Error(`Workflow not found: ${workflowSlug}`);\n  }\n\n  if (workflow.triggerType !== 'WEBHOOK') {\n    throw new Error(`Workflow ${workflowSlug} is not configured for webhook triggers`);\n  }\n\n  return executeWorkflow(workflow.id, {\n    triggeredBy: 'webhook',\n    eventData: payload,\n  });\n}\n\n/**\n * Find workflows that should run on schedule\n */\nexport async function getScheduledWorkflows(): Promise<Workflow[]> {\n  return prisma.workflow.findMany({\n    where: {\n      enabled: true,\n      triggerType: 'SCHEDULE',\n    },\n  });\n}\n\n/**\n * Check if a workflow should run based on cron schedule\n */\nexport function shouldRunScheduledWorkflow(\n  workflow: Workflow,\n  now: Date = new Date()\n): boolean {\n  const config = workflow.triggerConfig as { cron?: string } | null;\n  if (!config?.cron) return false;\n\n  // Parse cron expression (simplified - for production use a library like cron-parser)\n  // Format: minute hour dayOfMonth month dayOfWeek\n  const [minute, hour, dayOfMonth, month, dayOfWeek] = config.cron.split(' ');\n\n  const matches = (pattern: string, value: number): boolean => {\n    if (pattern === '*') return true;\n    if (pattern.includes(',')) {\n      return pattern.split(',').some((p) => matches(p, value));\n    }\n    if (pattern.includes('-')) {\n      const [start, end] = pattern.split('-').map(Number);\n      return value >= start && value <= end;\n    }\n    if (pattern.includes('/')) {\n      const [, step] = pattern.split('/').map(Number);\n      return value % step === 0;\n    }\n    return parseInt(pattern, 10) === value;\n  };\n\n  return (\n    matches(minute, now.getMinutes()) &&\n    matches(hour, now.getHours()) &&\n    matches(dayOfMonth, now.getDate()) &&\n    matches(month, now.getMonth() + 1) &&\n    matches(dayOfWeek, now.getDay())\n  );\n}\n"],"mappings":"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","names":["primitive"]}