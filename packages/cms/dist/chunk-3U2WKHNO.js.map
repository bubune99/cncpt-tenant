{"version":3,"sources":["/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-3U2WKHNO.js","../src/lib/analytics/types.ts","../src/lib/analytics/index.ts","../src/lib/blog/index.ts","../src/lib/cart/index.ts","../src/lib/discounts/validator.ts","../src/lib/discounts/calculator.ts","../src/lib/discounts/stripe-sync.ts","../src/lib/stripe/index.ts","../src/lib/stripe/types.ts","../src/lib/forms/types.ts","../src/lib/forms/index.ts","../src/lib/inventory/index.ts","../src/lib/media/index.ts","../src/lib/email/templates/base.ts","../src/lib/email/templates/renderer.ts","../src/lib/email/templates/order-confirmation.ts","../src/lib/email/templates/shipping-notification.ts","../src/lib/email/templates/delivery-confirmation.ts","../src/lib/email/templates/refund-notification.ts","../src/lib/email/templates/render.ts","../src/lib/notifications/index.ts","../src/lib/permissions/constants.ts","../src/lib/permissions/index.ts","../src/lib/order-workflows/types.ts","../src/lib/order-workflows/index.ts","../src/lib/plugins/types.ts","../src/lib/plugins/sandbox.ts","../src/lib/plugins/registry.ts","../src/lib/plugins/executor.ts","../src/lib/plugins/primitives/ai.ts","../src/lib/plugins/primitives/analytics.ts","../src/lib/plugins/primitives/blog.ts","../src/lib/plugins/primitives/cart.ts","../src/lib/plugins/primitives/customer.ts","../src/lib/plugins/primitives/discount.ts","../src/lib/plugins/primitives/email.ts","../src/lib/plugins/primitives/giftcard.ts","../src/lib/plugins/primitives/media.ts","../src/lib/plugins/primitives/notification.ts","../src/lib/plugins/primitives/order.ts","../src/lib/plugins/primitives/payment.ts","../src/lib/plugins/primitives/product.ts","../src/lib/plugins/primitives/review.ts","../src/lib/plugins/primitives/shipping.ts","../src/lib/plugins/primitives/wishlist.ts","../src/lib/plugins/primitives/index.ts","../src/lib/plugins/built-in.ts","../src/lib/reviews/index.ts","../src/lib/seo/types.ts","../src/lib/seo/index.ts","../src/lib/site-settings/index.ts","../src/lib/workflows/event-bus.ts","../src/lib/workflows/react-flow.ts","../src/lib/workflows/actions/index.ts","../src/lib/workflows/templates/index.ts","../src/lib/workflows/toggle.ts","../src/lib/shippo/index.ts","../src/lib/shippo/types.ts","../src/lib/dashboard/types.ts","../src/lib/dashboard/index.ts","../src/lib/routes/index.ts"],"names":["cart","SETTINGS_CACHE_TTL","settingsCache","stripeClient","_a","_c","_b"],"mappings":"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A;AACpB,EAAA;AAEQ,EAAA;AACX;AAK2C;AACN,EAAA;AACxB,IAAA;AACD,MAAA;AACI,QAAA;AACF,UAAA;AACG,UAAA;AACD,UAAA;AACE,UAAA;AACV,QAAA;AACF,MAAA;AACF,IAAA;AACuB,IAAA;AACxB,EAAA;AACH;A7D25oBqD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-3U2WKHNO.js","sourcesContent":[null,"/**\n * Analytics Types and Configurations\n */\n\n// Analytics provider types\nexport type AnalyticsProvider = 'google' | 'matomo' | 'plausible' | 'umami' | 'custom'\n\n// Analytics settings stored in database\nexport interface AnalyticsSettings {\n  enabled: boolean\n\n  // Google Analytics\n  googleEnabled: boolean\n  googleMeasurementId?: string // G-XXXXXXXXXX\n  googleDebugMode: boolean\n\n  // Matomo\n  matomoEnabled: boolean\n  matomoUrl?: string\n  matomoSiteId?: string\n\n  // Plausible (optional)\n  plausibleEnabled: boolean\n  plausibleDomain?: string\n\n  // Privacy settings\n  respectDoNotTrack: boolean\n  anonymizeIp: boolean\n  cookieConsent: boolean\n}\n\n// Default analytics settings\nexport const DEFAULT_ANALYTICS_SETTINGS: AnalyticsSettings = {\n  enabled: false,\n  googleEnabled: false,\n  googleDebugMode: false,\n  matomoEnabled: false,\n  plausibleEnabled: false,\n  respectDoNotTrack: true,\n  anonymizeIp: true,\n  cookieConsent: true,\n}\n\n// Standard event names\nexport type StandardEventName =\n  | 'page_view'\n  | 'purchase'\n  | 'add_to_cart'\n  | 'remove_from_cart'\n  | 'begin_checkout'\n  | 'view_item'\n  | 'view_item_list'\n  | 'search'\n  | 'sign_up'\n  | 'login'\n  | 'share'\n  | 'generate_lead'\n  | 'add_payment_info'\n  | 'add_shipping_info'\n  | 'select_item'\n  | 'select_promotion'\n  | 'view_promotion'\n  | 'refund'\n\n// Custom event\nexport interface AnalyticsEvent {\n  name: string\n  params?: Record<string, string | number | boolean | undefined>\n}\n\n// E-commerce item\nexport interface EcommerceItem {\n  item_id: string\n  item_name: string\n  item_brand?: string\n  item_category?: string\n  item_variant?: string\n  price?: number\n  quantity?: number\n  currency?: string\n}\n\n// Purchase event data\nexport interface PurchaseEventData {\n  transaction_id: string\n  value: number\n  currency: string\n  tax?: number\n  shipping?: number\n  coupon?: string\n  items: EcommerceItem[]\n}\n\n// Page view data\nexport interface PageViewData {\n  page_title?: string\n  page_location?: string\n  page_path?: string\n}\n\n// User properties\nexport interface UserProperties {\n  user_id?: string\n  user_type?: string\n  [key: string]: string | number | boolean | undefined\n}\n\n// Consent categories\nexport interface ConsentSettings {\n  analytics_storage: 'granted' | 'denied'\n  ad_storage: 'granted' | 'denied'\n  ad_user_data: 'granted' | 'denied'\n  ad_personalization: 'granted' | 'denied'\n  functionality_storage: 'granted' | 'denied'\n  personalization_storage: 'granted' | 'denied'\n  security_storage: 'granted' // Always granted\n}\n\n// Default consent (privacy-first)\nexport const DEFAULT_CONSENT: ConsentSettings = {\n  analytics_storage: 'denied',\n  ad_storage: 'denied',\n  ad_user_data: 'denied',\n  ad_personalization: 'denied',\n  functionality_storage: 'granted',\n  personalization_storage: 'denied',\n  security_storage: 'granted',\n}\n","/**\n * Analytics Library\n *\n * Provides unified analytics tracking for Google Analytics 4 and Matomo\n */\n\nimport { prisma } from '../db'\nimport type {\n  AnalyticsSettings,\n  AnalyticsEvent,\n  PurchaseEventData,\n  PageViewData,\n  UserProperties,\n  ConsentSettings,\n} from './types'\nimport { DEFAULT_ANALYTICS_SETTINGS } from './types'\n\n// Cache for analytics settings\nlet settingsCache: AnalyticsSettings | null = null\nlet settingsCacheTime = 0\nconst SETTINGS_CACHE_TTL = 60 * 1000 // 1 minute\n\n/**\n * Get analytics settings from database\n */\nexport async function getAnalyticsSettings(): Promise<AnalyticsSettings> {\n  const now = Date.now()\n  if (settingsCache && now - settingsCacheTime < SETTINGS_CACHE_TTL) {\n    return settingsCache\n  }\n\n  const records = await prisma.setting.findMany({\n    where: { key: { startsWith: 'analytics.' } },\n  })\n\n  const settings: AnalyticsSettings = { ...DEFAULT_ANALYTICS_SETTINGS }\n\n  for (const record of records) {\n    const key = record.key.replace('analytics.', '')\n    switch (key) {\n      case 'enabled':\n        settings.enabled = record.value === 'true'\n        break\n      case 'googleEnabled':\n        settings.googleEnabled = record.value === 'true'\n        break\n      case 'googleMeasurementId':\n        settings.googleMeasurementId = record.value\n        break\n      case 'googleDebugMode':\n        settings.googleDebugMode = record.value === 'true'\n        break\n      case 'matomoEnabled':\n        settings.matomoEnabled = record.value === 'true'\n        break\n      case 'matomoUrl':\n        settings.matomoUrl = record.value\n        break\n      case 'matomoSiteId':\n        settings.matomoSiteId = record.value\n        break\n      case 'plausibleEnabled':\n        settings.plausibleEnabled = record.value === 'true'\n        break\n      case 'plausibleDomain':\n        settings.plausibleDomain = record.value\n        break\n      case 'respectDoNotTrack':\n        settings.respectDoNotTrack = record.value === 'true'\n        break\n      case 'anonymizeIp':\n        settings.anonymizeIp = record.value === 'true'\n        break\n      case 'cookieConsent':\n        settings.cookieConsent = record.value === 'true'\n        break\n    }\n  }\n\n  // Fallback to environment variables\n  if (!settings.googleMeasurementId) {\n    settings.googleMeasurementId = process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID\n  }\n  if (!settings.matomoUrl) {\n    settings.matomoUrl = process.env.NEXT_PUBLIC_MATOMO_URL\n  }\n  if (!settings.matomoSiteId) {\n    settings.matomoSiteId = process.env.NEXT_PUBLIC_MATOMO_SITE_ID\n  }\n\n  settingsCache = settings\n  settingsCacheTime = now\n\n  return settings\n}\n\n/**\n * Clear analytics settings cache\n */\nexport function clearAnalyticsSettingsCache(): void {\n  settingsCache = null\n  settingsCacheTime = 0\n}\n\n/**\n * Track an event server-side (stores in database)\n */\nexport async function trackServerEvent(\n  eventName: string,\n  eventData?: Record<string, any>,\n  context?: {\n    sessionId?: string\n    userId?: string\n    pageUrl?: string\n    pageTitle?: string\n    referrer?: string\n    userAgent?: string\n    ipAddress?: string\n  }\n): Promise<void> {\n  try {\n    await prisma.analyticsEvent.create({\n      data: {\n        eventName,\n        eventData: eventData || undefined,\n        sessionId: context?.sessionId,\n        userId: context?.userId,\n        pageUrl: context?.pageUrl,\n        pageTitle: context?.pageTitle,\n        referrer: context?.referrer,\n        userAgent: context?.userAgent,\n        ipAddress: context?.ipAddress,\n      },\n    })\n  } catch (error) {\n    console.error('Failed to track server event:', error)\n  }\n}\n\n/**\n * Track a purchase event\n */\nexport async function trackPurchase(\n  data: PurchaseEventData,\n  context?: {\n    sessionId?: string\n    userId?: string\n  }\n): Promise<void> {\n  await trackServerEvent('purchase', data, context)\n}\n\n/**\n * Get analytics data for dashboard\n */\nexport async function getAnalyticsSummary(\n  startDate: Date,\n  endDate: Date\n): Promise<{\n  pageViews: number\n  uniqueVisitors: number\n  purchases: number\n  revenue: number\n  topPages: Array<{ url: string; views: number }>\n  topReferrers: Array<{ referrer: string; count: number }>\n  eventBreakdown: Array<{ event: string; count: number }>\n}> {\n  // Page views\n  const pageViews = await prisma.analyticsEvent.count({\n    where: {\n      eventName: 'page_view',\n      createdAt: { gte: startDate, lte: endDate },\n    },\n  })\n\n  // Unique visitors (by sessionId)\n  const uniqueVisitors = await prisma.analyticsEvent.groupBy({\n    by: ['sessionId'],\n    where: {\n      sessionId: { not: null },\n      createdAt: { gte: startDate, lte: endDate },\n    },\n  })\n\n  // Purchases and revenue\n  const purchases = await prisma.analyticsEvent.findMany({\n    where: {\n      eventName: 'purchase',\n      createdAt: { gte: startDate, lte: endDate },\n    },\n    select: { eventData: true },\n  })\n\n  const revenue = purchases.reduce((sum: number, p: (typeof purchases)[number]) => {\n    const data = p.eventData as Record<string, unknown> | null\n    const value = typeof data?.value === 'number' ? data.value : 0\n    return sum + value\n  }, 0)\n\n  // Top pages\n  const topPagesRaw = await prisma.analyticsEvent.groupBy({\n    by: ['pageUrl'],\n    where: {\n      eventName: 'page_view',\n      pageUrl: { not: null },\n      createdAt: { gte: startDate, lte: endDate },\n    },\n    _count: { pageUrl: true },\n    orderBy: { _count: { pageUrl: 'desc' } },\n    take: 10,\n  })\n\n  const topPages = topPagesRaw.map((p: (typeof topPagesRaw)[number]) => ({\n    url: p.pageUrl!,\n    views: p._count.pageUrl,\n  }))\n\n  // Top referrers\n  const topReferrersRaw = await prisma.analyticsEvent.groupBy({\n    by: ['referrer'],\n    where: {\n      referrer: { not: null },\n      createdAt: { gte: startDate, lte: endDate },\n    },\n    _count: { referrer: true },\n    orderBy: { _count: { referrer: 'desc' } },\n    take: 10,\n  })\n\n  const topReferrers = topReferrersRaw.map((r: (typeof topReferrersRaw)[number]) => ({\n    referrer: r.referrer!,\n    count: r._count.referrer,\n  }))\n\n  // Event breakdown\n  const eventBreakdownRaw = await prisma.analyticsEvent.groupBy({\n    by: ['eventName'],\n    where: {\n      createdAt: { gte: startDate, lte: endDate },\n    },\n    _count: { eventName: true },\n    orderBy: { _count: { eventName: 'desc' } },\n    take: 20,\n  })\n\n  const eventBreakdown = eventBreakdownRaw.map((e: (typeof eventBreakdownRaw)[number]) => ({\n    event: e.eventName,\n    count: e._count.eventName,\n  }))\n\n  return {\n    pageViews,\n    uniqueVisitors: uniqueVisitors.length,\n    purchases: purchases.length,\n    revenue,\n    topPages,\n    topReferrers,\n    eventBreakdown,\n  }\n}\n\n/**\n * Generate Google Analytics gtag script\n */\nexport function generateGtagScript(measurementId: string, debugMode = false): string {\n  return `\n    window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments);}\n    gtag('js', new Date());\n    gtag('config', '${measurementId}'${debugMode ? \", { 'debug_mode': true }\" : ''});\n  `\n}\n\n/**\n * Generate Matomo tracking script\n */\nexport function generateMatomoScript(matomoUrl: string, siteId: string): string {\n  const url = matomoUrl.endsWith('/') ? matomoUrl : `${matomoUrl}/`\n\n  return `\n    var _paq = window._paq = window._paq || [];\n    _paq.push(['trackPageView']);\n    _paq.push(['enableLinkTracking']);\n    (function() {\n      var u=\"${url}\";\n      _paq.push(['setTrackerUrl', u+'matomo.php']);\n      _paq.push(['setSiteId', '${siteId}']);\n      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];\n      g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);\n    })();\n  `\n}\n\nexport * from './types'\n","/**\n * Blog Library\n *\n * Core functions for blog post, category, and tag management\n */\n\nimport { prisma } from '../db'\nimport type { Prisma, PostVisibility } from '@prisma/client'\n\n// ============ SLUG UTILITIES ============\n\nfunction generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/(^-|-$)+/g, '')\n}\n\nasync function ensureUniqueSlug(\n  slug: string,\n  type: 'post' | 'category' | 'tag',\n  excludeId?: string\n): Promise<string> {\n  let uniqueSlug = slug\n  let counter = 1\n\n  while (true) {\n    const existing = await (type === 'post'\n      ? prisma.blogPost.findUnique({ where: { slug: uniqueSlug } })\n      : type === 'category'\n      ? prisma.blogCategory.findUnique({ where: { slug: uniqueSlug } })\n      : prisma.blogTag.findUnique({ where: { slug: uniqueSlug } }))\n\n    if (!existing || existing.id === excludeId) {\n      return uniqueSlug\n    }\n\n    uniqueSlug = `${slug}-${counter}`\n    counter++\n  }\n}\n\n// ============ BLOG POSTS ============\n\nexport interface CreatePostInput {\n  title: string\n  slug?: string\n  excerpt?: string\n  content?: object\n  contentHtml?: string\n  authorId?: string\n  featuredImageId?: string\n  status?: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED' | 'SCHEDULED'\n  visibility?: 'PUBLIC' | 'PRIVATE' | 'PASSWORD_PROTECTED' | 'MEMBERS_ONLY'\n  metaTitle?: string\n  metaDescription?: string\n  canonicalUrl?: string\n  noIndex?: boolean\n  ogTitle?: string\n  ogDescription?: string\n  ogImageId?: string\n  publishedAt?: Date\n  scheduledAt?: Date\n  allowComments?: boolean\n  featured?: boolean\n  pinned?: boolean\n  categoryIds?: string[]\n  tagIds?: string[]\n}\n\nexport interface UpdatePostInput extends Partial<CreatePostInput> {}\n\nexport interface ListPostsOptions {\n  status?: string\n  visibility?: string\n  authorId?: string\n  categoryId?: string\n  tagId?: string\n  featured?: boolean\n  search?: string\n  limit?: number\n  offset?: number\n  orderBy?: 'createdAt' | 'publishedAt' | 'title' | 'viewCount'\n  orderDir?: 'asc' | 'desc'\n}\n\nexport async function createPost(input: CreatePostInput) {\n  const slug = input.slug || generateSlug(input.title)\n  const uniqueSlug = await ensureUniqueSlug(slug, 'post')\n\n  // Calculate word count from HTML content\n  const wordCount = input.contentHtml\n    ? input.contentHtml.replace(/<[^>]*>/g, '').split(/\\s+/).filter(Boolean).length\n    : 0\n\n  // Estimate reading time (200 words per minute)\n  const readingTime = Math.ceil(wordCount / 200)\n\n  const post = await prisma.blogPost.create({\n    data: {\n      title: input.title,\n      slug: uniqueSlug,\n      excerpt: input.excerpt,\n      content: input.content as Prisma.InputJsonValue,\n      contentHtml: input.contentHtml,\n      authorId: input.authorId,\n      featuredImageId: input.featuredImageId,\n      status: input.status ?? 'DRAFT',\n      visibility: (input.visibility ?? 'PUBLIC') as PostVisibility,\n      metaTitle: input.metaTitle,\n      metaDescription: input.metaDescription,\n      canonicalUrl: input.canonicalUrl,\n      noIndex: input.noIndex ?? false,\n      ogTitle: input.ogTitle,\n      ogDescription: input.ogDescription,\n      ogImageId: input.ogImageId,\n      publishedAt: input.status === 'PUBLISHED' ? input.publishedAt ?? new Date() : input.publishedAt,\n      scheduledAt: input.scheduledAt,\n      wordCount,\n      readingTime,\n      allowComments: input.allowComments ?? true,\n      featured: input.featured ?? false,\n      pinned: input.pinned ?? false,\n      categories: input.categoryIds?.length\n        ? {\n            create: input.categoryIds.map((categoryId) => ({\n              category: { connect: { id: categoryId } },\n            })),\n          }\n        : undefined,\n      tags: input.tagIds?.length\n        ? {\n            create: input.tagIds.map((tagId) => ({\n              tag: { connect: { id: tagId } },\n            })),\n          }\n        : undefined,\n    },\n    include: {\n      author: {\n        select: { id: true, name: true, email: true },\n      },\n      featuredImage: true,\n      categories: {\n        include: { category: true },\n      },\n      tags: {\n        include: { tag: true },\n      },\n    },\n  })\n\n  return post\n}\n\nexport async function getPost(id: string) {\n  return prisma.blogPost.findUnique({\n    where: { id },\n    include: {\n      author: {\n        select: { id: true, name: true, email: true },\n      },\n      featuredImage: true,\n      ogImage: true,\n      categories: {\n        include: { category: true },\n      },\n      tags: {\n        include: { tag: true },\n      },\n      _count: {\n        select: { comments: true },\n      },\n    },\n  })\n}\n\nexport async function getPostBySlug(slug: string) {\n  return prisma.blogPost.findUnique({\n    where: { slug },\n    include: {\n      author: {\n        select: { id: true, name: true, email: true },\n      },\n      featuredImage: true,\n      ogImage: true,\n      categories: {\n        include: { category: true },\n      },\n      tags: {\n        include: { tag: true },\n      },\n      _count: {\n        select: { comments: true },\n      },\n    },\n  })\n}\n\nexport async function listPosts(options: ListPostsOptions = {}) {\n  const {\n    status,\n    visibility,\n    authorId,\n    categoryId,\n    tagId,\n    featured,\n    search,\n    limit = 20,\n    offset = 0,\n    orderBy = 'createdAt',\n    orderDir = 'desc',\n  } = options\n\n  const where: Prisma.BlogPostWhereInput = {}\n\n  if (status) {\n    where.status = status as any\n  }\n  if (visibility) {\n    where.visibility = visibility as any\n  }\n  if (authorId) {\n    where.authorId = authorId\n  }\n  if (featured !== undefined) {\n    where.featured = featured\n  }\n  if (categoryId) {\n    where.categories = {\n      some: { categoryId },\n    }\n  }\n  if (tagId) {\n    where.tags = {\n      some: { tagId },\n    }\n  }\n  if (search) {\n    where.OR = [\n      { title: { contains: search, mode: 'insensitive' } },\n      { excerpt: { contains: search, mode: 'insensitive' } },\n    ]\n  }\n\n  const [posts, total] = await Promise.all([\n    prisma.blogPost.findMany({\n      where,\n      take: limit,\n      skip: offset,\n      orderBy: { [orderBy]: orderDir },\n      include: {\n        author: {\n          select: { id: true, name: true, email: true },\n        },\n        featuredImage: {\n          select: { id: true, url: true, alt: true },\n        },\n        categories: {\n          include: {\n            category: {\n              select: { id: true, name: true, slug: true },\n            },\n          },\n        },\n        tags: {\n          include: {\n            tag: {\n              select: { id: true, name: true, slug: true },\n            },\n          },\n        },\n      },\n    }),\n    prisma.blogPost.count({ where }),\n  ])\n\n  return { posts, total, limit, offset }\n}\n\nexport async function updatePost(id: string, input: UpdatePostInput) {\n  // Get existing post\n  const existing = await prisma.blogPost.findUnique({\n    where: { id },\n    include: {\n      categories: true,\n      tags: true,\n    },\n  })\n\n  if (!existing) {\n    throw new Error('Post not found')\n  }\n\n  // Handle slug update\n  let slug = existing.slug\n  if (input.slug && input.slug !== existing.slug) {\n    slug = await ensureUniqueSlug(input.slug, 'post', id)\n  }\n\n  // Calculate word count if content changed\n  let wordCount = existing.wordCount\n  let readingTime = existing.readingTime\n  if (input.contentHtml !== undefined) {\n    wordCount = input.contentHtml\n      ? input.contentHtml.replace(/<[^>]*>/g, '').split(/\\s+/).filter(Boolean).length\n      : 0\n    readingTime = Math.ceil(wordCount / 200)\n  }\n\n  // Handle category updates\n  if (input.categoryIds !== undefined) {\n    // Delete existing categories\n    await prisma.blogPostCategory.deleteMany({\n      where: { postId: id },\n    })\n  }\n\n  // Handle tag updates\n  if (input.tagIds !== undefined) {\n    // Delete existing tags\n    await prisma.blogPostTag.deleteMany({\n      where: { postId: id },\n    })\n  }\n\n  const post = await prisma.blogPost.update({\n    where: { id },\n    data: {\n      title: input.title,\n      slug,\n      excerpt: input.excerpt,\n      content: input.content as Prisma.InputJsonValue,\n      contentHtml: input.contentHtml,\n      authorId: input.authorId,\n      featuredImageId: input.featuredImageId,\n      status: input.status,\n      visibility: input.visibility as PostVisibility | undefined,\n      metaTitle: input.metaTitle,\n      metaDescription: input.metaDescription,\n      canonicalUrl: input.canonicalUrl,\n      noIndex: input.noIndex,\n      ogTitle: input.ogTitle,\n      ogDescription: input.ogDescription,\n      ogImageId: input.ogImageId,\n      publishedAt:\n        input.status === 'PUBLISHED' && !existing.publishedAt\n          ? new Date()\n          : input.publishedAt,\n      scheduledAt: input.scheduledAt,\n      wordCount,\n      readingTime,\n      allowComments: input.allowComments,\n      featured: input.featured,\n      pinned: input.pinned,\n      categories: input.categoryIds?.length\n        ? {\n            create: input.categoryIds.map((categoryId) => ({\n              category: { connect: { id: categoryId } },\n            })),\n          }\n        : undefined,\n      tags: input.tagIds?.length\n        ? {\n            create: input.tagIds.map((tagId) => ({\n              tag: { connect: { id: tagId } },\n            })),\n          }\n        : undefined,\n    },\n    include: {\n      author: {\n        select: { id: true, name: true, email: true },\n      },\n      featuredImage: true,\n      categories: {\n        include: { category: true },\n      },\n      tags: {\n        include: { tag: true },\n      },\n    },\n  })\n\n  return post\n}\n\nexport async function deletePost(id: string) {\n  // Delete related records first\n  await prisma.blogPostCategory.deleteMany({ where: { postId: id } })\n  await prisma.blogPostTag.deleteMany({ where: { postId: id } })\n  await prisma.blogComment.deleteMany({ where: { postId: id } })\n\n  return prisma.blogPost.delete({ where: { id } })\n}\n\nexport async function incrementPostViews(id: string) {\n  return prisma.blogPost.update({\n    where: { id },\n    data: { viewCount: { increment: 1 } },\n  })\n}\n\n// ============ BLOG CATEGORIES ============\n\nexport interface CreateCategoryInput {\n  name: string\n  slug?: string\n  description?: string\n  parentId?: string\n  imageId?: string\n  metaTitle?: string\n  metaDescription?: string\n}\n\nexport interface UpdateCategoryInput extends Partial<CreateCategoryInput> {}\n\nexport async function createCategory(input: CreateCategoryInput) {\n  const slug = input.slug || generateSlug(input.name)\n  const uniqueSlug = await ensureUniqueSlug(slug, 'category')\n\n  return prisma.blogCategory.create({\n    data: {\n      name: input.name,\n      slug: uniqueSlug,\n      description: input.description,\n      parentId: input.parentId,\n      imageId: input.imageId,\n      metaTitle: input.metaTitle,\n      metaDescription: input.metaDescription,\n    },\n    include: {\n      parent: true,\n      children: true,\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function getCategory(id: string) {\n  return prisma.blogCategory.findUnique({\n    where: { id },\n    include: {\n      parent: true,\n      children: true,\n      image: true,\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function getCategoryBySlug(slug: string) {\n  return prisma.blogCategory.findUnique({\n    where: { slug },\n    include: {\n      parent: true,\n      children: true,\n      image: true,\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function listCategories(options: {\n  parentId?: string | null\n  search?: string\n  limit?: number\n  offset?: number\n} = {}) {\n  const { parentId, search, limit = 100, offset = 0 } = options\n\n  const where: Prisma.BlogCategoryWhereInput = {}\n\n  if (parentId !== undefined) {\n    where.parentId = parentId\n  }\n  if (search) {\n    where.name = { contains: search, mode: 'insensitive' }\n  }\n\n  const [categories, total] = await Promise.all([\n    prisma.blogCategory.findMany({\n      where,\n      take: limit,\n      skip: offset,\n      orderBy: { name: 'asc' },\n      include: {\n        parent: {\n          select: { id: true, name: true, slug: true },\n        },\n        children: {\n          select: { id: true, name: true, slug: true },\n        },\n        _count: {\n          select: { posts: true },\n        },\n      },\n    }),\n    prisma.blogCategory.count({ where }),\n  ])\n\n  return { categories, total, limit, offset }\n}\n\nexport async function updateCategory(id: string, input: UpdateCategoryInput) {\n  const existing = await prisma.blogCategory.findUnique({ where: { id } })\n  if (!existing) {\n    throw new Error('Category not found')\n  }\n\n  let slug = existing.slug\n  if (input.slug && input.slug !== existing.slug) {\n    slug = await ensureUniqueSlug(input.slug, 'category', id)\n  }\n\n  return prisma.blogCategory.update({\n    where: { id },\n    data: {\n      name: input.name,\n      slug,\n      description: input.description,\n      parentId: input.parentId,\n      imageId: input.imageId,\n      metaTitle: input.metaTitle,\n      metaDescription: input.metaDescription,\n    },\n    include: {\n      parent: true,\n      children: true,\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function deleteCategory(id: string) {\n  // Check for child categories\n  const children = await prisma.blogCategory.count({ where: { parentId: id } })\n  if (children > 0) {\n    throw new Error('Cannot delete category with child categories')\n  }\n\n  // Delete post associations\n  await prisma.blogPostCategory.deleteMany({ where: { categoryId: id } })\n\n  return prisma.blogCategory.delete({ where: { id } })\n}\n\n// ============ BLOG TAGS ============\n\nexport interface CreateTagInput {\n  name: string\n  slug?: string\n  description?: string\n}\n\nexport interface UpdateTagInput extends Partial<CreateTagInput> {}\n\nexport async function createTag(input: CreateTagInput) {\n  const slug = input.slug || generateSlug(input.name)\n  const uniqueSlug = await ensureUniqueSlug(slug, 'tag')\n\n  return prisma.blogTag.create({\n    data: {\n      name: input.name,\n      slug: uniqueSlug,\n      description: input.description,\n    },\n    include: {\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function getTag(id: string) {\n  return prisma.blogTag.findUnique({\n    where: { id },\n    include: {\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function getTagBySlug(slug: string) {\n  return prisma.blogTag.findUnique({\n    where: { slug },\n    include: {\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function listTags(options: {\n  search?: string\n  limit?: number\n  offset?: number\n} = {}) {\n  const { search, limit = 100, offset = 0 } = options\n\n  const where: Prisma.BlogTagWhereInput = {}\n\n  if (search) {\n    where.name = { contains: search, mode: 'insensitive' }\n  }\n\n  const [tags, total] = await Promise.all([\n    prisma.blogTag.findMany({\n      where,\n      take: limit,\n      skip: offset,\n      orderBy: { name: 'asc' },\n      include: {\n        _count: {\n          select: { posts: true },\n        },\n      },\n    }),\n    prisma.blogTag.count({ where }),\n  ])\n\n  return { tags, total, limit, offset }\n}\n\nexport async function updateTag(id: string, input: UpdateTagInput) {\n  const existing = await prisma.blogTag.findUnique({ where: { id } })\n  if (!existing) {\n    throw new Error('Tag not found')\n  }\n\n  let slug = existing.slug\n  if (input.slug && input.slug !== existing.slug) {\n    slug = await ensureUniqueSlug(input.slug, 'tag', id)\n  }\n\n  return prisma.blogTag.update({\n    where: { id },\n    data: {\n      name: input.name,\n      slug,\n      description: input.description,\n    },\n    include: {\n      _count: {\n        select: { posts: true },\n      },\n    },\n  })\n}\n\nexport async function deleteTag(id: string) {\n  // Delete post associations\n  await prisma.blogPostTag.deleteMany({ where: { tagId: id } })\n\n  return prisma.blogTag.delete({ where: { id } })\n}\n","/**\n * Cart Management Service\n *\n * Handles cart operations including:\n * - Guest and authenticated carts\n * - Item management (add, update, remove)\n * - Discount application\n * - Total calculation\n * - Cart merging on login\n * - Abandonment tracking\n */\n\nimport { prisma } from '../db';\nimport { CartStatus } from '@prisma/client';\n\n// Types\nexport interface CartItemInput {\n  productId: string;\n  variantId?: string | null;\n  quantity: number;\n}\n\nexport interface CartIdentifier {\n  sessionId?: string;\n  userId?: string;\n  cartId?: string;\n}\n\nexport interface CartWithItems {\n  id: string;\n  sessionId: string | null;\n  userId: string | null;\n  email: string | null;\n  status: CartStatus;\n  subtotal: number;\n  discountTotal: number;\n  taxTotal: number;\n  shippingTotal: number;\n  total: number;\n  discountCodeId: string | null;\n  abandonedAt: Date | null;\n  createdAt: Date;\n  updatedAt: Date;\n  items: Array<{\n    id: string;\n    productId: string;\n    variantId: string | null;\n    quantity: number;\n    title: string;\n    variantTitle: string | null;\n    price: number;\n    imageUrl: string | null;\n  }>;\n  discountCode: {\n    id: string;\n    code: string;\n    type: string;\n    value: number;\n  } | null;\n}\n\n/**\n * Get or create a cart by session ID or user ID\n */\nexport async function getOrCreateCart(\n  identifier: CartIdentifier\n): Promise<CartWithItems> {\n  const { sessionId, userId, cartId } = identifier;\n\n  // If cartId provided, fetch directly\n  if (cartId) {\n    const cart = await prisma.cart.findUnique({\n      where: { id: cartId },\n      include: {\n        items: {\n          orderBy: { createdAt: 'asc' },\n        },\n        discountCode: {\n          select: { id: true, code: true, type: true, value: true },\n        },\n      },\n    });\n\n    if (cart && cart.status === CartStatus.ACTIVE) {\n      return cart as CartWithItems;\n    }\n  }\n\n  // Try to find existing cart\n  let cart = await findExistingCart(identifier);\n\n  // Create new cart if none exists\n  if (!cart) {\n    cart = await prisma.cart.create({\n      data: {\n        sessionId: sessionId || null,\n        userId: userId || null,\n        status: CartStatus.ACTIVE,\n      },\n      include: {\n        items: true,\n        discountCode: {\n          select: { id: true, code: true, type: true, value: true },\n        },\n      },\n    });\n  }\n\n  return cart as CartWithItems;\n}\n\n/**\n * Find existing active cart\n */\nasync function findExistingCart(\n  identifier: CartIdentifier\n): Promise<CartWithItems | null> {\n  const { sessionId, userId } = identifier;\n\n  // Prefer user cart over session cart\n  if (userId) {\n    const cart = await prisma.cart.findFirst({\n      where: {\n        userId,\n        status: CartStatus.ACTIVE,\n      },\n      include: {\n        items: {\n          orderBy: { createdAt: 'asc' },\n        },\n        discountCode: {\n          select: { id: true, code: true, type: true, value: true },\n        },\n      },\n    });\n    if (cart) return cart as CartWithItems;\n  }\n\n  // Fall back to session cart\n  if (sessionId) {\n    const cart = await prisma.cart.findUnique({\n      where: { sessionId },\n      include: {\n        items: {\n          orderBy: { createdAt: 'asc' },\n        },\n        discountCode: {\n          select: { id: true, code: true, type: true, value: true },\n        },\n      },\n    });\n    if (cart && cart.status === CartStatus.ACTIVE) {\n      return cart as CartWithItems;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Add item to cart\n */\nexport async function addToCart(\n  cartId: string,\n  item: CartItemInput\n): Promise<CartWithItems> {\n  const { productId, variantId, quantity } = item;\n\n  // Get product/variant info for snapshot\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    include: {\n      variants: variantId ? { where: { id: variantId } } : false,\n      images: { take: 1, orderBy: { position: 'asc' }, include: { media: true } },\n    },\n  });\n\n  if (!product) {\n    throw new Error('Product not found');\n  }\n\n  const variant = variantId\n    ? await prisma.productVariant.findUnique({ where: { id: variantId } })\n    : null;\n\n  // Determine price (variant price or product basePrice)\n  const price = variant?.price ?? product.basePrice ?? 0;\n  const title = product.title;\n  const variantTitle = variant?.sku || null;\n  const imageUrl = product.images[0]?.media?.url || null;\n\n  // Check if item already exists in cart\n  const existingItem = await prisma.cartItem.findUnique({\n    where: {\n      cartId_productId_variantId: {\n        cartId,\n        productId,\n        variantId: variantId || '',\n      },\n    },\n  });\n\n  if (existingItem) {\n    // Update quantity\n    await prisma.cartItem.update({\n      where: { id: existingItem.id },\n      data: { quantity: existingItem.quantity + quantity },\n    });\n  } else {\n    // Create new item\n    await prisma.cartItem.create({\n      data: {\n        cartId,\n        productId,\n        variantId,\n        quantity,\n        title,\n        variantTitle,\n        price,\n        imageUrl,\n      },\n    });\n  }\n\n  // Recalculate totals and return updated cart\n  return recalculateCart(cartId);\n}\n\n/**\n * Update item quantity\n */\nexport async function updateCartItem(\n  cartId: string,\n  itemId: string,\n  quantity: number\n): Promise<CartWithItems> {\n  if (quantity <= 0) {\n    return removeFromCart(cartId, itemId);\n  }\n\n  await prisma.cartItem.update({\n    where: { id: itemId, cartId },\n    data: { quantity },\n  });\n\n  return recalculateCart(cartId);\n}\n\n/**\n * Remove item from cart\n */\nexport async function removeFromCart(\n  cartId: string,\n  itemId: string\n): Promise<CartWithItems> {\n  await prisma.cartItem.delete({\n    where: { id: itemId, cartId },\n  });\n\n  return recalculateCart(cartId);\n}\n\n/**\n * Clear all items from cart\n */\nexport async function clearCart(cartId: string): Promise<CartWithItems> {\n  await prisma.cartItem.deleteMany({\n    where: { cartId },\n  });\n\n  return recalculateCart(cartId);\n}\n\n/**\n * Apply discount code to cart\n */\nexport async function applyDiscount(\n  cartId: string,\n  code: string\n): Promise<{ cart: CartWithItems; error?: string }> {\n  // Find discount code\n  const discount = await prisma.discountCode.findUnique({\n    where: { code: code.toUpperCase() },\n  });\n\n  if (!discount) {\n    return {\n      cart: await getCartById(cartId),\n      error: 'Invalid discount code',\n    };\n  }\n\n  // Check if discount is enabled\n  if (!discount.enabled) {\n    return {\n      cart: await getCartById(cartId),\n      error: 'This discount code is no longer active',\n    };\n  }\n\n  // Check date validity\n  const now = new Date();\n  if (discount.startsAt && discount.startsAt > now) {\n    return {\n      cart: await getCartById(cartId),\n      error: 'This discount code is not yet active',\n    };\n  }\n  if (discount.expiresAt && discount.expiresAt < now) {\n    return {\n      cart: await getCartById(cartId),\n      error: 'This discount code has expired',\n    };\n  }\n\n  // Check usage limit\n  if (discount.usageLimit && discount.usageCount >= discount.usageLimit) {\n    return {\n      cart: await getCartById(cartId),\n      error: 'This discount code has reached its usage limit',\n    };\n  }\n\n  // Apply discount to cart\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: { discountCodeId: discount.id },\n  });\n\n  const cart = await recalculateCart(cartId);\n\n  // Check minimum order value\n  if (discount.minOrderValue && cart.subtotal < discount.minOrderValue) {\n    // Remove discount if minimum not met\n    await prisma.cart.update({\n      where: { id: cartId },\n      data: { discountCodeId: null },\n    });\n\n    return {\n      cart: await recalculateCart(cartId),\n      error: `Minimum order value of $${(discount.minOrderValue / 100).toFixed(2)} required`,\n    };\n  }\n\n  return { cart };\n}\n\n/**\n * Remove discount from cart\n */\nexport async function removeDiscount(cartId: string): Promise<CartWithItems> {\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: { discountCodeId: null },\n  });\n\n  return recalculateCart(cartId);\n}\n\n/**\n * Update cart email (for guest abandonment recovery)\n */\nexport async function updateCartEmail(\n  cartId: string,\n  email: string\n): Promise<CartWithItems> {\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: { email },\n  });\n\n  return getCartById(cartId);\n}\n\n/**\n * Merge guest cart into user cart on login\n */\nexport async function mergeCartsOnLogin(\n  sessionId: string,\n  userId: string\n): Promise<CartWithItems | null> {\n  // Find guest cart\n  const guestCart = await prisma.cart.findUnique({\n    where: { sessionId },\n    include: { items: true },\n  });\n\n  if (!guestCart || guestCart.status !== CartStatus.ACTIVE) {\n    // No guest cart to merge, return user's existing cart if any\n    return findExistingCart({ userId });\n  }\n\n  // Find or create user cart\n  let userCart = await prisma.cart.findFirst({\n    where: { userId, status: CartStatus.ACTIVE },\n    include: { items: true },\n  });\n\n  if (!userCart) {\n    // Convert guest cart to user cart\n    await prisma.cart.update({\n      where: { id: guestCart.id },\n      data: {\n        userId,\n        sessionId: null, // Clear session ID\n      },\n    });\n    return getCartById(guestCart.id);\n  }\n\n  // Merge guest items into user cart\n  for (const guestItem of guestCart.items) {\n    const existingItem = userCart.items.find(\n      (item) =>\n        item.productId === guestItem.productId &&\n        item.variantId === guestItem.variantId\n    );\n\n    if (existingItem) {\n      // Update quantity\n      await prisma.cartItem.update({\n        where: { id: existingItem.id },\n        data: { quantity: existingItem.quantity + guestItem.quantity },\n      });\n    } else {\n      // Move item to user cart\n      await prisma.cartItem.update({\n        where: { id: guestItem.id },\n        data: { cartId: userCart.id },\n      });\n    }\n  }\n\n  // Mark guest cart as expired\n  await prisma.cart.update({\n    where: { id: guestCart.id },\n    data: { status: CartStatus.EXPIRED },\n  });\n\n  return recalculateCart(userCart.id);\n}\n\n/**\n * Mark cart as converted (after successful checkout)\n */\nexport async function convertCart(\n  cartId: string,\n  orderId: string\n): Promise<void> {\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: {\n      status: CartStatus.CONVERTED,\n      convertedToOrderId: orderId,\n    },\n  });\n}\n\n/**\n * Get cart by ID\n */\nasync function getCartById(cartId: string): Promise<CartWithItems> {\n  const cart = await prisma.cart.findUnique({\n    where: { id: cartId },\n    include: {\n      items: {\n        orderBy: { createdAt: 'asc' },\n      },\n      discountCode: {\n        select: { id: true, code: true, type: true, value: true },\n      },\n    },\n  });\n\n  if (!cart) {\n    throw new Error('Cart not found');\n  }\n\n  return cart as CartWithItems;\n}\n\n/**\n * Recalculate cart totals\n */\nasync function recalculateCart(cartId: string): Promise<CartWithItems> {\n  const cart = await prisma.cart.findUnique({\n    where: { id: cartId },\n    include: {\n      items: true,\n      discountCode: true,\n    },\n  });\n\n  if (!cart) {\n    throw new Error('Cart not found');\n  }\n\n  // Calculate subtotal\n  const subtotal = cart.items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n\n  // Calculate discount\n  let discountTotal = 0;\n  if (cart.discountCode) {\n    const discount = cart.discountCode;\n    if (discount.type === 'PERCENTAGE') {\n      discountTotal = Math.round(subtotal * (discount.value / 100));\n      // Apply max discount cap if set\n      if (discount.maxDiscount && discountTotal > discount.maxDiscount) {\n        discountTotal = discount.maxDiscount;\n      }\n    } else if (discount.type === 'FIXED') {\n      discountTotal = Math.min(discount.value, subtotal);\n    }\n    // FREE_SHIPPING handled separately\n  }\n\n  // Calculate total (tax and shipping calculated at checkout)\n  const total = Math.max(0, subtotal - discountTotal);\n\n  // Update cart totals\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: {\n      subtotal,\n      discountTotal,\n      total,\n      updatedAt: new Date(),\n    },\n  });\n\n  return getCartById(cartId);\n}\n\n// =============================================================================\n// ABANDONMENT TRACKING\n// =============================================================================\n\n/**\n * Mark carts as abandoned after timeout (called by scheduled job)\n */\nexport async function markAbandonedCarts(\n  timeoutMinutes: number = 60\n): Promise<number> {\n  const cutoffTime = new Date(Date.now() - timeoutMinutes * 60 * 1000);\n\n  const result = await prisma.cart.updateMany({\n    where: {\n      status: CartStatus.ACTIVE,\n      updatedAt: { lt: cutoffTime },\n      abandonedAt: null,\n      items: { some: {} }, // Has at least one item\n    },\n    data: {\n      status: CartStatus.ABANDONED,\n      abandonedAt: new Date(),\n    },\n  });\n\n  return result.count;\n}\n\n/**\n * Get abandoned carts for recovery emails\n */\nexport async function getAbandonedCartsForRecovery(\n  minAgeMinutes: number = 60,\n  maxAgeHours: number = 72\n): Promise<Array<CartWithItems & { email: string }>> {\n  const minAge = new Date(Date.now() - minAgeMinutes * 60 * 1000);\n  const maxAge = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);\n\n  const carts = await prisma.cart.findMany({\n    where: {\n      status: CartStatus.ABANDONED,\n      abandonedAt: {\n        gte: maxAge,\n        lte: minAge,\n      },\n      recoveryEmailAt: null,\n      email: { not: null },\n    },\n    include: {\n      items: {\n        orderBy: { createdAt: 'asc' },\n      },\n      discountCode: {\n        select: { id: true, code: true, type: true, value: true },\n      },\n    },\n  });\n\n  return carts.filter((cart) => cart.email !== null) as Array<\n    CartWithItems & { email: string }\n  >;\n}\n\n/**\n * Mark recovery email as sent\n */\nexport async function markRecoveryEmailSent(cartId: string): Promise<void> {\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: { recoveryEmailAt: new Date() },\n  });\n}\n\n/**\n * Mark cart as recovered (customer returned)\n */\nexport async function markCartRecovered(cartId: string): Promise<CartWithItems> {\n  await prisma.cart.update({\n    where: { id: cartId },\n    data: {\n      status: CartStatus.ACTIVE,\n      recoveredAt: new Date(),\n    },\n  });\n\n  return getCartById(cartId);\n}\n\n/**\n * Clean up expired carts (called by scheduled job)\n */\nexport async function cleanupExpiredCarts(\n  expiryDays: number = 30\n): Promise<number> {\n  const cutoffTime = new Date(Date.now() - expiryDays * 24 * 60 * 60 * 1000);\n\n  // Delete cart items first (cascade should handle this, but being explicit)\n  await prisma.cartItem.deleteMany({\n    where: {\n      cart: {\n        OR: [\n          { status: CartStatus.EXPIRED },\n          {\n            status: CartStatus.ABANDONED,\n            abandonedAt: { lt: cutoffTime },\n          },\n        ],\n      },\n    },\n  });\n\n  // Delete expired/old abandoned carts\n  const result = await prisma.cart.deleteMany({\n    where: {\n      OR: [\n        { status: CartStatus.EXPIRED },\n        {\n          status: CartStatus.ABANDONED,\n          abandonedAt: { lt: cutoffTime },\n        },\n      ],\n    },\n  });\n\n  return result.count;\n}\n\n/**\n * Get cart statistics for analytics\n */\nexport async function getCartStats(): Promise<{\n  activeCarts: number;\n  abandonedCarts: number;\n  recoveredCarts: number;\n  conversionRate: number;\n  averageCartValue: number;\n}> {\n  const [active, abandoned, recovered, converted, avgValue] = await Promise.all([\n    prisma.cart.count({ where: { status: CartStatus.ACTIVE } }),\n    prisma.cart.count({ where: { status: CartStatus.ABANDONED } }),\n    prisma.cart.count({ where: { recoveredAt: { not: null } } }),\n    prisma.cart.count({ where: { status: CartStatus.CONVERTED } }),\n    prisma.cart.aggregate({\n      where: { status: CartStatus.ACTIVE, total: { gt: 0 } },\n      _avg: { total: true },\n    }),\n  ]);\n\n  const totalWithItems = abandoned + converted + recovered;\n  const conversionRate = totalWithItems > 0 ? (converted / totalWithItems) * 100 : 0;\n\n  return {\n    activeCarts: active,\n    abandonedCarts: abandoned,\n    recoveredCarts: recovered,\n    conversionRate: Math.round(conversionRate * 100) / 100,\n    averageCartValue: avgValue._avg.total || 0,\n  };\n}\n","/**\n * Discount Code Validator\n *\n * Validates discount codes against all business rules\n */\n\nimport { prisma } from '../db';\nimport type { DiscountCode, DiscountUsage } from '@prisma/client';\n\nexport interface ValidationContext {\n  code: string;\n  subtotal: number; // Cart subtotal in cents\n  userId?: string | null;\n  email?: string | null;\n  isFirstOrder?: boolean;\n  items?: Array<{\n    productId: string;\n    categoryIds: string[];\n    quantity: number;\n    price: number; // Price per unit in cents\n    isOnSale?: boolean;\n  }>;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  discount: DiscountCode | null;\n  error?: string;\n  errorCode?: ValidationErrorCode;\n}\n\nexport type ValidationErrorCode =\n  | 'NOT_FOUND'\n  | 'DISABLED'\n  | 'EXPIRED'\n  | 'NOT_STARTED'\n  | 'USAGE_LIMIT_REACHED'\n  | 'CUSTOMER_LIMIT_REACHED'\n  | 'MIN_ORDER_NOT_MET'\n  | 'FIRST_ORDER_ONLY'\n  | 'NO_APPLICABLE_ITEMS'\n  | 'EXCLUDED_ITEMS_ONLY';\n\n/**\n * Validate a discount code against all business rules\n */\nexport async function validateDiscountCode(\n  context: ValidationContext\n): Promise<ValidationResult> {\n  const { code, subtotal, userId, email, isFirstOrder, items } = context;\n\n  // 1. Find the discount code\n  const discount = await prisma.discountCode.findUnique({\n    where: { code: code.toUpperCase().trim() },\n  });\n\n  if (!discount) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'Invalid discount code',\n      errorCode: 'NOT_FOUND',\n    };\n  }\n\n  // 2. Check if enabled\n  if (!discount.enabled) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'This discount code is no longer active',\n      errorCode: 'DISABLED',\n    };\n  }\n\n  // 3. Check validity period\n  const now = new Date();\n  if (discount.startsAt > now) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'This discount code is not yet active',\n      errorCode: 'NOT_STARTED',\n    };\n  }\n\n  if (discount.expiresAt && discount.expiresAt < now) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'This discount code has expired',\n      errorCode: 'EXPIRED',\n    };\n  }\n\n  // 4. Check total usage limit\n  if (discount.usageLimit !== null && discount.usageCount >= discount.usageLimit) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'This discount code has reached its usage limit',\n      errorCode: 'USAGE_LIMIT_REACHED',\n    };\n  }\n\n  // 5. Check per-customer limit\n  if (discount.perCustomer !== null && (userId || email)) {\n    const customerUsageCount = await prisma.discountUsage.count({\n      where: {\n        discountCodeId: discount.id,\n        OR: [\n          ...(userId ? [{ userId }] : []),\n          ...(email ? [{ email }] : []),\n        ],\n      },\n    });\n\n    if (customerUsageCount >= discount.perCustomer) {\n      return {\n        valid: false,\n        discount: null,\n        error: 'You have already used this discount code the maximum number of times',\n        errorCode: 'CUSTOMER_LIMIT_REACHED',\n      };\n    }\n  }\n\n  // 6. Check minimum order value\n  if (discount.minOrderValue !== null && subtotal < discount.minOrderValue) {\n    const minAmount = (discount.minOrderValue / 100).toFixed(2);\n    return {\n      valid: false,\n      discount: null,\n      error: `Minimum order of $${minAmount} required for this discount`,\n      errorCode: 'MIN_ORDER_NOT_MET',\n    };\n  }\n\n  // 7. Check first order only\n  if (discount.firstOrderOnly && !isFirstOrder) {\n    return {\n      valid: false,\n      discount: null,\n      error: 'This discount code is only valid for first orders',\n      errorCode: 'FIRST_ORDER_ONLY',\n    };\n  }\n\n  // 8. Check applicability to items (for PRODUCT and CATEGORY apply types)\n  if (items && items.length > 0 && discount.applyTo !== 'ORDER' && discount.applyTo !== 'SHIPPING') {\n    const applicableItems = getApplicableItems(discount, items);\n\n    if (applicableItems.length === 0) {\n      return {\n        valid: false,\n        discount: null,\n        error: 'This discount code does not apply to any items in your cart',\n        errorCode: 'NO_APPLICABLE_ITEMS',\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    discount,\n  };\n}\n\n/**\n * Get items that a discount applies to\n */\nexport function getApplicableItems(\n  discount: DiscountCode,\n  items: Array<{\n    productId: string;\n    categoryIds: string[];\n    quantity: number;\n    price: number;\n    isOnSale?: boolean;\n  }>\n): typeof items {\n  return items.filter((item) => {\n    // Check if item is excluded\n    if (discount.excludeProductIds.includes(item.productId)) {\n      return false;\n    }\n\n    // Check if sale items are excluded\n    if (discount.excludeSaleItems && item.isOnSale) {\n      return false;\n    }\n\n    // For ORDER type, all items apply\n    if (discount.applyTo === 'ORDER') {\n      return true;\n    }\n\n    // For PRODUCT type, check product IDs\n    if (discount.applyTo === 'PRODUCT') {\n      return discount.productIds.length === 0 || discount.productIds.includes(item.productId);\n    }\n\n    // For CATEGORY type, check category IDs\n    if (discount.applyTo === 'CATEGORY') {\n      if (discount.categoryIds.length === 0) return true;\n      return item.categoryIds.some((catId) => discount.categoryIds.includes(catId));\n    }\n\n    // For SHIPPING type, no items apply (discount is on shipping)\n    if (discount.applyTo === 'SHIPPING') {\n      return false;\n    }\n\n    return false;\n  });\n}\n\n/**\n * Check if user is making their first order\n */\nexport async function isFirstOrderForUser(\n  userId?: string | null,\n  email?: string | null\n): Promise<boolean> {\n  if (!userId && !email) {\n    return true; // Guest with no email - assume first order\n  }\n\n  const existingOrders = await prisma.order.count({\n    where: {\n      OR: [\n        ...(userId ? [{ customerId: userId }] : []),\n        ...(email ? [{ email }] : []),\n      ],\n      paymentStatus: 'PAID',\n    },\n  });\n\n  return existingOrders === 0;\n}\n\n/**\n * Record discount usage after order is placed\n */\nexport async function recordDiscountUsage(\n  discountCodeId: string,\n  orderId: string,\n  userId: string | null,\n  email: string,\n  discountAmount: number\n): Promise<DiscountUsage> {\n  // Create usage record and update discount stats in a transaction\n  const [usage] = await prisma.$transaction([\n    prisma.discountUsage.create({\n      data: {\n        discountCodeId,\n        orderId,\n        userId,\n        email,\n        discountAmount,\n      },\n    }),\n    prisma.discountCode.update({\n      where: { id: discountCodeId },\n      data: {\n        usageCount: { increment: 1 },\n        ordersCount: { increment: 1 },\n        revenue: { increment: discountAmount },\n      },\n    }),\n  ]);\n\n  return usage;\n}\n","/**\n * Discount Calculator\n *\n * Calculates discount amounts for carts and orders\n */\n\nimport type { DiscountCode } from '@prisma/client';\nimport { getApplicableItems } from './validator';\n\nexport interface CartItem {\n  productId: string;\n  variantId?: string;\n  categoryIds: string[];\n  name?: string; // Optional - not always provided in validation context\n  quantity: number;\n  price: number; // Price per unit in cents\n  isOnSale?: boolean;\n}\n\nexport interface CartTotals {\n  subtotal: number; // Sum of item prices in cents\n  shippingTotal: number; // Shipping cost in cents\n}\n\nexport interface DiscountCalculation {\n  discountAmount: number; // Total discount in cents\n  discountedSubtotal: number; // Subtotal after discount\n  discountedShipping: number; // Shipping after discount\n  appliedTo: 'order' | 'products' | 'categories' | 'shipping';\n  itemDiscounts: Array<{\n    productId: string;\n    variantId?: string;\n    originalPrice: number;\n    discountAmount: number;\n    finalPrice: number;\n  }>;\n  description: string; // Human-readable discount description\n}\n\n/**\n * Calculate discount amount for a cart\n */\nexport function calculateDiscount(\n  discount: DiscountCode,\n  items: CartItem[],\n  totals: CartTotals\n): DiscountCalculation {\n  const { subtotal, shippingTotal } = totals;\n\n  // Handle FREE_SHIPPING type\n  if (discount.type === 'FREE_SHIPPING') {\n    return {\n      discountAmount: shippingTotal,\n      discountedSubtotal: subtotal,\n      discountedShipping: 0,\n      appliedTo: 'shipping',\n      itemDiscounts: [],\n      description: 'Free Shipping',\n    };\n  }\n\n  // Get applicable items for the discount\n  const applicableItems = discount.applyTo === 'SHIPPING'\n    ? []\n    : getApplicableItems(discount, items);\n\n  // Calculate base amount for discount\n  const applicableSubtotal =\n    discount.applyTo === 'ORDER'\n      ? subtotal\n      : applicableItems.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  if (applicableSubtotal === 0) {\n    return {\n      discountAmount: 0,\n      discountedSubtotal: subtotal,\n      discountedShipping: shippingTotal,\n      appliedTo: mapApplyTo(discount.applyTo),\n      itemDiscounts: [],\n      description: 'No applicable items',\n    };\n  }\n\n  // Calculate raw discount amount\n  let rawDiscount = 0;\n  let description = '';\n\n  switch (discount.type) {\n    case 'PERCENTAGE':\n      rawDiscount = Math.floor((applicableSubtotal * discount.value) / 100);\n      description = `${discount.value}% off`;\n      break;\n\n    case 'FIXED':\n      rawDiscount = discount.value;\n      description = `$${(discount.value / 100).toFixed(2)} off`;\n      break;\n\n    case 'BUY_X_GET_Y':\n      // For BUY_X_GET_Y, value represents the discount on Y items\n      // This is a simplified implementation\n      rawDiscount = calculateBuyXGetYDiscount(discount, applicableItems);\n      description = 'Buy X Get Y promotion';\n      break;\n\n    default:\n      rawDiscount = 0;\n      description = 'Unknown discount type';\n  }\n\n  // Apply maximum discount cap\n  let discountAmount = rawDiscount;\n  if (discount.maxDiscount !== null && discountAmount > discount.maxDiscount) {\n    discountAmount = discount.maxDiscount;\n    description += ` (max $${(discount.maxDiscount / 100).toFixed(2)})`;\n  }\n\n  // Ensure discount doesn't exceed applicable amount\n  discountAmount = Math.min(discountAmount, applicableSubtotal);\n\n  // Calculate per-item discounts for display\n  const itemDiscounts = calculateItemDiscounts(\n    discount,\n    applicableItems,\n    discountAmount,\n    applicableSubtotal\n  );\n\n  return {\n    discountAmount,\n    discountedSubtotal: subtotal - discountAmount,\n    discountedShipping: shippingTotal,\n    appliedTo: mapApplyTo(discount.applyTo),\n    itemDiscounts,\n    description,\n  };\n}\n\n/**\n * Calculate BUY_X_GET_Y discount\n * This is a simplified implementation - value represents the discount percentage on Y\n */\nfunction calculateBuyXGetYDiscount(\n  discount: DiscountCode,\n  items: CartItem[]\n): number {\n  // Simple implementation: every 3rd item is discounted by value%\n  // Can be enhanced with more complex BuyX/GetY config\n  let totalDiscount = 0;\n\n  for (const item of items) {\n    const freeItems = Math.floor(item.quantity / 3);\n    const itemDiscount = Math.floor((item.price * freeItems * discount.value) / 100);\n    totalDiscount += itemDiscount;\n  }\n\n  return totalDiscount;\n}\n\n/**\n * Calculate per-item discount breakdown\n */\nfunction calculateItemDiscounts(\n  discount: DiscountCode,\n  applicableItems: CartItem[],\n  totalDiscount: number,\n  applicableSubtotal: number\n): DiscountCalculation['itemDiscounts'] {\n  if (applicableSubtotal === 0) return [];\n\n  return applicableItems.map((item) => {\n    const itemTotal = item.price * item.quantity;\n    // Distribute discount proportionally\n    const itemDiscount = Math.floor((itemTotal / applicableSubtotal) * totalDiscount);\n\n    return {\n      productId: item.productId,\n      variantId: item.variantId,\n      originalPrice: itemTotal,\n      discountAmount: itemDiscount,\n      finalPrice: itemTotal - itemDiscount,\n    };\n  });\n}\n\n/**\n * Map applyTo enum to simplified type\n */\nfunction mapApplyTo(applyTo: string): 'order' | 'products' | 'categories' | 'shipping' {\n  switch (applyTo) {\n    case 'ORDER':\n      return 'order';\n    case 'PRODUCT':\n      return 'products';\n    case 'CATEGORY':\n      return 'categories';\n    case 'SHIPPING':\n      return 'shipping';\n    default:\n      return 'order';\n  }\n}\n\n/**\n * Format discount for display\n */\nexport function formatDiscount(discount: DiscountCode): string {\n  switch (discount.type) {\n    case 'PERCENTAGE':\n      return `${discount.value}% off`;\n    case 'FIXED':\n      return `$${(discount.value / 100).toFixed(2)} off`;\n    case 'FREE_SHIPPING':\n      return 'Free Shipping';\n    case 'BUY_X_GET_Y':\n      return 'Special Promotion';\n    default:\n      return discount.code;\n  }\n}\n\n/**\n * Get discount code summary for display\n */\nexport function getDiscountSummary(discount: DiscountCode): {\n  type: string;\n  value: string;\n  conditions: string[];\n} {\n  const conditions: string[] = [];\n\n  if (discount.minOrderValue) {\n    conditions.push(`Min order: $${(discount.minOrderValue / 100).toFixed(2)}`);\n  }\n\n  if (discount.maxDiscount) {\n    conditions.push(`Max discount: $${(discount.maxDiscount / 100).toFixed(2)}`);\n  }\n\n  if (discount.usageLimit) {\n    conditions.push(`${discount.usageLimit - discount.usageCount} uses remaining`);\n  }\n\n  if (discount.firstOrderOnly) {\n    conditions.push('First order only');\n  }\n\n  if (discount.expiresAt) {\n    const expires = new Date(discount.expiresAt);\n    conditions.push(`Expires: ${expires.toLocaleDateString()}`);\n  }\n\n  if (discount.applyTo === 'PRODUCT' && discount.productIds.length > 0) {\n    conditions.push('Specific products only');\n  }\n\n  if (discount.applyTo === 'CATEGORY' && discount.categoryIds.length > 0) {\n    conditions.push('Specific categories only');\n  }\n\n  if (discount.excludeSaleItems) {\n    conditions.push('Excludes sale items');\n  }\n\n  return {\n    type: discount.type,\n    value: formatDiscount(discount),\n    conditions,\n  };\n}\n\n/**\n * Calculate the final cart total with discount applied\n */\nexport function calculateCartTotals(\n  items: CartItem[],\n  shippingTotal: number,\n  taxRate: number,\n  discount: DiscountCode | null\n): {\n  subtotal: number;\n  discountTotal: number;\n  discountedSubtotal: number;\n  shippingTotal: number;\n  taxTotal: number;\n  total: number;\n  discountDescription: string | null;\n} {\n  const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  let discountTotal = 0;\n  let discountedSubtotal = subtotal;\n  let discountedShipping = shippingTotal;\n  let discountDescription: string | null = null;\n\n  if (discount) {\n    const calculation = calculateDiscount(discount, items, { subtotal, shippingTotal });\n    discountTotal = calculation.discountAmount;\n    discountedSubtotal = calculation.discountedSubtotal;\n    discountedShipping = calculation.discountedShipping;\n    discountDescription = calculation.description;\n  }\n\n  // Calculate tax on discounted subtotal\n  const taxTotal = Math.floor((discountedSubtotal * taxRate) / 100);\n\n  // Final total\n  const total = discountedSubtotal + discountedShipping + taxTotal;\n\n  return {\n    subtotal,\n    discountTotal,\n    discountedSubtotal,\n    shippingTotal: discountedShipping,\n    taxTotal,\n    total,\n    discountDescription,\n  };\n}\n","/**\n * Stripe Discount Sync\n *\n * Syncs discount codes with Stripe coupons and promotion codes\n */\n\nimport Stripe from 'stripe';\nimport { prisma } from '../db';\nimport { getStripeSettings } from '../stripe';\nimport type { DiscountCode, DiscountType } from '@prisma/client';\n\n// Stripe client cache\nlet stripeClient: Stripe | null = null;\n\nasync function getStripeClient(): Promise<Stripe> {\n  const settings = await getStripeSettings();\n\n  const secretKey = settings.secretKey || process.env.STRIPE_SECRET_KEY;\n  if (!secretKey) {\n    throw new Error('Stripe secret key not configured');\n  }\n\n  if (!stripeClient) {\n    stripeClient = new Stripe(secretKey, { apiVersion: '2025-02-24.acacia' });\n  }\n  return stripeClient;\n}\n\n/**\n * Convert our discount type to Stripe coupon params\n */\nfunction mapDiscountToStripeCoupon(discount: DiscountCode): Stripe.CouponCreateParams {\n  const metadata: Record<string, string> = {\n    discountCodeId: discount.id,\n    source: 'nextjs-cms',\n  };\n\n  const params: Stripe.CouponCreateParams = {\n    name: discount.code,\n    metadata,\n  };\n\n  // Map discount type\n  switch (discount.type) {\n    case 'PERCENTAGE':\n      params.percent_off = discount.value;\n      break;\n    case 'FIXED':\n      params.amount_off = discount.value;\n      params.currency = 'usd'; // TODO: Get from settings\n      break;\n    case 'FREE_SHIPPING':\n      // Stripe doesn't have native free shipping coupons\n      // We use a 0% coupon and handle shipping separately\n      params.percent_off = 0;\n      metadata.freeShipping = 'true';\n      break;\n    case 'BUY_X_GET_Y':\n      // BuyXGetY is complex - use percentage for simplicity\n      params.percent_off = discount.value;\n      metadata.buyXGetY = 'true';\n      break;\n  }\n\n  // Set duration\n  if (discount.expiresAt) {\n    params.redeem_by = Math.floor(discount.expiresAt.getTime() / 1000);\n  }\n\n  // Set max redemptions\n  if (discount.usageLimit) {\n    params.max_redemptions = discount.usageLimit;\n  }\n\n  return params;\n}\n\n/**\n * Create a Stripe coupon from a discount code\n */\nexport async function createStripeCoupon(discountId: string): Promise<string> {\n  const stripe = await getStripeClient();\n\n  const discount = await prisma.discountCode.findUnique({\n    where: { id: discountId },\n  });\n\n  if (!discount) {\n    throw new Error('Discount code not found');\n  }\n\n  // Create the coupon\n  const couponParams = mapDiscountToStripeCoupon(discount);\n  const coupon = await stripe.coupons.create(couponParams);\n\n  // Update discount with Stripe coupon ID\n  await prisma.discountCode.update({\n    where: { id: discountId },\n    data: {\n      stripeCouponId: coupon.id,\n      stripeSyncedAt: new Date(),\n    },\n  });\n\n  return coupon.id;\n}\n\n/**\n * Create a Stripe promotion code from a discount code\n * Promotion codes are customer-facing codes that reference coupons\n */\nexport async function createStripePromotionCode(discountId: string): Promise<string> {\n  const stripe = await getStripeClient();\n\n  const discount = await prisma.discountCode.findUnique({\n    where: { id: discountId },\n  });\n\n  if (!discount) {\n    throw new Error('Discount code not found');\n  }\n\n  // Ensure we have a Stripe coupon first\n  let stripeCouponId = discount.stripeCouponId;\n  if (!stripeCouponId) {\n    stripeCouponId = await createStripeCoupon(discountId);\n  }\n\n  // Create promotion code params\n  const promoParams: Stripe.PromotionCodeCreateParams = {\n    coupon: stripeCouponId,\n    code: discount.code,\n    active: discount.enabled,\n    metadata: {\n      discountCodeId: discount.id,\n      source: 'nextjs-cms',\n    },\n  };\n\n  // Set restrictions\n  const restrictions: Stripe.PromotionCodeCreateParams.Restrictions = {};\n\n  if (discount.minOrderValue) {\n    restrictions.minimum_amount = discount.minOrderValue;\n    restrictions.minimum_amount_currency = 'usd';\n  }\n\n  if (discount.firstOrderOnly) {\n    restrictions.first_time_transaction = true;\n  }\n\n  if (Object.keys(restrictions).length > 0) {\n    promoParams.restrictions = restrictions;\n  }\n\n  // Set max redemptions\n  if (discount.usageLimit) {\n    promoParams.max_redemptions = discount.usageLimit;\n  }\n\n  // Set expiration\n  if (discount.expiresAt) {\n    promoParams.expires_at = Math.floor(discount.expiresAt.getTime() / 1000);\n  }\n\n  const promotionCode = await stripe.promotionCodes.create(promoParams);\n\n  // Update discount with Stripe promotion code ID\n  await prisma.discountCode.update({\n    where: { id: discountId },\n    data: {\n      stripePromotionCodeId: promotionCode.id,\n      stripeSyncedAt: new Date(),\n    },\n  });\n\n  return promotionCode.id;\n}\n\n/**\n * Sync a discount code to Stripe (create or update)\n */\nexport async function syncDiscountToStripe(discountId: string): Promise<{\n  couponId: string;\n  promotionCodeId: string;\n}> {\n  const stripe = await getStripeClient();\n\n  const discount = await prisma.discountCode.findUnique({\n    where: { id: discountId },\n  });\n\n  if (!discount) {\n    throw new Error('Discount code not found');\n  }\n\n  if (!discount.stripeSyncEnabled) {\n    throw new Error('Stripe sync is disabled for this discount');\n  }\n\n  let couponId = discount.stripeCouponId;\n  let promotionCodeId = discount.stripePromotionCodeId;\n\n  // Update existing coupon or create new one\n  if (couponId) {\n    try {\n      // Coupons can only update name and metadata\n      await stripe.coupons.update(couponId, {\n        name: discount.code,\n        metadata: {\n          discountCodeId: discount.id,\n          source: 'nextjs-cms',\n          updatedAt: new Date().toISOString(),\n        },\n      });\n    } catch (error) {\n      // Coupon might have been deleted in Stripe - create new one\n      console.log('Stripe coupon not found, creating new one');\n      couponId = await createStripeCoupon(discountId);\n    }\n  } else {\n    couponId = await createStripeCoupon(discountId);\n  }\n\n  // Update existing promotion code or create new one\n  if (promotionCodeId) {\n    try {\n      await stripe.promotionCodes.update(promotionCodeId, {\n        active: discount.enabled,\n        metadata: {\n          discountCodeId: discount.id,\n          source: 'nextjs-cms',\n          updatedAt: new Date().toISOString(),\n        },\n      });\n    } catch (error) {\n      // Promotion code might have been deleted - create new one\n      console.log('Stripe promotion code not found, creating new one');\n      promotionCodeId = await createStripePromotionCode(discountId);\n    }\n  } else {\n    promotionCodeId = await createStripePromotionCode(discountId);\n  }\n\n  // Update sync timestamp\n  await prisma.discountCode.update({\n    where: { id: discountId },\n    data: { stripeSyncedAt: new Date() },\n  });\n\n  return { couponId, promotionCodeId: promotionCodeId! };\n}\n\n/**\n * Delete Stripe coupon and promotion code for a discount\n */\nexport async function deleteStripeDiscount(discountId: string): Promise<void> {\n  const stripe = await getStripeClient();\n\n  const discount = await prisma.discountCode.findUnique({\n    where: { id: discountId },\n  });\n\n  if (!discount) {\n    return;\n  }\n\n  // Deactivate promotion code (can't delete, only deactivate)\n  if (discount.stripePromotionCodeId) {\n    try {\n      await stripe.promotionCodes.update(discount.stripePromotionCodeId, {\n        active: false,\n      });\n    } catch (error) {\n      console.error('Failed to deactivate Stripe promotion code:', error);\n    }\n  }\n\n  // Delete coupon\n  if (discount.stripeCouponId) {\n    try {\n      await stripe.coupons.del(discount.stripeCouponId);\n    } catch (error) {\n      console.error('Failed to delete Stripe coupon:', error);\n    }\n  }\n\n  // Clear Stripe IDs\n  await prisma.discountCode.update({\n    where: { id: discountId },\n    data: {\n      stripeCouponId: null,\n      stripePromotionCodeId: null,\n      stripeSyncedAt: null,\n    },\n  });\n}\n\n/**\n * Toggle promotion code active status in Stripe\n */\nexport async function toggleStripePromotionCode(\n  discountId: string,\n  active: boolean\n): Promise<void> {\n  const stripe = await getStripeClient();\n\n  const discount = await prisma.discountCode.findUnique({\n    where: { id: discountId },\n  });\n\n  if (!discount?.stripePromotionCodeId) {\n    return;\n  }\n\n  await stripe.promotionCodes.update(discount.stripePromotionCodeId, {\n    active,\n  });\n}\n\n/**\n * Import a Stripe coupon/promotion code into our system\n */\nexport async function importFromStripe(promotionCodeId: string): Promise<string> {\n  const stripe = await getStripeClient();\n\n  // Get promotion code with coupon\n  const promotionCode = await stripe.promotionCodes.retrieve(promotionCodeId, {\n    expand: ['coupon'],\n  });\n\n  const coupon = promotionCode.coupon as Stripe.Coupon;\n\n  // Check if already imported\n  const existing = await prisma.discountCode.findFirst({\n    where: {\n      OR: [\n        { stripePromotionCodeId: promotionCodeId },\n        { stripeCouponId: coupon.id },\n        { code: promotionCode.code },\n      ],\n    },\n  });\n\n  if (existing) {\n    throw new Error(`Discount code already exists: ${existing.code}`);\n  }\n\n  // Determine discount type\n  let type: DiscountType = 'PERCENTAGE';\n  let value = 0;\n\n  if (coupon.percent_off) {\n    type = 'PERCENTAGE';\n    value = coupon.percent_off;\n  } else if (coupon.amount_off) {\n    type = 'FIXED';\n    value = coupon.amount_off;\n  }\n\n  // Check metadata for special types\n  if (coupon.metadata?.freeShipping === 'true') {\n    type = 'FREE_SHIPPING';\n  }\n\n  // Create discount code\n  const discount = await prisma.discountCode.create({\n    data: {\n      code: promotionCode.code,\n      description: coupon.name || `Imported from Stripe: ${promotionCode.code}`,\n      type,\n      value,\n      minOrderValue: promotionCode.restrictions?.minimum_amount || null,\n      usageLimit: promotionCode.max_redemptions || null,\n      usageCount: promotionCode.times_redeemed || 0,\n      firstOrderOnly: promotionCode.restrictions?.first_time_transaction || false,\n      startsAt: new Date(),\n      expiresAt: promotionCode.expires_at\n        ? new Date(promotionCode.expires_at * 1000)\n        : null,\n      enabled: promotionCode.active,\n      stripeCouponId: coupon.id,\n      stripePromotionCodeId: promotionCodeId,\n      stripeSyncEnabled: true,\n      stripeSyncedAt: new Date(),\n    },\n  });\n\n  return discount.id;\n}\n\n/**\n * Get Stripe coupons not yet imported\n */\nexport async function listUnimportedStripeCoupons(): Promise<\n  Array<{\n    id: string;\n    name: string | null;\n    percentOff: number | null;\n    amountOff: number | null;\n    currency: string | null;\n    valid: boolean;\n  }>\n> {\n  const stripe = await getStripeClient();\n\n  // Get all coupons from Stripe\n  const coupons = await stripe.coupons.list({ limit: 100 });\n\n  // Get already imported coupon IDs\n  const importedCoupons = await prisma.discountCode.findMany({\n    where: { stripeCouponId: { not: null } },\n    select: { stripeCouponId: true },\n  });\n\n  const importedIds = new Set(importedCoupons.map((d) => d.stripeCouponId));\n\n  // Filter out already imported\n  return coupons.data\n    .filter((c) => !importedIds.has(c.id))\n    .map((c) => ({\n      id: c.id,\n      name: c.name,\n      percentOff: c.percent_off,\n      amountOff: c.amount_off,\n      currency: c.currency,\n      valid: c.valid,\n    }));\n}\n\n/**\n * Validate a promotion code in Stripe\n */\nexport async function validateStripePromotionCode(\n  code: string\n): Promise<{\n  valid: boolean;\n  promotionCodeId?: string;\n  couponId?: string;\n  percentOff?: number;\n  amountOff?: number;\n  error?: string;\n}> {\n  const stripe = await getStripeClient();\n\n  try {\n    // Search for the promotion code\n    const promotionCodes = await stripe.promotionCodes.list({\n      code,\n      active: true,\n      limit: 1,\n    });\n\n    if (promotionCodes.data.length === 0) {\n      return { valid: false, error: 'Promotion code not found' };\n    }\n\n    const promoCode = promotionCodes.data[0];\n    const coupon = promoCode.coupon as Stripe.Coupon;\n\n    if (!coupon.valid) {\n      return { valid: false, error: 'Coupon is no longer valid' };\n    }\n\n    return {\n      valid: true,\n      promotionCodeId: promoCode.id,\n      couponId: coupon.id,\n      percentOff: coupon.percent_off || undefined,\n      amountOff: coupon.amount_off || undefined,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error instanceof Error ? error.message : 'Validation failed',\n    };\n  }\n}\n","/**\n * Stripe Integration Library\n *\n * Provides payment processing, subscriptions, and billing management\n */\n\nimport Stripe from 'stripe'\nimport { prisma } from '../db'\nimport type {\n  StripeSettings,\n  CreateCheckoutSessionRequest,\n  CreatePaymentIntentRequest,\n  CreateCustomerRequest,\n  CreateSubscriptionRequest,\n  CreateRefundRequest,\n  CheckoutSessionResponse,\n  PaymentIntentResponse,\n  RefundResponse,\n} from './types'\nimport { DEFAULT_STRIPE_SETTINGS } from './types'\n\n// Cache for settings\nlet settingsCache: StripeSettings | null = null\nlet settingsCacheTime = 0\nconst SETTINGS_CACHE_TTL = 60 * 1000 // 1 minute\n\n// Get Stripe client instance\nlet stripeClient: Stripe | null = null\n\nasync function getStripeClient(): Promise<Stripe> {\n  const settings = await getStripeSettings()\n\n  if (!settings.secretKey) {\n    // Fallback to environment variable\n    const envKey = process.env.STRIPE_SECRET_KEY\n    if (!envKey) {\n      throw new Error('Stripe secret key not configured')\n    }\n    if (!stripeClient) {\n      stripeClient = new Stripe(envKey, { apiVersion: '2025-02-24.acacia' })\n    }\n    return stripeClient\n  }\n\n  // Create new client if key changed\n  stripeClient = new Stripe(settings.secretKey, { apiVersion: '2025-02-24.acacia' })\n  return stripeClient\n}\n\n/**\n * Get Stripe settings from database\n */\nexport async function getStripeSettings(): Promise<StripeSettings> {\n  const now = Date.now()\n  if (settingsCache && now - settingsCacheTime < SETTINGS_CACHE_TTL) {\n    return settingsCache\n  }\n\n  const settingRecords = await prisma.setting.findMany({\n    where: {\n      key: { startsWith: 'stripe.' },\n    },\n  })\n\n  const settings: StripeSettings = { ...DEFAULT_STRIPE_SETTINGS }\n\n  for (const record of settingRecords) {\n    const key = record.key.replace('stripe.', '')\n    switch (key) {\n      case 'enabled':\n        settings.enabled = record.value === 'true'\n        break\n      case 'testMode':\n        settings.testMode = record.value === 'true'\n        break\n      case 'secretKey':\n        settings.secretKey = record.value\n        break\n      case 'publishableKey':\n        settings.publishableKey = record.value\n        break\n      case 'webhookSecret':\n        settings.webhookSecret = record.value\n        break\n      case 'currency':\n        settings.currency = record.value\n        break\n      case 'statementDescriptor':\n        settings.statementDescriptor = record.value\n        break\n      case 'supportedPaymentMethods':\n        settings.supportedPaymentMethods = JSON.parse(record.value)\n        break\n      case 'automaticTax':\n        settings.automaticTax = record.value === 'true'\n        break\n      case 'billingAddressCollection':\n        settings.billingAddressCollection = record.value as 'auto' | 'required'\n        break\n    }\n  }\n\n  // Use environment variables as fallback\n  if (!settings.secretKey) {\n    settings.secretKey = process.env.STRIPE_SECRET_KEY\n  }\n  if (!settings.publishableKey) {\n    settings.publishableKey = process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY\n  }\n  if (!settings.webhookSecret) {\n    settings.webhookSecret = process.env.STRIPE_WEBHOOK_SECRET\n  }\n\n  settingsCache = settings\n  settingsCacheTime = now\n\n  return settings\n}\n\n/**\n * Clear settings cache\n */\nexport function clearStripeSettingsCache(): void {\n  settingsCache = null\n  settingsCacheTime = 0\n  stripeClient = null\n}\n\n/**\n * Create a Stripe Checkout Session\n */\nexport async function createCheckoutSession(\n  request: CreateCheckoutSessionRequest\n): Promise<CheckoutSessionResponse> {\n  const stripe = await getStripeClient()\n  const settings = await getStripeSettings()\n\n  const lineItems: Stripe.Checkout.SessionCreateParams.LineItem[] = request.items.map((item) => {\n    // Use existing Stripe price if available\n    if (item.stripePriceId) {\n      return {\n        price: item.stripePriceId,\n        quantity: item.quantity,\n      }\n    }\n\n    // Fall back to inline pricing\n    return {\n      price_data: {\n        currency: settings.currency,\n        product_data: {\n          name: item.name,\n          description: item.description,\n          images: item.images,\n          metadata: item.productId ? { productId: item.productId } : undefined,\n        },\n        unit_amount: item.price,\n      },\n      quantity: item.quantity,\n    }\n  })\n\n  const sessionParams: Stripe.Checkout.SessionCreateParams = {\n    mode: request.mode || 'payment',\n    line_items: lineItems,\n    success_url: request.successUrl,\n    cancel_url: request.cancelUrl,\n    customer_email: request.customerEmail,\n    allow_promotion_codes: request.allowPromotionCodes,\n    billing_address_collection: settings.billingAddressCollection,\n    metadata: {\n      ...request.metadata,\n      orderId: request.orderId || '',\n    },\n  }\n\n  // Add customer if provided\n  if (request.customerId) {\n    sessionParams.customer = request.customerId\n    delete sessionParams.customer_email\n  }\n\n  // Add shipping options\n  if (request.shippingAddressCollection) {\n    sessionParams.shipping_address_collection = {\n      allowed_countries: ['US', 'CA', 'GB', 'AU', 'DE', 'FR'],\n    }\n  }\n\n  if (request.shippingOptions && request.shippingOptions.length > 0) {\n    sessionParams.shipping_options = request.shippingOptions.map((option) => ({\n      shipping_rate_data: {\n        type: 'fixed_amount' as const,\n        fixed_amount: {\n          amount: option.amount,\n          currency: settings.currency,\n        },\n        display_name: option.displayName,\n        delivery_estimate: option.deliveryEstimate,\n      },\n    }))\n  }\n\n  // Enable automatic tax if configured\n  if (settings.automaticTax) {\n    sessionParams.automatic_tax = { enabled: true }\n  }\n\n  // Set payment method types\n  if (settings.supportedPaymentMethods.length > 0) {\n    sessionParams.payment_method_types = settings.supportedPaymentMethods as Stripe.Checkout.SessionCreateParams.PaymentMethodType[]\n  }\n\n  const session = await stripe.checkout.sessions.create(sessionParams)\n\n  return {\n    sessionId: session.id,\n    url: session.url!,\n  }\n}\n\n/**\n * Create a Payment Intent for custom payment flows\n */\nexport async function createPaymentIntent(\n  request: CreatePaymentIntentRequest\n): Promise<PaymentIntentResponse> {\n  const stripe = await getStripeClient()\n  const settings = await getStripeSettings()\n\n  const params: Stripe.PaymentIntentCreateParams = {\n    amount: request.amount,\n    currency: request.currency || settings.currency,\n    capture_method: request.captureMethod || 'automatic',\n    metadata: {\n      ...request.metadata,\n      orderId: request.orderId || '',\n    },\n  }\n\n  if (request.customerId) {\n    params.customer = request.customerId\n  }\n\n  if (request.paymentMethodTypes && request.paymentMethodTypes.length > 0) {\n    params.payment_method_types = request.paymentMethodTypes as string[]\n  } else {\n    params.automatic_payment_methods = { enabled: true }\n  }\n\n  if (settings.statementDescriptor) {\n    params.statement_descriptor = settings.statementDescriptor.substring(0, 22)\n  }\n\n  const paymentIntent = await stripe.paymentIntents.create(params)\n\n  return {\n    paymentIntentId: paymentIntent.id,\n    clientSecret: paymentIntent.client_secret!,\n    status: paymentIntent.status,\n  }\n}\n\n/**\n * Capture a payment intent (for manual capture mode)\n */\nexport async function capturePaymentIntent(\n  paymentIntentId: string,\n  amount?: number\n): Promise<PaymentIntentResponse> {\n  const stripe = await getStripeClient()\n\n  const params: Stripe.PaymentIntentCaptureParams = {}\n  if (amount) {\n    params.amount_to_capture = amount\n  }\n\n  const paymentIntent = await stripe.paymentIntents.capture(paymentIntentId, params)\n\n  return {\n    paymentIntentId: paymentIntent.id,\n    clientSecret: paymentIntent.client_secret!,\n    status: paymentIntent.status,\n  }\n}\n\n/**\n * Cancel a payment intent\n */\nexport async function cancelPaymentIntent(paymentIntentId: string): Promise<void> {\n  const stripe = await getStripeClient()\n  await stripe.paymentIntents.cancel(paymentIntentId)\n}\n\n/**\n * Create or update a Stripe customer\n */\nexport async function createCustomer(request: CreateCustomerRequest): Promise<string> {\n  const stripe = await getStripeClient()\n\n  const params: Stripe.CustomerCreateParams = {\n    email: request.email,\n    name: request.name,\n    phone: request.phone,\n    metadata: request.metadata,\n  }\n\n  if (request.address) {\n    params.address = {\n      line1: request.address.line1,\n      line2: request.address.line2,\n      city: request.address.city,\n      state: request.address.state,\n      postal_code: request.address.postalCode,\n      country: request.address.country,\n    }\n  }\n\n  const customer = await stripe.customers.create(params)\n  return customer.id\n}\n\n/**\n * Get or create a Stripe customer by email\n */\nexport async function getOrCreateCustomer(email: string, name?: string): Promise<string> {\n  const stripe = await getStripeClient()\n\n  // Search for existing customer\n  const customers = await stripe.customers.list({\n    email,\n    limit: 1,\n  })\n\n  if (customers.data.length > 0) {\n    return customers.data[0].id\n  }\n\n  // Create new customer\n  const customer = await stripe.customers.create({\n    email,\n    name,\n  })\n\n  return customer.id\n}\n\n/**\n * Create a subscription\n */\nexport async function createSubscription(\n  request: CreateSubscriptionRequest\n): Promise<{ subscriptionId: string; status: string; clientSecret?: string }> {\n  const stripe = await getStripeClient()\n\n  const params: Stripe.SubscriptionCreateParams = {\n    customer: request.customerId,\n    items: [{ price: request.priceId }],\n    payment_behavior: 'default_incomplete',\n    expand: ['latest_invoice.payment_intent'],\n    metadata: request.metadata,\n  }\n\n  if (request.trialPeriodDays) {\n    params.trial_period_days = request.trialPeriodDays\n  }\n\n  if (request.cancelAtPeriodEnd) {\n    params.cancel_at_period_end = true\n  }\n\n  const subscription = await stripe.subscriptions.create(params)\n\n  // Get client secret for payment\n  const invoice = subscription.latest_invoice as Stripe.Invoice\n  const paymentIntent = invoice?.payment_intent as Stripe.PaymentIntent\n\n  return {\n    subscriptionId: subscription.id,\n    status: subscription.status,\n    clientSecret: paymentIntent?.client_secret || undefined,\n  }\n}\n\n/**\n * Cancel a subscription\n */\nexport async function cancelSubscription(\n  subscriptionId: string,\n  immediately = false\n): Promise<void> {\n  const stripe = await getStripeClient()\n\n  if (immediately) {\n    await stripe.subscriptions.cancel(subscriptionId)\n  } else {\n    await stripe.subscriptions.update(subscriptionId, {\n      cancel_at_period_end: true,\n    })\n  }\n}\n\n/**\n * Create a refund\n */\nexport async function createRefund(request: CreateRefundRequest): Promise<RefundResponse> {\n  const stripe = await getStripeClient()\n\n  const params: Stripe.RefundCreateParams = {\n    payment_intent: request.paymentIntentId,\n    reason: request.reason,\n    metadata: request.metadata,\n  }\n\n  if (request.amount) {\n    params.amount = request.amount\n  }\n\n  const refund = await stripe.refunds.create(params)\n\n  return {\n    refundId: refund.id,\n    status: refund.status!,\n    amount: refund.amount,\n  }\n}\n\n/**\n * Get a checkout session by ID\n */\nexport async function getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session> {\n  const stripe = await getStripeClient()\n  return stripe.checkout.sessions.retrieve(sessionId, {\n    expand: ['line_items', 'customer', 'payment_intent'],\n  })\n}\n\n/**\n * Get a payment intent by ID\n */\nexport async function getPaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {\n  const stripe = await getStripeClient()\n  return stripe.paymentIntents.retrieve(paymentIntentId)\n}\n\n/**\n * Construct and verify a Stripe webhook event\n */\nexport async function constructWebhookEvent(\n  payload: string | Buffer,\n  signature: string\n): Promise<Stripe.Event> {\n  const stripe = await getStripeClient()\n  const settings = await getStripeSettings()\n\n  const webhookSecret = settings.webhookSecret || process.env.STRIPE_WEBHOOK_SECRET\n\n  if (!webhookSecret) {\n    throw new Error('Stripe webhook secret not configured')\n  }\n\n  return stripe.webhooks.constructEvent(payload, signature, webhookSecret)\n}\n\n/**\n * Create a billing portal session for customer self-service\n */\nexport async function createBillingPortalSession(\n  customerId: string,\n  returnUrl: string\n): Promise<string> {\n  const stripe = await getStripeClient()\n\n  const session = await stripe.billingPortal.sessions.create({\n    customer: customerId,\n    return_url: returnUrl,\n  })\n\n  return session.url\n}\n\n/**\n * List customer payment methods\n */\nexport async function listPaymentMethods(\n  customerId: string,\n  type: 'card' | 'us_bank_account' = 'card'\n): Promise<Stripe.PaymentMethod[]> {\n  const stripe = await getStripeClient()\n\n  const paymentMethods = await stripe.paymentMethods.list({\n    customer: customerId,\n    type,\n  })\n\n  return paymentMethods.data\n}\n\n/**\n * Get customer invoices\n */\nexport async function listInvoices(\n  customerId: string,\n  limit = 10\n): Promise<Stripe.Invoice[]> {\n  const stripe = await getStripeClient()\n\n  const invoices = await stripe.invoices.list({\n    customer: customerId,\n    limit,\n  })\n\n  return invoices.data\n}\n\n/**\n * Retrieve product by ID\n */\nexport async function getProduct(productId: string): Promise<Stripe.Product> {\n  const stripe = await getStripeClient()\n  return stripe.products.retrieve(productId)\n}\n\n/**\n * Create a product in Stripe\n */\nexport async function createProduct(\n  name: string,\n  description?: string,\n  images?: string[],\n  metadata?: Record<string, string>\n): Promise<Stripe.Product> {\n  const stripe = await getStripeClient()\n\n  return stripe.products.create({\n    name,\n    description,\n    images,\n    metadata,\n  })\n}\n\n/**\n * Create a price for a product\n */\nexport async function createPrice(\n  productId: string,\n  unitAmount: number,\n  currency?: string,\n  recurring?: { interval: 'day' | 'week' | 'month' | 'year'; interval_count?: number }\n): Promise<Stripe.Price> {\n  const stripe = await getStripeClient()\n  const settings = await getStripeSettings()\n\n  const params: Stripe.PriceCreateParams = {\n    product: productId,\n    unit_amount: unitAmount,\n    currency: currency || settings.currency,\n  }\n\n  if (recurring) {\n    params.recurring = recurring\n  }\n\n  return stripe.prices.create(params)\n}\n\nexport * from './types'\n","/**\n * Stripe Integration Types\n */\n\nimport type Stripe from 'stripe'\n\n// Payment status enum matching Prisma\nexport type PaymentStatus =\n  | 'PENDING'\n  | 'PROCESSING'\n  | 'SUCCEEDED'\n  | 'FAILED'\n  | 'CANCELLED'\n  | 'REFUNDED'\n  | 'PARTIALLY_REFUNDED'\n\n// Checkout session request\nexport interface CreateCheckoutSessionRequest {\n  orderId?: string\n  items: CheckoutItem[]\n  customerEmail?: string\n  customerId?: string\n  successUrl: string\n  cancelUrl: string\n  mode?: 'payment' | 'subscription'\n  allowPromotionCodes?: boolean\n  shippingAddressCollection?: boolean\n  shippingOptions?: ShippingOption[]\n  metadata?: Record<string, string>\n}\n\nexport interface CheckoutItem {\n  name: string\n  description?: string\n  price: number // in cents\n  quantity: number\n  images?: string[]\n  productId?: string\n  variantId?: string\n  stripePriceId?: string // Use existing Stripe price if available\n}\n\nexport interface ShippingOption {\n  id: string\n  displayName: string\n  amount: number // in cents\n  deliveryEstimate?: {\n    minimum: { unit: 'day' | 'week' | 'month'; value: number }\n    maximum: { unit: 'day' | 'week' | 'month'; value: number }\n  }\n}\n\n// Payment intent request\nexport interface CreatePaymentIntentRequest {\n  amount: number // in cents\n  currency?: string\n  customerId?: string\n  customerEmail?: string\n  orderId?: string\n  metadata?: Record<string, string>\n  paymentMethodTypes?: string[]\n  captureMethod?: 'automatic' | 'manual'\n}\n\n// Customer management\nexport interface CreateCustomerRequest {\n  email: string\n  name?: string\n  phone?: string\n  address?: {\n    line1: string\n    line2?: string\n    city: string\n    state: string\n    postalCode: string\n    country: string\n  }\n  metadata?: Record<string, string>\n}\n\n// Subscription management\nexport interface CreateSubscriptionRequest {\n  customerId: string\n  priceId: string\n  trialPeriodDays?: number\n  metadata?: Record<string, string>\n  cancelAtPeriodEnd?: boolean\n}\n\n// Refund request\nexport interface CreateRefundRequest {\n  paymentIntentId: string\n  amount?: number // partial refund in cents, full if not specified\n  reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer'\n  metadata?: Record<string, string>\n}\n\n// Webhook event types we handle\nexport type StripeWebhookEventType =\n  | 'checkout.session.completed'\n  | 'checkout.session.expired'\n  | 'payment_intent.succeeded'\n  | 'payment_intent.payment_failed'\n  | 'payment_intent.canceled'\n  | 'charge.refunded'\n  | 'charge.dispute.created'\n  | 'customer.subscription.created'\n  | 'customer.subscription.updated'\n  | 'customer.subscription.deleted'\n  | 'invoice.paid'\n  | 'invoice.payment_failed'\n\n// Stripe settings stored in database\nexport interface StripeSettings {\n  enabled: boolean\n  testMode: boolean\n  secretKey?: string\n  publishableKey?: string\n  webhookSecret?: string\n  currency: string\n  statementDescriptor?: string\n  supportedPaymentMethods: string[]\n  automaticTax: boolean\n  billingAddressCollection: 'auto' | 'required'\n}\n\n// Default Stripe settings\nexport const DEFAULT_STRIPE_SETTINGS: StripeSettings = {\n  enabled: false,\n  testMode: true,\n  currency: 'usd',\n  supportedPaymentMethods: ['card'],\n  automaticTax: false,\n  billingAddressCollection: 'auto',\n}\n\n// Supported currencies\nexport const SUPPORTED_CURRENCIES = [\n  { value: 'usd', label: 'USD - US Dollar' },\n  { value: 'eur', label: 'EUR - Euro' },\n  { value: 'gbp', label: 'GBP - British Pound' },\n  { value: 'cad', label: 'CAD - Canadian Dollar' },\n  { value: 'aud', label: 'AUD - Australian Dollar' },\n  { value: 'jpy', label: 'JPY - Japanese Yen' },\n  { value: 'inr', label: 'INR - Indian Rupee' },\n] as const\n\n// Payment method options\nexport const PAYMENT_METHOD_OPTIONS = [\n  { value: 'card', label: 'Credit/Debit Card' },\n  { value: 'us_bank_account', label: 'ACH Bank Transfer' },\n  { value: 'sepa_debit', label: 'SEPA Direct Debit' },\n  { value: 'klarna', label: 'Klarna' },\n  { value: 'afterpay_clearpay', label: 'Afterpay / Clearpay' },\n  { value: 'affirm', label: 'Affirm' },\n  { value: 'link', label: 'Link' },\n] as const\n\n// Response types\nexport interface CheckoutSessionResponse {\n  sessionId: string\n  url: string\n}\n\nexport interface PaymentIntentResponse {\n  paymentIntentId: string\n  clientSecret: string\n  status: string\n}\n\nexport interface RefundResponse {\n  refundId: string\n  status: string\n  amount: number\n}\n\n// Utility type for Stripe event data\nexport type StripeEventData = Stripe.Event['data']['object']\n","/**\n * Form Builder Types\n */\n\n// Field types supported by the form builder\nexport type FormFieldType =\n  | 'text'\n  | 'email'\n  | 'phone'\n  | 'number'\n  | 'textarea'\n  | 'select'\n  | 'multiselect'\n  | 'checkbox'\n  | 'radio'\n  | 'date'\n  | 'time'\n  | 'datetime'\n  | 'file'\n  | 'url'\n  | 'hidden'\n  | 'rating'\n  | 'range'\n\n// Validation rule types\nexport type ValidationRuleType =\n  | 'required'\n  | 'minLength'\n  | 'maxLength'\n  | 'min'\n  | 'max'\n  | 'pattern'\n  | 'email'\n  | 'url'\n  | 'custom'\n\n// Validation rule\nexport interface ValidationRule {\n  type: ValidationRuleType\n  value?: string | number\n  message: string\n}\n\n// Select/Radio option\nexport interface FieldOption {\n  value: string\n  label: string\n}\n\n// Conditional logic\nexport interface FieldCondition {\n  field: string // Field name to check\n  operator: 'equals' | 'notEquals' | 'contains' | 'notContains' | 'isEmpty' | 'isNotEmpty'\n  value?: string | number | boolean\n}\n\n// Form field definition\nexport interface FormField {\n  id: string\n  name: string\n  type: FormFieldType\n  label: string\n  placeholder?: string\n  description?: string\n  defaultValue?: string | number | boolean | string[]\n  options?: FieldOption[] // For select, multiselect, radio\n  validation?: ValidationRule[]\n  conditions?: FieldCondition[] // Show field only if conditions are met\n  width?: 'full' | 'half' | 'third' // Grid width\n  rows?: number // For textarea\n  accept?: string // For file upload\n  min?: number // For number, range\n  max?: number // For number, range\n  step?: number // For number, range\n}\n\n// Form definition\nexport interface FormDefinition {\n  id: string\n  name: string\n  slug: string\n  description?: string\n  fields: FormField[]\n  settings: FormSettings\n  createdAt: string\n  updatedAt: string\n}\n\n// Form settings\nexport interface FormSettings {\n  submitButtonText: string\n  successMessage: string\n  redirectUrl?: string\n  notifyEmails: string[]\n  captchaEnabled: boolean\n  storeSubmissions: boolean\n  limitSubmissions?: number\n  closeAfterDate?: string\n}\n\n// Form submission data\nexport interface FormSubmissionData {\n  formId: string\n  data: Record<string, any>\n  metadata?: {\n    ipAddress?: string\n    userAgent?: string\n    referrer?: string\n    timestamp: string\n  }\n}\n\n// Submission response\nexport interface FormSubmissionResponse {\n  success: boolean\n  message: string\n  submissionId?: string\n  redirectUrl?: string\n  errors?: Record<string, string>\n}\n\n// Default field templates\nexport const FIELD_TEMPLATES: Record<string, Partial<FormField>> = {\n  name: {\n    type: 'text',\n    label: 'Name',\n    placeholder: 'Enter your name',\n    validation: [{ type: 'required', message: 'Name is required' }],\n  },\n  email: {\n    type: 'email',\n    label: 'Email',\n    placeholder: 'Enter your email',\n    validation: [\n      { type: 'required', message: 'Email is required' },\n      { type: 'email', message: 'Please enter a valid email' },\n    ],\n  },\n  phone: {\n    type: 'phone',\n    label: 'Phone',\n    placeholder: 'Enter your phone number',\n  },\n  message: {\n    type: 'textarea',\n    label: 'Message',\n    placeholder: 'Enter your message',\n    rows: 4,\n    validation: [{ type: 'required', message: 'Message is required' }],\n  },\n  company: {\n    type: 'text',\n    label: 'Company',\n    placeholder: 'Enter your company name',\n  },\n  website: {\n    type: 'url',\n    label: 'Website',\n    placeholder: 'https://example.com',\n    validation: [{ type: 'url', message: 'Please enter a valid URL' }],\n  },\n  subscribe: {\n    type: 'checkbox',\n    label: 'Subscribe to newsletter',\n    defaultValue: false,\n  },\n}\n\n// Default form settings\nexport const DEFAULT_FORM_SETTINGS: FormSettings = {\n  submitButtonText: 'Submit',\n  successMessage: 'Thank you for your submission!',\n  notifyEmails: [],\n  captchaEnabled: false,\n  storeSubmissions: true,\n}\n","/**\n * Form Builder Library\n *\n * Provides form creation, validation, and submission handling\n */\n\nimport { prisma } from '../db'\nimport type {\n  FormField,\n  FormDefinition,\n  FormSettings,\n  ValidationRule,\n  FieldCondition,\n  FormSubmissionData,\n  FormSubmissionResponse,\n} from './types'\nimport { DEFAULT_FORM_SETTINGS } from './types'\n\n/**\n * Create a new form\n */\nexport async function createForm(\n  name: string,\n  fields: FormField[],\n  settings?: Partial<FormSettings>\n): Promise<FormDefinition> {\n  const slug = name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/(^-|-$)/g, '')\n\n  const form = await prisma.form.create({\n    data: {\n      name,\n      slug,\n      fields: fields as any,\n      submitButtonText: settings?.submitButtonText || DEFAULT_FORM_SETTINGS.submitButtonText,\n      successMessage: settings?.successMessage || DEFAULT_FORM_SETTINGS.successMessage,\n      redirectUrl: settings?.redirectUrl,\n      notifyEmails: settings?.notifyEmails || [],\n      status: 'ACTIVE',\n    },\n  })\n\n  return {\n    id: form.id,\n    name: form.name,\n    slug: form.slug,\n    description: form.description || undefined,\n    fields: form.fields as unknown as FormField[],\n    settings: {\n      submitButtonText: form.submitButtonText,\n      successMessage: form.successMessage || DEFAULT_FORM_SETTINGS.successMessage,\n      redirectUrl: form.redirectUrl || undefined,\n      notifyEmails: form.notifyEmails,\n      captchaEnabled: false,\n      storeSubmissions: true,\n    },\n    createdAt: form.createdAt.toISOString(),\n    updatedAt: form.updatedAt.toISOString(),\n  }\n}\n\n/**\n * Get form by ID or slug\n */\nexport async function getForm(idOrSlug: string): Promise<FormDefinition | null> {\n  const form = await prisma.form.findFirst({\n    where: {\n      OR: [{ id: idOrSlug }, { slug: idOrSlug }],\n    },\n  })\n\n  if (!form) return null\n\n  return {\n    id: form.id,\n    name: form.name,\n    slug: form.slug,\n    description: form.description || undefined,\n    fields: form.fields as unknown as FormField[],\n    settings: {\n      submitButtonText: form.submitButtonText,\n      successMessage: form.successMessage || DEFAULT_FORM_SETTINGS.successMessage,\n      redirectUrl: form.redirectUrl || undefined,\n      notifyEmails: form.notifyEmails,\n      captchaEnabled: false,\n      storeSubmissions: true,\n    },\n    createdAt: form.createdAt.toISOString(),\n    updatedAt: form.updatedAt.toISOString(),\n  }\n}\n\n/**\n * Update a form\n */\nexport async function updateForm(\n  id: string,\n  data: {\n    name?: string\n    description?: string\n    fields?: FormField[]\n    settings?: Partial<FormSettings>\n    status?: 'DRAFT' | 'ACTIVE' | 'ARCHIVED'\n  }\n): Promise<FormDefinition> {\n  const updateData: any = {}\n\n  if (data.name) updateData.name = data.name\n  if (data.description !== undefined) updateData.description = data.description\n  if (data.fields) updateData.fields = data.fields\n  if (data.status) updateData.status = data.status\n  if (data.settings) {\n    if (data.settings.submitButtonText) updateData.submitButtonText = data.settings.submitButtonText\n    if (data.settings.successMessage) updateData.successMessage = data.settings.successMessage\n    if (data.settings.redirectUrl !== undefined) updateData.redirectUrl = data.settings.redirectUrl\n    if (data.settings.notifyEmails) updateData.notifyEmails = data.settings.notifyEmails\n  }\n\n  const form = await prisma.form.update({\n    where: { id },\n    data: updateData,\n  })\n\n  return {\n    id: form.id,\n    name: form.name,\n    slug: form.slug,\n    description: form.description || undefined,\n    fields: form.fields as unknown as FormField[],\n    settings: {\n      submitButtonText: form.submitButtonText,\n      successMessage: form.successMessage || DEFAULT_FORM_SETTINGS.successMessage,\n      redirectUrl: form.redirectUrl || undefined,\n      notifyEmails: form.notifyEmails,\n      captchaEnabled: false,\n      storeSubmissions: true,\n    },\n    createdAt: form.createdAt.toISOString(),\n    updatedAt: form.updatedAt.toISOString(),\n  }\n}\n\n/**\n * Delete a form\n */\nexport async function deleteForm(id: string): Promise<void> {\n  await prisma.form.delete({ where: { id } })\n}\n\n/**\n * Validate form data against field definitions\n */\nexport function validateFormData(\n  fields: FormField[],\n  data: Record<string, any>\n): { valid: boolean; errors: Record<string, string> } {\n  const errors: Record<string, string> = {}\n\n  for (const field of fields) {\n    const value = data[field.name]\n\n    // Check conditions - skip validation if field shouldn't be shown\n    if (field.conditions && field.conditions.length > 0) {\n      const shouldShow = field.conditions.every((condition) =>\n        evaluateCondition(condition, data)\n      )\n      if (!shouldShow) continue\n    }\n\n    // Validate each rule\n    if (field.validation) {\n      for (const rule of field.validation) {\n        const error = validateRule(rule, value, field)\n        if (error) {\n          errors[field.name] = error\n          break // Only show first error per field\n        }\n      }\n    }\n  }\n\n  return {\n    valid: Object.keys(errors).length === 0,\n    errors,\n  }\n}\n\n/**\n * Evaluate a field condition\n */\nfunction evaluateCondition(\n  condition: FieldCondition,\n  data: Record<string, any>\n): boolean {\n  const value = data[condition.field]\n\n  switch (condition.operator) {\n    case 'equals':\n      return value === condition.value\n    case 'notEquals':\n      return value !== condition.value\n    case 'contains':\n      return String(value || '').includes(String(condition.value))\n    case 'notContains':\n      return !String(value || '').includes(String(condition.value))\n    case 'isEmpty':\n      return value === undefined || value === null || value === ''\n    case 'isNotEmpty':\n      return value !== undefined && value !== null && value !== ''\n    default:\n      return true\n  }\n}\n\n/**\n * Validate a single rule\n */\nfunction validateRule(\n  rule: ValidationRule,\n  value: any,\n  field: FormField\n): string | null {\n  switch (rule.type) {\n    case 'required':\n      if (value === undefined || value === null || value === '' ||\n          (Array.isArray(value) && value.length === 0)) {\n        return rule.message\n      }\n      break\n\n    case 'minLength':\n      if (typeof value === 'string' && value.length < (rule.value as number)) {\n        return rule.message\n      }\n      break\n\n    case 'maxLength':\n      if (typeof value === 'string' && value.length > (rule.value as number)) {\n        return rule.message\n      }\n      break\n\n    case 'min':\n      if (typeof value === 'number' && value < (rule.value as number)) {\n        return rule.message\n      }\n      break\n\n    case 'max':\n      if (typeof value === 'number' && value > (rule.value as number)) {\n        return rule.message\n      }\n      break\n\n    case 'pattern':\n      if (value && !new RegExp(rule.value as string).test(String(value))) {\n        return rule.message\n      }\n      break\n\n    case 'email':\n      if (value && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(String(value))) {\n        return rule.message\n      }\n      break\n\n    case 'url':\n      if (value) {\n        try {\n          new URL(String(value))\n        } catch {\n          return rule.message\n        }\n      }\n      break\n  }\n\n  return null\n}\n\n/**\n * Submit form data\n */\nexport async function submitForm(\n  submission: FormSubmissionData\n): Promise<FormSubmissionResponse> {\n  const form = await getForm(submission.formId)\n\n  if (!form) {\n    return {\n      success: false,\n      message: 'Form not found',\n    }\n  }\n\n  // Validate data\n  const validation = validateFormData(form.fields, submission.data)\n\n  if (!validation.valid) {\n    return {\n      success: false,\n      message: 'Validation failed',\n      errors: validation.errors,\n    }\n  }\n\n  // Store submission\n  const formSubmission = await prisma.formSubmission.create({\n    data: {\n      formId: form.id,\n      data: submission.data,\n      ipAddress: submission.metadata?.ipAddress,\n      userAgent: submission.metadata?.userAgent,\n      referrer: submission.metadata?.referrer,\n    },\n  })\n\n  // Update submission count\n  await prisma.form.update({\n    where: { id: form.id },\n    data: { submissionCount: { increment: 1 } },\n  })\n\n  // TODO: Send notification emails if configured\n  // This would integrate with your email service\n\n  return {\n    success: true,\n    message: form.settings.successMessage,\n    submissionId: formSubmission.id,\n    redirectUrl: form.settings.redirectUrl,\n  }\n}\n\n/**\n * Get form submissions\n */\nexport async function getFormSubmissions(\n  formId: string,\n  options?: {\n    limit?: number\n    offset?: number\n    starred?: boolean\n    read?: boolean\n  }\n): Promise<{\n  submissions: Array<{\n    id: string\n    data: Record<string, any>\n    createdAt: string\n    read: boolean\n    starred: boolean\n  }>\n  total: number\n}> {\n  const where: any = { formId }\n\n  if (options?.starred !== undefined) {\n    where.starred = options.starred\n  }\n  if (options?.read !== undefined) {\n    where.read = options.read\n  }\n\n  const [submissions, total] = await Promise.all([\n    prisma.formSubmission.findMany({\n      where,\n      take: options?.limit || 50,\n      skip: options?.offset || 0,\n      orderBy: { createdAt: 'desc' },\n    }),\n    prisma.formSubmission.count({ where }),\n  ])\n\n  return {\n    submissions: submissions.map((s: (typeof submissions)[number]) => ({\n      id: s.id,\n      data: s.data as Record<string, any>,\n      createdAt: s.createdAt.toISOString(),\n      read: s.read,\n      starred: s.starred,\n    })),\n    total,\n  }\n}\n\n/**\n * Mark submission as read\n */\nexport async function markSubmissionRead(\n  submissionId: string,\n  read = true\n): Promise<void> {\n  await prisma.formSubmission.update({\n    where: { id: submissionId },\n    data: { read },\n  })\n}\n\n/**\n * Star/unstar submission\n */\nexport async function starSubmission(\n  submissionId: string,\n  starred = true\n): Promise<void> {\n  await prisma.formSubmission.update({\n    where: { id: submissionId },\n    data: { starred },\n  })\n}\n\n/**\n * Delete submission\n */\nexport async function deleteSubmission(submissionId: string): Promise<void> {\n  await prisma.formSubmission.delete({\n    where: { id: submissionId },\n  })\n}\n\nexport * from './types'\n","/**\n * Inventory Management Service\n *\n * Handles stock alerts, back-in-stock subscriptions, and stock reservations\n */\n\nimport { prisma } from '../db';\nimport { sendEmail } from '../email';\nimport { getEmailSettings } from '../settings';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface LowStockProduct {\n  id: string;\n  title: string;\n  sku: string | null;\n  stock: number;\n  lowStockThreshold: number;\n  variantId?: string;\n  variantTitle?: string;\n}\n\nexport interface StockReservationResult {\n  success: boolean;\n  reservationId?: string;\n  error?: string;\n}\n\n// =============================================================================\n// Low Stock Detection\n// =============================================================================\n\n/**\n * Find all products and variants below their low stock threshold\n */\nexport async function getLowStockItems(): Promise<LowStockProduct[]> {\n  const lowStockItems: LowStockProduct[] = [];\n\n  // Check simple products (non-variant)\n  const lowStockProducts = await prisma.product.findMany({\n    where: {\n      status: 'ACTIVE',\n      trackInventory: true,\n      type: 'SIMPLE',\n      stock: {\n        lte: prisma.product.fields.lowStockThreshold,\n      },\n    },\n    select: {\n      id: true,\n      title: true,\n      sku: true,\n      stock: true,\n      lowStockThreshold: true,\n    },\n  });\n\n  for (const product of lowStockProducts) {\n    if (product.stock <= product.lowStockThreshold) {\n      lowStockItems.push({\n        id: product.id,\n        title: product.title,\n        sku: product.sku,\n        stock: product.stock,\n        lowStockThreshold: product.lowStockThreshold,\n      });\n    }\n  }\n\n  // Check product variants\n  const lowStockVariants = await prisma.productVariant.findMany({\n    where: {\n      enabled: true,\n      product: {\n        status: 'ACTIVE',\n        trackInventory: true,\n      },\n    },\n    include: {\n      product: {\n        select: {\n          id: true,\n          title: true,\n        },\n      },\n      optionValues: {\n        include: {\n          optionValue: true,\n        },\n      },\n    },\n  });\n\n  for (const variant of lowStockVariants) {\n    if (variant.stock <= variant.lowStockThreshold) {\n      // Construct variant title from option values\n      const variantTitle = variant.optionValues\n        .map((ov) => ov.optionValue.value)\n        .join(' / ') || undefined;\n\n      lowStockItems.push({\n        id: variant.product.id,\n        title: variant.product.title,\n        sku: variant.sku,\n        stock: variant.stock,\n        lowStockThreshold: variant.lowStockThreshold,\n        variantId: variant.id,\n        variantTitle,\n      });\n    }\n  }\n\n  return lowStockItems;\n}\n\n/**\n * Send low stock alert email to admin\n */\nexport async function sendLowStockAlert(items: LowStockProduct[]): Promise<{ success: boolean; error?: string }> {\n  if (items.length === 0) {\n    return { success: true };\n  }\n\n  const emailSettings = await getEmailSettings();\n  const adminEmail = emailSettings.replyTo || emailSettings.fromEmail;\n\n  if (!adminEmail) {\n    return { success: false, error: 'No admin email configured' };\n  }\n\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\n\n  // Build email content\n  const itemRows = items\n    .map((item) => {\n      const name = item.variantTitle ? `${item.title} - ${item.variantTitle}` : item.title;\n      const sku = item.sku ? ` (SKU: ${item.sku})` : '';\n      return ` ${name}${sku}: ${item.stock} remaining (threshold: ${item.lowStockThreshold})`;\n    })\n    .join('\\n');\n\n  const html = `\n    <h2>Low Stock Alert</h2>\n    <p>The following products are at or below their low stock threshold:</p>\n    <ul>\n      ${items\n        .map((item) => {\n          const name = item.variantTitle ? `${item.title} - ${item.variantTitle}` : item.title;\n          const sku = item.sku ? ` (SKU: ${item.sku})` : '';\n          return `<li><strong>${name}</strong>${sku}: ${item.stock} remaining (threshold: ${item.lowStockThreshold})</li>`;\n        })\n        .join('')}\n    </ul>\n    <p><a href=\"${appUrl}/admin/products\">View Products in Admin</a></p>\n  `;\n\n  const text = `Low Stock Alert\n\nThe following products are at or below their low stock threshold:\n\n${itemRows}\n\nView products: ${appUrl}/admin/products`;\n\n  try {\n    const result = await sendEmail({\n      to: { email: adminEmail, name: 'Store Admin' },\n      subject: `Low Stock Alert: ${items.length} product${items.length > 1 ? 's' : ''} need attention`,\n      html,\n      text,\n      metadata: {\n        type: 'low_stock_alert',\n        itemCount: String(items.length),\n      },\n    });\n\n    return { success: result.success, error: result.error };\n  } catch (error) {\n    console.error('Error sending low stock alert:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n// =============================================================================\n// Back-In-Stock Subscriptions\n// =============================================================================\n\n/**\n * Subscribe an email to back-in-stock notifications for a product\n */\nexport async function subscribeToBackInStock(\n  email: string,\n  productId: string,\n  variantId?: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Verify product exists\n    const product = await prisma.product.findUnique({\n      where: { id: productId },\n      select: { id: true, status: true },\n    });\n\n    if (!product) {\n      return { success: false, error: 'Product not found' };\n    }\n\n    // Verify variant exists if provided\n    if (variantId) {\n      const variant = await prisma.productVariant.findUnique({\n        where: { id: variantId },\n        select: { id: true },\n      });\n      if (!variant) {\n        return { success: false, error: 'Variant not found' };\n      }\n    }\n\n    // Check for existing subscription\n    const existing = await prisma.backInStockSubscription.findFirst({\n      where: {\n        email,\n        productId,\n        variantId: variantId ?? null,\n      },\n    });\n\n    if (existing) {\n      // Update existing subscription\n      await prisma.backInStockSubscription.update({\n        where: { id: existing.id },\n        data: {\n          notified: false,\n          notifiedAt: null,\n        },\n      });\n    } else {\n      // Create new subscription\n      await prisma.backInStockSubscription.create({\n        data: {\n          email,\n          productId,\n          variantId: variantId ?? null,\n        },\n      });\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error('Error subscribing to back-in-stock:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Unsubscribe from back-in-stock notifications\n */\nexport async function unsubscribeFromBackInStock(\n  email: string,\n  productId: string,\n  variantId?: string\n): Promise<{ success: boolean }> {\n  try {\n    await prisma.backInStockSubscription.deleteMany({\n      where: {\n        email,\n        productId,\n        variantId: variantId || null,\n      },\n    });\n    return { success: true };\n  } catch {\n    return { success: false };\n  }\n}\n\n/**\n * Send back-in-stock notifications for a product that's now in stock\n */\nexport async function sendBackInStockNotifications(\n  productId: string,\n  variantId?: string\n): Promise<{ sent: number; errors: number }> {\n  const subscriptions = await prisma.backInStockSubscription.findMany({\n    where: {\n      productId,\n      variantId: variantId || null,\n      notified: false,\n    },\n    include: {\n      product: {\n        select: {\n          title: true,\n          slug: true,\n          images: {\n            select: {\n              media: {\n                select: {\n                  url: true,\n                },\n              },\n            },\n            take: 1,\n            orderBy: { position: 'asc' },\n          },\n        },\n      },\n      variant: {\n        include: {\n          optionValues: {\n            include: {\n              optionValue: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (subscriptions.length === 0) {\n    return { sent: 0, errors: 0 };\n  }\n\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\n  let sent = 0;\n  let errors = 0;\n\n  for (const sub of subscriptions) {\n    // Construct variant title from option values\n    const variantTitle = sub.variant?.optionValues\n      .map((ov) => ov.optionValue.value)\n      .join(' / ');\n    const productName = variantTitle\n      ? `${sub.product.title} - ${variantTitle}`\n      : sub.product.title;\n    const productUrl = `${appUrl}/products/${sub.product.slug}`;\n    const imageUrl = sub.product.images?.[0]?.media?.url || '';\n\n    const html = `\n      <h2>Good News! ${productName} is Back in Stock</h2>\n      ${imageUrl ? `<img src=\"${imageUrl}\" alt=\"${productName}\" style=\"max-width: 200px; margin: 20px 0;\" />` : ''}\n      <p>The product you were waiting for is now available.</p>\n      <p><a href=\"${productUrl}\" style=\"display: inline-block; padding: 12px 24px; background-color: #000; color: #fff; text-decoration: none; border-radius: 4px;\">Shop Now</a></p>\n      <p style=\"color: #666; font-size: 12px; margin-top: 20px;\">\n        You received this email because you signed up for a back-in-stock notification.\n      </p>\n    `;\n\n    const text = `Good News! ${productName} is Back in Stock\n\nThe product you were waiting for is now available.\n\nShop now: ${productUrl}\n\nYou received this email because you signed up for a back-in-stock notification.`;\n\n    try {\n      const result = await sendEmail({\n        to: { email: sub.email },\n        subject: `${productName} is Back in Stock!`,\n        html,\n        text,\n        metadata: {\n          type: 'back_in_stock',\n          productId: sub.productId,\n          ...(sub.variantId ? { variantId: sub.variantId } : {}),\n        },\n      });\n\n      if (result.success) {\n        // Mark as notified\n        await prisma.backInStockSubscription.update({\n          where: { id: sub.id },\n          data: {\n            notified: true,\n            notifiedAt: new Date(),\n          },\n        });\n        sent++;\n      } else {\n        errors++;\n      }\n    } catch {\n      errors++;\n    }\n  }\n\n  return { sent, errors };\n}\n\n/**\n * Check if a product is back in stock and send notifications\n * Call this when updating stock levels\n */\nexport async function checkAndNotifyBackInStock(\n  productId: string,\n  variantId: string | undefined,\n  newStock: number\n): Promise<void> {\n  if (newStock <= 0) return;\n\n  // Check if there are subscribers waiting\n  const subCount = await prisma.backInStockSubscription.count({\n    where: {\n      productId,\n      variantId: variantId || null,\n      notified: false,\n    },\n  });\n\n  if (subCount > 0) {\n    // Send notifications in the background\n    sendBackInStockNotifications(productId, variantId).catch((err) => {\n      console.error('Error sending back-in-stock notifications:', err);\n    });\n  }\n}\n\n// =============================================================================\n// Stock Reservation\n// =============================================================================\n\nconst DEFAULT_RESERVATION_MINUTES = 15;\n\n/**\n * Reserve stock for a checkout session\n */\nexport async function reserveStock(\n  productId: string,\n  quantity: number,\n  sessionId: string,\n  variantId?: string,\n  reservationMinutes: number = DEFAULT_RESERVATION_MINUTES\n): Promise<StockReservationResult> {\n  try {\n    // Get current stock\n    let currentStock: number;\n    let trackInventory: boolean;\n\n    if (variantId) {\n      const variant = await prisma.productVariant.findUnique({\n        where: { id: variantId },\n        include: {\n          product: {\n            select: { trackInventory: true },\n          },\n        },\n      });\n      if (!variant) {\n        return { success: false, error: 'Variant not found' };\n      }\n      currentStock = variant.stock;\n      trackInventory = variant.product.trackInventory;\n    } else {\n      const product = await prisma.product.findUnique({\n        where: { id: productId },\n        select: { stock: true, trackInventory: true },\n      });\n      if (!product) {\n        return { success: false, error: 'Product not found' };\n      }\n      currentStock = product.stock;\n      trackInventory = product.trackInventory;\n    }\n\n    // If not tracking inventory, always succeed\n    if (!trackInventory) {\n      return { success: true };\n    }\n\n    // Calculate available stock (current - active reservations)\n    const reservedStock = await prisma.stockReservation.aggregate({\n      where: {\n        productId,\n        variantId: variantId || null,\n        released: false,\n        expiresAt: { gt: new Date() },\n      },\n      _sum: { quantity: true },\n    });\n\n    const availableStock = currentStock - (reservedStock._sum.quantity || 0);\n\n    if (availableStock < quantity) {\n      return { success: false, error: 'Insufficient stock' };\n    }\n\n    // Create reservation\n    const expiresAt = new Date(Date.now() + reservationMinutes * 60 * 1000);\n\n    const reservation = await prisma.stockReservation.create({\n      data: {\n        productId,\n        variantId: variantId || null,\n        quantity,\n        sessionId,\n        expiresAt,\n      },\n    });\n\n    return { success: true, reservationId: reservation.id };\n  } catch (error) {\n    console.error('Error reserving stock:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Release a stock reservation (cart cleared, session expired, etc.)\n */\nexport async function releaseReservation(reservationId: string): Promise<boolean> {\n  try {\n    await prisma.stockReservation.update({\n      where: { id: reservationId },\n      data: { released: true },\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Release all reservations for a session\n */\nexport async function releaseSessionReservations(sessionId: string): Promise<number> {\n  const result = await prisma.stockReservation.updateMany({\n    where: {\n      sessionId,\n      released: false,\n    },\n    data: { released: true },\n  });\n  return result.count;\n}\n\n/**\n * Convert reservations to order (when order is created)\n * Links reservations to order and makes them permanent\n */\nexport async function convertReservationsToOrder(sessionId: string, orderId: string): Promise<number> {\n  const result = await prisma.stockReservation.updateMany({\n    where: {\n      sessionId,\n      released: false,\n      expiresAt: { gt: new Date() },\n    },\n    data: {\n      orderId,\n      // Extend expiration significantly - these are now order reservations\n      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n    },\n  });\n  return result.count;\n}\n\n/**\n * Deduct stock when order is confirmed/paid\n * Releases reservations after deducting actual stock\n */\nexport async function deductStockForOrder(orderId: string): Promise<{ success: boolean; error?: string }> {\n  try {\n    const reservations = await prisma.stockReservation.findMany({\n      where: {\n        orderId,\n        released: false,\n      },\n    });\n\n    for (const reservation of reservations) {\n      if (reservation.variantId) {\n        await prisma.productVariant.update({\n          where: { id: reservation.variantId },\n          data: {\n            stock: { decrement: reservation.quantity },\n          },\n        });\n      } else {\n        await prisma.product.update({\n          where: { id: reservation.productId },\n          data: {\n            stock: { decrement: reservation.quantity },\n          },\n        });\n      }\n\n      // Mark reservation as released (stock has been deducted)\n      await prisma.stockReservation.update({\n        where: { id: reservation.id },\n        data: { released: true },\n      });\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error('Error deducting stock for order:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Cleanup expired reservations\n * Run this periodically (e.g., every 5 minutes)\n */\nexport async function cleanupExpiredReservations(): Promise<number> {\n  const result = await prisma.stockReservation.updateMany({\n    where: {\n      released: false,\n      expiresAt: { lte: new Date() },\n      orderId: null, // Only cleanup session reservations, not order reservations\n    },\n    data: { released: true },\n  });\n  return result.count;\n}\n\n/**\n * Get available stock for a product (accounting for reservations)\n */\nexport async function getAvailableStock(productId: string, variantId?: string): Promise<number> {\n  let currentStock: number;\n  let trackInventory: boolean;\n\n  if (variantId) {\n    const variant = await prisma.productVariant.findUnique({\n      where: { id: variantId },\n      include: {\n        product: { select: { trackInventory: true } },\n      },\n    });\n    if (!variant) return 0;\n    currentStock = variant.stock;\n    trackInventory = variant.product.trackInventory;\n  } else {\n    const product = await prisma.product.findUnique({\n      where: { id: productId },\n      select: { stock: true, trackInventory: true },\n    });\n    if (!product) return 0;\n    currentStock = product.stock;\n    trackInventory = product.trackInventory;\n  }\n\n  // If not tracking inventory, return max int (unlimited)\n  if (!trackInventory) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n\n  // Subtract active reservations\n  const reserved = await prisma.stockReservation.aggregate({\n    where: {\n      productId,\n      variantId: variantId || null,\n      released: false,\n      expiresAt: { gt: new Date() },\n    },\n    _sum: { quantity: true },\n  });\n\n  return Math.max(0, currentStock - (reserved._sum.quantity || 0));\n}\n","/**\n * Media Library - Core CRUD Operations\n */\n\nimport { prisma } from '../db'\nimport type {\n  MediaFilters,\n  MediaWithRelations,\n  MediaListResponse,\n  MediaCreateInput,\n  MediaUpdateInput,\n} from './types'\n\n// Type augmentation for Prisma client with extended Media model\n// This allows the code to compile before prisma generate is run with new schema\ntype PrismaWithMedia = typeof prisma & {\n  media: {\n    findMany: (args: any) => Promise<any[]>\n    findUnique: (args: any) => Promise<any | null>\n    create: (args: any) => Promise<any>\n    update: (args: any) => Promise<any>\n    delete: (args: any) => Promise<any>\n    updateMany: (args: any) => Promise<{ count: number }>\n    deleteMany: (args: any) => Promise<{ count: number }>\n    count: (args: any) => Promise<number>\n    groupBy: (args: any) => Promise<any[]>\n    aggregate: (args: any) => Promise<any>\n  }\n  mediaTagOnMedia: {\n    createMany: (args: any) => Promise<{ count: number }>\n    deleteMany: (args: any) => Promise<{ count: number }>\n  }\n}\n\nconst db = prisma as PrismaWithMedia\n\n// Type for media where input\ninterface MediaWhereInput {\n  id?: { in: string[] }\n  deletedAt?: null | Date | { gte?: Date }\n  folderId?: string | null\n  mimeType?: { startsWith?: string; contains?: string } | string\n  OR?: any[]\n  tags?: { some: { tagId: { in: string[] } } }\n  createdAt?: { gte?: Date }\n}\n\n// Type for media order by\ninterface MediaOrderByInput {\n  originalName?: 'asc' | 'desc'\n  size?: 'asc' | 'desc'\n  mimeType?: 'asc' | 'desc'\n  createdAt?: 'asc' | 'desc'\n}\n\n// =============================================================================\n// LIST MEDIA\n// =============================================================================\n\nexport async function listMedia(filters: MediaFilters = {}): Promise<MediaListResponse> {\n  const {\n    folderId,\n    type,\n    search,\n    tagIds,\n    includeDeleted = false,\n    page = 1,\n    limit = 50,\n    sortBy = 'createdAt',\n    sortOrder = 'desc',\n  } = filters\n\n  const where: MediaWhereInput = {}\n\n  // Soft delete filter\n  if (!includeDeleted) {\n    where.deletedAt = null\n  }\n\n  // Folder filter\n  if (folderId !== undefined) {\n    where.folderId = folderId\n  }\n\n  // Type filter (by mime type prefix)\n  if (type) {\n    switch (type) {\n      case 'image':\n        where.mimeType = { startsWith: 'image/' }\n        break\n      case 'video':\n        where.mimeType = { startsWith: 'video/' }\n        break\n      case 'audio':\n        where.mimeType = { startsWith: 'audio/' }\n        break\n      case 'document':\n        where.OR = [\n          { mimeType: 'application/pdf' },\n          { mimeType: { contains: 'document' } },\n          { mimeType: { contains: 'spreadsheet' } },\n          { mimeType: { contains: 'presentation' } },\n          { mimeType: { contains: 'word' } },\n          { mimeType: { contains: 'excel' } },\n          { mimeType: { contains: 'powerpoint' } },\n          { mimeType: 'text/plain' },\n          { mimeType: 'text/csv' },\n        ]\n        break\n    }\n  }\n\n  // Search filter\n  if (search) {\n    const searchLower = search.toLowerCase()\n    where.OR = [\n      { filename: { contains: searchLower, mode: 'insensitive' } },\n      { originalName: { contains: searchLower, mode: 'insensitive' } },\n      { title: { contains: searchLower, mode: 'insensitive' } },\n      { alt: { contains: searchLower, mode: 'insensitive' } },\n      { caption: { contains: searchLower, mode: 'insensitive' } },\n    ]\n  }\n\n  // Tag filter\n  if (tagIds && tagIds.length > 0) {\n    where.tags = {\n      some: {\n        tagId: { in: tagIds },\n      },\n    }\n  }\n\n  // Sort\n  const orderBy: MediaOrderByInput = {}\n  switch (sortBy) {\n    case 'name':\n      orderBy.originalName = sortOrder\n      break\n    case 'size':\n      orderBy.size = sortOrder\n      break\n    case 'type':\n      orderBy.mimeType = sortOrder\n      break\n    case 'createdAt':\n    default:\n      orderBy.createdAt = sortOrder\n      break\n  }\n\n  const skip = (page - 1) * limit\n\n  const [media, total] = await Promise.all([\n    db.media.findMany({\n      where,\n      include: {\n        folder: true,\n        tags: {\n          include: {\n            tag: true,\n          },\n        },\n        uploadedBy: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n        _count: {\n          select: {\n            usages: true,\n          },\n        },\n      },\n      orderBy,\n      skip,\n      take: limit,\n    }),\n    db.media.count({ where }),\n  ])\n\n  return {\n    media: media as MediaWithRelations[],\n    total,\n    page,\n    limit,\n    hasMore: skip + media.length < total,\n  }\n}\n\n// =============================================================================\n// GET SINGLE MEDIA\n// =============================================================================\n\nexport async function getMedia(id: string, includeUsage = true): Promise<MediaWithRelations | null> {\n  const media = await db.media.findUnique({\n    where: { id },\n    include: {\n      folder: true,\n      tags: {\n        include: {\n          tag: true,\n        },\n      },\n      usages: includeUsage,\n      uploadedBy: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        },\n      },\n    },\n  })\n\n  return media as MediaWithRelations | null\n}\n\n// =============================================================================\n// CREATE MEDIA\n// =============================================================================\n\nexport async function createMedia(input: MediaCreateInput): Promise<MediaWithRelations> {\n  const { tagIds, ...data } = input\n\n  const media = await db.media.create({\n    data: {\n      ...data,\n      tags: tagIds?.length\n        ? {\n            create: tagIds.map((tagId) => ({ tagId })),\n          }\n        : undefined,\n    },\n    include: {\n      folder: true,\n      tags: {\n        include: {\n          tag: true,\n        },\n      },\n      uploadedBy: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        },\n      },\n    },\n  })\n\n  return media as MediaWithRelations\n}\n\n// =============================================================================\n// UPDATE MEDIA\n// =============================================================================\n\nexport async function updateMedia(id: string, input: MediaUpdateInput): Promise<MediaWithRelations> {\n  const { tagIds, ...data } = input\n\n  // If tagIds is provided, replace all tags\n  if (tagIds !== undefined) {\n    await db.mediaTagOnMedia.deleteMany({\n      where: { mediaId: id },\n    })\n\n    if (tagIds.length > 0) {\n      await db.mediaTagOnMedia.createMany({\n        data: tagIds.map((tagId) => ({ mediaId: id, tagId })),\n      })\n    }\n  }\n\n  const media = await db.media.update({\n    where: { id },\n    data,\n    include: {\n      folder: true,\n      tags: {\n        include: {\n          tag: true,\n        },\n      },\n      usages: true,\n      uploadedBy: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        },\n      },\n    },\n  })\n\n  return media as MediaWithRelations\n}\n\n// =============================================================================\n// DELETE MEDIA\n// =============================================================================\n\nexport async function deleteMedia(id: string, hard = false): Promise<void> {\n  if (hard) {\n    // Hard delete - permanently remove\n    await db.media.delete({\n      where: { id },\n    })\n  } else {\n    // Soft delete - mark as deleted\n    await db.media.update({\n      where: { id },\n      data: { deletedAt: new Date() },\n    })\n  }\n}\n\n// =============================================================================\n// RESTORE MEDIA\n// =============================================================================\n\nexport async function restoreMedia(id: string): Promise<MediaWithRelations> {\n  const media = await db.media.update({\n    where: { id },\n    data: { deletedAt: null },\n    include: {\n      folder: true,\n      tags: {\n        include: {\n          tag: true,\n        },\n      },\n      uploadedBy: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        },\n      },\n    },\n  })\n\n  return media as MediaWithRelations\n}\n\n// =============================================================================\n// BULK OPERATIONS\n// =============================================================================\n\nexport async function bulkDeleteMedia(ids: string[], hard = false): Promise<number> {\n  if (hard) {\n    const result = await db.media.deleteMany({\n      where: { id: { in: ids } },\n    })\n    return result.count\n  } else {\n    const result = await db.media.updateMany({\n      where: { id: { in: ids } },\n      data: { deletedAt: new Date() },\n    })\n    return result.count\n  }\n}\n\nexport async function bulkMoveMedia(ids: string[], folderId: string | null): Promise<number> {\n  const result = await db.media.updateMany({\n    where: { id: { in: ids } },\n    data: { folderId },\n  })\n  return result.count\n}\n\nexport async function bulkTagMedia(ids: string[], tagIds: string[]): Promise<number> {\n  // Create tag associations for each media item\n  const data = ids.flatMap((mediaId) =>\n    tagIds.map((tagId) => ({ mediaId, tagId }))\n  )\n\n  await db.mediaTagOnMedia.createMany({\n    data,\n    skipDuplicates: true,\n  })\n\n  return ids.length\n}\n\nexport async function bulkUntagMedia(ids: string[], tagIds: string[]): Promise<number> {\n  const result = await db.mediaTagOnMedia.deleteMany({\n    where: {\n      mediaId: { in: ids },\n      tagId: { in: tagIds },\n    },\n  })\n  return result.count\n}\n\nexport async function bulkRestoreMedia(ids: string[]): Promise<number> {\n  const result = await db.media.updateMany({\n    where: { id: { in: ids } },\n    data: { deletedAt: null },\n  })\n  return result.count\n}\n\n// =============================================================================\n// STATS\n// =============================================================================\n\nexport async function getMediaStats() {\n  const [total, byType, totalSize, recentCount] = await Promise.all([\n    db.media.count({ where: { deletedAt: null } }),\n    db.media.groupBy({\n      by: ['mimeType'],\n      where: { deletedAt: null },\n      _count: { id: true },\n    }),\n    db.media.aggregate({\n      where: { deletedAt: null },\n      _sum: { size: true },\n    }),\n    db.media.count({\n      where: {\n        deletedAt: null,\n        createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },\n      },\n    }),\n  ])\n\n  // Group by media type\n  const typeStats = {\n    image: 0,\n    video: 0,\n    audio: 0,\n    document: 0,\n    other: 0,\n  }\n\n  for (const item of byType) {\n    if (item.mimeType.startsWith('image/')) {\n      typeStats.image += item._count.id\n    } else if (item.mimeType.startsWith('video/')) {\n      typeStats.video += item._count.id\n    } else if (item.mimeType.startsWith('audio/')) {\n      typeStats.audio += item._count.id\n    } else if (\n      item.mimeType === 'application/pdf' ||\n      item.mimeType.includes('document') ||\n      item.mimeType.includes('word')\n    ) {\n      typeStats.document += item._count.id\n    } else {\n      typeStats.other += item._count.id\n    }\n  }\n\n  return {\n    total,\n    totalSize: totalSize._sum.size || 0,\n    recentCount,\n    byType: typeStats,\n  }\n}\n\n// Re-export types\nexport * from './types'\n","/**\n * Base Email Template\n *\n * Provides consistent styling and structure for all transactional emails.\n * Uses inline CSS for maximum email client compatibility.\n */\n\nexport interface BaseTemplateOptions {\n  title: string;\n  preheader?: string;\n  content: string;\n  footerContent?: string;\n  brandColor?: string;\n  logoUrl?: string;\n  storeName?: string;\n  storeUrl?: string;\n  supportEmail?: string;\n  unsubscribeUrl?: string;\n  socialLinks?: {\n    facebook?: string;\n    twitter?: string;\n    instagram?: string;\n  };\n}\n\n/**\n * Base email template with responsive design and dark mode support\n */\nexport function baseTemplate(options: BaseTemplateOptions): string {\n  const {\n    title,\n    preheader = '',\n    content,\n    footerContent = '',\n    brandColor = '#4F46E5',\n    logoUrl,\n    storeName = '{{store.name}}',\n    storeUrl = '{{store.url}}',\n    supportEmail = '{{store.supportEmail}}',\n    unsubscribeUrl,\n    socialLinks = {},\n  } = options;\n\n  return `\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:v=\"urn:schemas-microsoft-com:vml\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"x-apple-disable-message-reformatting\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <meta name=\"format-detection\" content=\"telephone=no, date=no, address=no, email=no, url=no\">\n  <meta name=\"color-scheme\" content=\"light dark\">\n  <meta name=\"supported-color-schemes\" content=\"light dark\">\n  <!--[if mso]>\n  <noscript>\n    <xml>\n      <o:OfficeDocumentSettings xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n        <o:PixelsPerInch>96</o:PixelsPerInch>\n      </o:OfficeDocumentSettings>\n    </xml>\n  </noscript>\n  <style>\n    td,th,div,p,a,h1,h2,h3,h4,h5,h6 {font-family: \"Segoe UI\", sans-serif; mso-line-height-rule: exactly;}\n  </style>\n  <![endif]-->\n  <title>${title}</title>\n  <style>\n    :root {\n      color-scheme: light dark;\n    }\n\n    /* Reset */\n    body, table, td, p, a, li, blockquote {\n      -webkit-text-size-adjust: 100%;\n      -ms-text-size-adjust: 100%;\n    }\n\n    table, td {\n      mso-table-lspace: 0pt;\n      mso-table-rspace: 0pt;\n      border-collapse: collapse !important;\n    }\n\n    img {\n      -ms-interpolation-mode: bicubic;\n      border: 0;\n      height: auto;\n      line-height: 100%;\n      outline: none;\n      text-decoration: none;\n    }\n\n    body {\n      margin: 0 !important;\n      padding: 0 !important;\n      width: 100% !important;\n      background-color: #f4f4f5;\n    }\n\n    /* Dark mode styles */\n    @media (prefers-color-scheme: dark) {\n      body {\n        background-color: #18181b !important;\n      }\n      .email-container {\n        background-color: #27272a !important;\n      }\n      .email-content {\n        color: #e4e4e7 !important;\n      }\n      .email-footer {\n        background-color: #18181b !important;\n        color: #a1a1aa !important;\n      }\n      h1, h2, h3, h4, h5, h6 {\n        color: #fafafa !important;\n      }\n      p, td {\n        color: #e4e4e7 !important;\n      }\n      .text-muted {\n        color: #a1a1aa !important;\n      }\n    }\n\n    /* Responsive styles */\n    @media only screen and (max-width: 600px) {\n      .email-container {\n        width: 100% !important;\n        max-width: 100% !important;\n      }\n      .stack-column {\n        display: block !important;\n        width: 100% !important;\n        max-width: 100% !important;\n      }\n      .stack-column-center {\n        text-align: center !important;\n      }\n      .mobile-padding {\n        padding-left: 20px !important;\n        padding-right: 20px !important;\n      }\n      .mobile-hide {\n        display: none !important;\n      }\n    }\n  </style>\n</head>\n<body style=\"margin: 0; padding: 0; background-color: #f4f4f5;\">\n  <!-- Preheader text (hidden) -->\n  <div style=\"display: none; font-size: 1px; line-height: 1px; max-height: 0px; max-width: 0px; opacity: 0; overflow: hidden; mso-hide: all;\">\n    ${preheader}\n    ${'&zwnj;&nbsp;'.repeat(50)}\n  </div>\n\n  <!-- Email wrapper -->\n  <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"background-color: #f4f4f5;\">\n    <tr>\n      <td align=\"center\" style=\"padding: 40px 10px;\">\n\n        <!-- Email container -->\n        <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"600\" class=\"email-container\" style=\"max-width: 600px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);\">\n\n          <!-- Header -->\n          <tr>\n            <td style=\"padding: 30px 40px; text-align: center; border-bottom: 1px solid #e4e4e7;\">\n              ${logoUrl ? `\n              <a href=\"${storeUrl}\" style=\"text-decoration: none;\">\n                <img src=\"${logoUrl}\" alt=\"${storeName}\" width=\"150\" style=\"max-width: 150px; height: auto;\">\n              </a>\n              ` : `\n              <a href=\"${storeUrl}\" style=\"text-decoration: none; font-size: 24px; font-weight: bold; color: ${brandColor}; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;\">\n                ${storeName}\n              </a>\n              `}\n            </td>\n          </tr>\n\n          <!-- Content -->\n          <tr>\n            <td class=\"email-content mobile-padding\" style=\"padding: 40px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.6; color: #3f3f46;\">\n              ${content}\n            </td>\n          </tr>\n\n          <!-- Footer -->\n          <tr>\n            <td class=\"email-footer\" style=\"padding: 30px 40px; background-color: #fafafa; border-top: 1px solid #e4e4e7; border-radius: 0 0 8px 8px;\">\n              <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                ${footerContent ? `\n                <tr>\n                  <td style=\"padding-bottom: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.5; color: #71717a;\">\n                    ${footerContent}\n                  </td>\n                </tr>\n                ` : ''}\n\n                <!-- Social links -->\n                ${Object.keys(socialLinks).length > 0 ? `\n                <tr>\n                  <td align=\"center\" style=\"padding-bottom: 20px;\">\n                    ${socialLinks.facebook ? `<a href=\"${socialLinks.facebook}\" style=\"text-decoration: none; margin: 0 8px;\"><img src=\"https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/facebook.svg\" width=\"24\" height=\"24\" alt=\"Facebook\" style=\"opacity: 0.6;\"></a>` : ''}\n                    ${socialLinks.twitter ? `<a href=\"${socialLinks.twitter}\" style=\"text-decoration: none; margin: 0 8px;\"><img src=\"https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/twitter.svg\" width=\"24\" height=\"24\" alt=\"Twitter\" style=\"opacity: 0.6;\"></a>` : ''}\n                    ${socialLinks.instagram ? `<a href=\"${socialLinks.instagram}\" style=\"text-decoration: none; margin: 0 8px;\"><img src=\"https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/instagram.svg\" width=\"24\" height=\"24\" alt=\"Instagram\" style=\"opacity: 0.6;\"></a>` : ''}\n                  </td>\n                </tr>\n                ` : ''}\n\n                <tr>\n                  <td align=\"center\" style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 12px; line-height: 1.5; color: #a1a1aa;\">\n                    <p style=\"margin: 0 0 8px 0;\">\n                      Questions? Contact us at <a href=\"mailto:${supportEmail}\" style=\"color: ${brandColor}; text-decoration: none;\">${supportEmail}</a>\n                    </p>\n                    <p style=\"margin: 0 0 8px 0;\">\n                      &copy; {{currentYear}} ${storeName}. All rights reserved.\n                    </p>\n                    ${unsubscribeUrl ? `\n                    <p style=\"margin: 0;\">\n                      <a href=\"${unsubscribeUrl}\" style=\"color: #a1a1aa; text-decoration: underline;\">Unsubscribe</a>\n                    </p>\n                    ` : ''}\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n\n        </table>\n\n      </td>\n    </tr>\n  </table>\n</body>\n</html>\n`.trim();\n}\n\n/**\n * Common UI components for email templates\n */\nexport const emailComponents = {\n  /**\n   * Primary call-to-action button\n   */\n  button: (text: string, url: string, color = '#4F46E5'): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"border-radius: 6px; background-color: ${color};\">\n          <a href=\"${url}\" target=\"_blank\" style=\"display: inline-block; padding: 14px 28px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 16px; font-weight: 600; color: #ffffff; text-decoration: none; border-radius: 6px;\">\n            ${text}\n          </a>\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Secondary/outline button\n   */\n  buttonOutline: (text: string, url: string, color = '#4F46E5'): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"border-radius: 6px; border: 2px solid ${color};\">\n          <a href=\"${url}\" target=\"_blank\" style=\"display: inline-block; padding: 12px 26px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 16px; font-weight: 600; color: ${color}; text-decoration: none; border-radius: 6px;\">\n            ${text}\n          </a>\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Divider line\n   */\n  divider: (): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"border-top: 1px solid #e4e4e7;\"></td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Info box/callout\n   */\n  infoBox: (content: string, bgColor = '#eff6ff', borderColor = '#3b82f6'): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"padding: 16px 20px; background-color: ${bgColor}; border-left: 4px solid ${borderColor}; border-radius: 4px;\">\n          ${content}\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Success box\n   */\n  successBox: (content: string): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"padding: 16px 20px; background-color: #f0fdf4; border-left: 4px solid #22c55e; border-radius: 4px;\">\n          ${content}\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Warning box\n   */\n  warningBox: (content: string): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"padding: 16px 20px; background-color: #fffbeb; border-left: 4px solid #f59e0b; border-radius: 4px;\">\n          ${content}\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Two-column layout row\n   */\n  twoColumn: (leftContent: string, rightContent: string): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n      <tr>\n        <td class=\"stack-column\" width=\"50%\" valign=\"top\" style=\"padding-right: 10px;\">\n          ${leftContent}\n        </td>\n        <td class=\"stack-column\" width=\"50%\" valign=\"top\" style=\"padding-left: 10px;\">\n          ${rightContent}\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Image with optional caption\n   */\n  image: (src: string, alt: string, width = 520, caption?: string): string => `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      <tr>\n        <td align=\"center\">\n          <img src=\"${src}\" alt=\"${alt}\" width=\"${width}\" style=\"max-width: 100%; height: auto; border-radius: 6px;\">\n          ${caption ? `<p style=\"margin: 8px 0 0 0; font-size: 14px; color: #71717a;\">${caption}</p>` : ''}\n        </td>\n      </tr>\n    </table>\n  `,\n\n  /**\n   * Heading styles\n   */\n  heading: {\n    h1: (text: string): string => `<h1 style=\"margin: 0 0 24px 0; font-size: 28px; font-weight: 700; color: #18181b; line-height: 1.3;\">${text}</h1>`,\n    h2: (text: string): string => `<h2 style=\"margin: 24px 0 16px 0; font-size: 22px; font-weight: 600; color: #18181b; line-height: 1.3;\">${text}</h2>`,\n    h3: (text: string): string => `<h3 style=\"margin: 20px 0 12px 0; font-size: 18px; font-weight: 600; color: #18181b; line-height: 1.3;\">${text}</h3>`,\n  },\n\n  /**\n   * Paragraph\n   */\n  paragraph: (text: string): string => `<p style=\"margin: 0 0 16px 0; font-size: 16px; line-height: 1.6; color: #3f3f46;\">${text}</p>`,\n\n  /**\n   * Muted/secondary text\n   */\n  mutedText: (text: string): string => `<p style=\"margin: 0 0 16px 0; font-size: 14px; line-height: 1.5; color: #71717a;\">${text}</p>`,\n};\n","/**\n * Email Template Renderer\n *\n * Renders email templates with merge tags and provides\n * a unified interface for generating transactional emails.\n */\n\nimport { parseMergeTags, MergeTagData } from '../merge-tags';\nimport { baseTemplate, BaseTemplateOptions, emailComponents } from './base';\n\nexport interface StoreConfig {\n  name: string;\n  url: string;\n  supportEmail: string;\n  logoUrl?: string;\n  brandColor?: string;\n  socialLinks?: {\n    facebook?: string;\n    twitter?: string;\n    instagram?: string;\n  };\n}\n\nexport interface RenderOptions {\n  /** Store configuration */\n  store?: Partial<StoreConfig>;\n  /** Additional merge tag data */\n  data?: MergeTagData;\n}\n\n/**\n * Default store config - can be overridden per-render or via settings\n */\nconst defaultStoreConfig: StoreConfig = {\n  name: 'Our Store',\n  url: 'https://example.com',\n  supportEmail: 'support@example.com',\n};\n\n/**\n * Recursively convert Date objects to ISO strings in data\n */\nfunction sanitizeData(data: unknown): MergeTagData {\n  if (data === null || data === undefined) {\n    return {};\n  }\n\n  if (data instanceof Date) {\n    return data.toISOString() as unknown as MergeTagData;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map(sanitizeData) as unknown as MergeTagData;\n  }\n\n  if (typeof data === 'object') {\n    const result: MergeTagData = {};\n    for (const [key, value] of Object.entries(data)) {\n      if (value instanceof Date) {\n        result[key] = value.toISOString();\n      } else if (Array.isArray(value)) {\n        result[key] = value.map(sanitizeData) as MergeTagData[];\n      } else if (typeof value === 'object' && value !== null) {\n        result[key] = sanitizeData(value);\n      } else {\n        result[key] = value as string | number | boolean | null | undefined;\n      }\n    }\n    return result;\n  }\n\n  return data as unknown as MergeTagData;\n}\n\n/**\n * Renders an email template with merge tags\n */\nexport function renderTemplate(\n  template: string,\n  data: Record<string, unknown>,\n  options: RenderOptions = {}\n): string {\n  const { store = {} } = options;\n\n  // Merge store config with data\n  const dataStore = typeof data.store === 'object' && data.store !== null ? data.store as Record<string, unknown> : {};\n  const mergedData: Record<string, unknown> = {\n    ...data,\n    store: {\n      ...defaultStoreConfig,\n      ...store,\n      ...dataStore,\n    },\n    currentYear: new Date().getFullYear().toString(),\n  };\n\n  // Sanitize data (convert Dates to strings)\n  const sanitizedData = sanitizeData(mergedData);\n\n  // Process merge tags\n  return parseMergeTags(template, sanitizedData);\n}\n\n/**\n * Wraps content in the base email template\n */\nexport function wrapInBaseTemplate(\n  content: string,\n  options: Partial<BaseTemplateOptions> & { store?: Partial<StoreConfig> }\n): string {\n  const store = options.store || {};\n\n  return baseTemplate({\n    title: options.title || 'Email from ' + (store.name || defaultStoreConfig.name),\n    preheader: options.preheader,\n    content,\n    footerContent: options.footerContent,\n    brandColor: store.brandColor || options.brandColor,\n    logoUrl: store.logoUrl || options.logoUrl,\n    storeName: store.name || defaultStoreConfig.name,\n    storeUrl: store.url || defaultStoreConfig.url,\n    supportEmail: store.supportEmail || defaultStoreConfig.supportEmail,\n    unsubscribeUrl: options.unsubscribeUrl,\n    socialLinks: store.socialLinks || options.socialLinks,\n  });\n}\n\n/**\n * Complete email rendering: wraps in base template and processes merge tags\n */\nexport function renderEmail(\n  content: string,\n  templateOptions: Partial<BaseTemplateOptions>,\n  data: Record<string, unknown>,\n  renderOptions: RenderOptions = {}\n): string {\n  const store = renderOptions.store || {};\n\n  // First wrap in base template\n  const wrappedHtml = wrapInBaseTemplate(content, {\n    ...templateOptions,\n    store,\n  });\n\n  // Then process merge tags\n  return renderTemplate(wrappedHtml, data, renderOptions);\n}\n\n/**\n * Generate plain text version from HTML (basic conversion)\n */\nexport function htmlToPlainText(html: string): string {\n  return html\n    // Remove style and script tags with content\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    // Convert links to text with URL\n    .replace(/<a[^>]*href=\"([^\"]*)\"[^>]*>([^<]*)<\\/a>/gi, '$2 ($1)')\n    // Convert headings to uppercase with newlines\n    .replace(/<h[1-6][^>]*>([^<]*)<\\/h[1-6]>/gi, '\\n\\n$1\\n')\n    // Convert paragraphs and divs to newlines\n    .replace(/<\\/p>/gi, '\\n\\n')\n    .replace(/<\\/div>/gi, '\\n')\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    // Convert list items\n    .replace(/<li[^>]*>/gi, '\\n- ')\n    // Remove all remaining HTML tags\n    .replace(/<[^>]+>/g, '')\n    // Decode common HTML entities\n    .replace(/&nbsp;/gi, ' ')\n    .replace(/&amp;/gi, '&')\n    .replace(/&lt;/gi, '<')\n    .replace(/&gt;/gi, '>')\n    .replace(/&quot;/gi, '\"')\n    .replace(/&#39;/gi, \"'\")\n    .replace(/&zwnj;/g, '')\n    // Clean up whitespace\n    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')\n    .replace(/^\\s+|\\s+$/g, '')\n    .trim();\n}\n\n/**\n * Template builder for creating email content\n */\nexport class EmailTemplateBuilder {\n  private content: string[] = [];\n  private store: Partial<StoreConfig> = {};\n\n  constructor(store?: Partial<StoreConfig>) {\n    if (store) {\n      this.store = store;\n    }\n  }\n\n  /**\n   * Add a heading\n   */\n  heading(text: string, level: 1 | 2 | 3 = 1): this {\n    const headingFn = emailComponents.heading[`h${level}`];\n    this.content.push(headingFn(text));\n    return this;\n  }\n\n  /**\n   * Add a paragraph\n   */\n  paragraph(text: string): this {\n    this.content.push(emailComponents.paragraph(text));\n    return this;\n  }\n\n  /**\n   * Add muted/secondary text\n   */\n  muted(text: string): this {\n    this.content.push(emailComponents.mutedText(text));\n    return this;\n  }\n\n  /**\n   * Add a primary button\n   */\n  button(text: string, url: string, color?: string): this {\n    this.content.push(emailComponents.button(text, url, color || this.store.brandColor));\n    return this;\n  }\n\n  /**\n   * Add an outline button\n   */\n  buttonOutline(text: string, url: string, color?: string): this {\n    this.content.push(emailComponents.buttonOutline(text, url, color || this.store.brandColor));\n    return this;\n  }\n\n  /**\n   * Add a divider\n   */\n  divider(): this {\n    this.content.push(emailComponents.divider());\n    return this;\n  }\n\n  /**\n   * Add an info box\n   */\n  info(content: string): this {\n    this.content.push(emailComponents.infoBox(content));\n    return this;\n  }\n\n  /**\n   * Add a success box\n   */\n  success(content: string): this {\n    this.content.push(emailComponents.successBox(content));\n    return this;\n  }\n\n  /**\n   * Add a warning box\n   */\n  warning(content: string): this {\n    this.content.push(emailComponents.warningBox(content));\n    return this;\n  }\n\n  /**\n   * Add an image\n   */\n  image(src: string, alt: string, width?: number, caption?: string): this {\n    this.content.push(emailComponents.image(src, alt, width, caption));\n    return this;\n  }\n\n  /**\n   * Add raw HTML\n   */\n  raw(html: string): this {\n    this.content.push(html);\n    return this;\n  }\n\n  /**\n   * Add two-column layout\n   */\n  twoColumn(left: string, right: string): this {\n    this.content.push(emailComponents.twoColumn(left, right));\n    return this;\n  }\n\n  /**\n   * Build the content string\n   */\n  build(): string {\n    return this.content.join('\\n');\n  }\n\n  /**\n   * Build and wrap in base template\n   */\n  buildWithWrapper(options: Partial<BaseTemplateOptions>): string {\n    return wrapInBaseTemplate(this.build(), {\n      ...options,\n      store: this.store,\n    });\n  }\n\n  /**\n   * Build, wrap, and render with data\n   */\n  render(\n    templateOptions: Partial<BaseTemplateOptions>,\n    data: Record<string, unknown>,\n    renderOptions?: RenderOptions\n  ): string {\n    return renderEmail(this.build(), templateOptions, data, {\n      ...renderOptions,\n      store: { ...this.store, ...renderOptions?.store },\n    });\n  }\n}\n\n/**\n * Create a new template builder\n */\nexport function createEmailBuilder(store?: Partial<StoreConfig>): EmailTemplateBuilder {\n  return new EmailTemplateBuilder(store);\n}\n\n// Re-export components for direct use\nexport { emailComponents };\n\n// Re-export MergeTagData type for consumers\nexport type { MergeTagData };\n","/**\n * Order Confirmation Email Template\n *\n * Sent immediately after a successful order is placed.\n * Includes order details, items, pricing, and shipping info.\n */\n\nimport { renderEmail, StoreConfig, emailComponents } from './renderer';\n\nexport interface OrderItem {\n  id: string;\n  name: string;\n  variant?: string;\n  quantity: number;\n  price: number;\n  imageUrl?: string;\n}\n\nexport interface OrderAddress {\n  name: string;\n  line1: string;\n  line2?: string;\n  city: string;\n  state: string;\n  postalCode: string;\n  country: string;\n}\n\nexport interface OrderConfirmationData {\n  order: {\n    id: string;\n    orderNumber: string;\n    createdAt: Date | string;\n    items: OrderItem[];\n    subtotal: number;\n    shipping: number;\n    tax: number;\n    discount?: number;\n    total: number;\n    currency?: string;\n    paymentMethod?: string;\n    shippingAddress: OrderAddress;\n    billingAddress?: OrderAddress;\n    shippingMethod?: string;\n    estimatedDelivery?: string;\n    notes?: string;\n  };\n  customer: {\n    name: string;\n    email: string;\n  };\n}\n\n/**\n * Generate order items table HTML\n */\nfunction generateItemsTable(items: OrderItem[], currency = 'USD'): string {\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  const itemRows = items.map(item => `\n    <tr>\n      <td style=\"padding: 16px 0; border-bottom: 1px solid #e4e4e7;\">\n        <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n          <tr>\n            ${item.imageUrl ? `\n            <td width=\"80\" valign=\"top\" style=\"padding-right: 16px;\">\n              <img src=\"${item.imageUrl}\" alt=\"${item.name}\" width=\"80\" height=\"80\" style=\"border-radius: 6px; object-fit: cover;\">\n            </td>\n            ` : ''}\n            <td valign=\"top\">\n              <p style=\"margin: 0 0 4px 0; font-weight: 600; color: #18181b;\">${item.name}</p>\n              ${item.variant ? `<p style=\"margin: 0 0 4px 0; font-size: 14px; color: #71717a;\">${item.variant}</p>` : ''}\n              <p style=\"margin: 0; font-size: 14px; color: #71717a;\">Qty: ${item.quantity}</p>\n            </td>\n            <td width=\"100\" valign=\"top\" align=\"right\">\n              <p style=\"margin: 0; font-weight: 600; color: #18181b;\">${formatPrice(item.price * item.quantity)}</p>\n            </td>\n          </tr>\n        </table>\n      </td>\n    </tr>\n  `).join('');\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      ${itemRows}\n    </table>\n  `;\n}\n\n/**\n * Generate order totals section\n */\nfunction generateTotals(order: OrderConfirmationData['order']): string {\n  const currency = order.currency || 'USD';\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      <tr>\n        <td style=\"padding: 8px 0; color: #71717a;\">Subtotal</td>\n        <td align=\"right\" style=\"padding: 8px 0; color: #3f3f46;\">${formatPrice(order.subtotal)}</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px 0; color: #71717a;\">Shipping</td>\n        <td align=\"right\" style=\"padding: 8px 0; color: #3f3f46;\">${order.shipping === 0 ? 'Free' : formatPrice(order.shipping)}</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 8px 0; color: #71717a;\">Tax</td>\n        <td align=\"right\" style=\"padding: 8px 0; color: #3f3f46;\">${formatPrice(order.tax)}</td>\n      </tr>\n      ${order.discount ? `\n      <tr>\n        <td style=\"padding: 8px 0; color: #22c55e;\">Discount</td>\n        <td align=\"right\" style=\"padding: 8px 0; color: #22c55e;\">-${formatPrice(order.discount)}</td>\n      </tr>\n      ` : ''}\n      <tr>\n        <td style=\"padding: 16px 0 8px 0; border-top: 2px solid #e4e4e7; font-weight: 700; font-size: 18px; color: #18181b;\">Total</td>\n        <td align=\"right\" style=\"padding: 16px 0 8px 0; border-top: 2px solid #e4e4e7; font-weight: 700; font-size: 18px; color: #18181b;\">${formatPrice(order.total)}</td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate address block\n */\nfunction generateAddressBlock(title: string, address: OrderAddress): string {\n  return `\n    <div style=\"padding: 16px; background-color: #fafafa; border-radius: 6px;\">\n      <p style=\"margin: 0 0 8px 0; font-weight: 600; color: #18181b;\">${title}</p>\n      <p style=\"margin: 0; font-size: 14px; line-height: 1.5; color: #3f3f46;\">\n        ${address.name}<br>\n        ${address.line1}<br>\n        ${address.line2 ? address.line2 + '<br>' : ''}\n        ${address.city}, ${address.state} ${address.postalCode}<br>\n        ${address.country}\n      </p>\n    </div>\n  `;\n}\n\n/**\n * Generate order confirmation email content\n */\nexport function generateOrderConfirmationContent(data: OrderConfirmationData): string {\n  const { order, customer } = data;\n  const orderDate = new Date(order.createdAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  return `\n    ${emailComponents.heading.h1('Thank you for your order!')}\n\n    ${emailComponents.paragraph(`Hi ${customer.name},`)}\n\n    ${emailComponents.paragraph(`We've received your order and it's being processed. You'll receive another email when your order ships.`)}\n\n    ${emailComponents.successBox(`\n      <p style=\"margin: 0; font-weight: 600;\">Order #${order.orderNumber}</p>\n      <p style=\"margin: 4px 0 0 0; font-size: 14px; color: #71717a;\">Placed on ${orderDate}</p>\n    `)}\n\n    ${emailComponents.button('View Order', `{{store.url}}/account/orders/${order.id}`)}\n\n    ${emailComponents.heading.h2('Order Details')}\n\n    ${generateItemsTable(order.items, order.currency)}\n\n    ${generateTotals(order)}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.heading.h2('Shipping Information')}\n\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n      <tr>\n        <td class=\"stack-column\" width=\"50%\" valign=\"top\" style=\"padding-right: 10px; padding-bottom: 16px;\">\n          ${generateAddressBlock('Shipping Address', order.shippingAddress)}\n        </td>\n        ${order.billingAddress ? `\n        <td class=\"stack-column\" width=\"50%\" valign=\"top\" style=\"padding-left: 10px; padding-bottom: 16px;\">\n          ${generateAddressBlock('Billing Address', order.billingAddress)}\n        </td>\n        ` : ''}\n      </tr>\n    </table>\n\n    ${order.shippingMethod ? `\n    ${emailComponents.infoBox(`\n      <p style=\"margin: 0;\"><strong>Shipping Method:</strong> ${order.shippingMethod}</p>\n      ${order.estimatedDelivery ? `<p style=\"margin: 4px 0 0 0;\"><strong>Estimated Delivery:</strong> ${order.estimatedDelivery}</p>` : ''}\n    `)}\n    ` : ''}\n\n    ${order.paymentMethod ? `\n    ${emailComponents.mutedText(`<strong>Payment Method:</strong> ${order.paymentMethod}`)}\n    ` : ''}\n\n    ${order.notes ? `\n    ${emailComponents.divider()}\n    ${emailComponents.heading.h3('Order Notes')}\n    ${emailComponents.paragraph(order.notes)}\n    ` : ''}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.mutedText('If you have any questions about your order, please don\\'t hesitate to contact our support team.')}\n  `;\n}\n\n/**\n * Render complete order confirmation email\n */\nexport function renderOrderConfirmationEmail(\n  data: OrderConfirmationData,\n  store?: Partial<StoreConfig>\n): { html: string; text: string; subject: string } {\n  const content = generateOrderConfirmationContent(data);\n\n  const mergeData: Record<string, unknown> = {\n    order: data.order,\n    customer: data.customer,\n  };\n\n  const html = renderEmail(\n    content,\n    {\n      title: `Order Confirmation #${data.order.orderNumber}`,\n      preheader: `Thank you for your order! Your order #${data.order.orderNumber} has been confirmed.`,\n    },\n    mergeData,\n    { store }\n  );\n\n  // Generate plain text version\n  const text = `\nThank you for your order!\n\nHi ${data.customer.name},\n\nWe've received your order and it's being processed. You'll receive another email when your order ships.\n\nOrder #${data.order.orderNumber}\nPlaced on ${new Date(data.order.createdAt).toLocaleDateString()}\n\nORDER DETAILS:\n${data.order.items.map(item => `- ${item.name}${item.variant ? ` (${item.variant})` : ''} x${item.quantity}`).join('\\n')}\n\nSubtotal: ${(data.order.subtotal / 100).toFixed(2)}\nShipping: ${data.order.shipping === 0 ? 'Free' : (data.order.shipping / 100).toFixed(2)}\nTax: ${(data.order.tax / 100).toFixed(2)}\n${data.order.discount ? `Discount: -${(data.order.discount / 100).toFixed(2)}` : ''}\nTotal: ${(data.order.total / 100).toFixed(2)}\n\nSHIPPING ADDRESS:\n${data.order.shippingAddress.name}\n${data.order.shippingAddress.line1}\n${data.order.shippingAddress.line2 ? data.order.shippingAddress.line2 + '\\n' : ''}${data.order.shippingAddress.city}, ${data.order.shippingAddress.state} ${data.order.shippingAddress.postalCode}\n${data.order.shippingAddress.country}\n\nIf you have any questions, please contact our support team.\n  `.trim();\n\n  return {\n    html,\n    text,\n    subject: `Order Confirmation #${data.order.orderNumber}`,\n  };\n}\n","/**\n * Shipping Notification Email Template\n *\n * Sent when an order has been shipped.\n * Includes tracking information and shipment details.\n */\n\nimport { renderEmail, StoreConfig, emailComponents } from './renderer';\nimport { OrderItem, OrderAddress } from './order-confirmation';\n\nexport interface ShipmentData {\n  order: {\n    id: string;\n    orderNumber: string;\n    items: OrderItem[];\n  };\n  shipment: {\n    id: string;\n    carrier: string;\n    carrierName?: string;\n    trackingNumber: string;\n    trackingUrl?: string;\n    shippedAt: Date | string;\n    estimatedDelivery?: string;\n    shippingAddress: OrderAddress;\n    items?: OrderItem[]; // Items in this shipment (for partial shipments)\n  };\n  customer: {\n    name: string;\n    email: string;\n  };\n  isPartialShipment?: boolean;\n}\n\n/**\n * Generate tracking info box\n */\nfunction generateTrackingBox(shipment: ShipmentData['shipment']): string {\n  const carrierDisplay = shipment.carrierName || shipment.carrier;\n  const shippedDate = new Date(shipment.shippedAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0; background-color: #eff6ff; border-radius: 8px;\">\n      <tr>\n        <td style=\"padding: 24px;\">\n          <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n            <tr>\n              <td>\n                <p style=\"margin: 0 0 16px 0; font-size: 14px; color: #3b82f6; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;\">\n                   Shipment Details\n                </p>\n              </td>\n            </tr>\n            <tr>\n              <td>\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                  <tr>\n                    <td width=\"50%\" style=\"padding-bottom: 12px;\">\n                      <p style=\"margin: 0 0 4px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Carrier</p>\n                      <p style=\"margin: 0; font-size: 16px; font-weight: 600; color: #18181b;\">${carrierDisplay}</p>\n                    </td>\n                    <td width=\"50%\" style=\"padding-bottom: 12px;\">\n                      <p style=\"margin: 0 0 4px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Shipped On</p>\n                      <p style=\"margin: 0; font-size: 16px; font-weight: 600; color: #18181b;\">${shippedDate}</p>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td colspan=\"2\" style=\"padding-top: 12px; border-top: 1px solid #bfdbfe;\">\n                      <p style=\"margin: 0 0 4px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Tracking Number</p>\n                      <p style=\"margin: 0; font-size: 18px; font-weight: 700; color: #18181b; font-family: monospace;\">${shipment.trackingNumber}</p>\n                    </td>\n                  </tr>\n                  ${shipment.estimatedDelivery ? `\n                  <tr>\n                    <td colspan=\"2\" style=\"padding-top: 12px;\">\n                      <p style=\"margin: 0 0 4px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Estimated Delivery</p>\n                      <p style=\"margin: 0; font-size: 16px; font-weight: 600; color: #22c55e;\">${shipment.estimatedDelivery}</p>\n                    </td>\n                  </tr>\n                  ` : ''}\n                </table>\n              </td>\n            </tr>\n          </table>\n        </td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate shipped items list\n */\nfunction generateShippedItems(items: OrderItem[]): string {\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      ${items.map(item => `\n        <tr>\n          <td style=\"padding: 12px 0; border-bottom: 1px solid #e4e4e7;\">\n            <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n              <tr>\n                ${item.imageUrl ? `\n                <td width=\"60\" valign=\"top\" style=\"padding-right: 12px;\">\n                  <img src=\"${item.imageUrl}\" alt=\"${item.name}\" width=\"60\" height=\"60\" style=\"border-radius: 4px; object-fit: cover;\">\n                </td>\n                ` : ''}\n                <td valign=\"middle\">\n                  <p style=\"margin: 0 0 2px 0; font-weight: 500; color: #18181b;\">${item.name}</p>\n                  ${item.variant ? `<p style=\"margin: 0; font-size: 13px; color: #71717a;\">${item.variant}</p>` : ''}\n                </td>\n                <td width=\"50\" valign=\"middle\" align=\"right\">\n                  <p style=\"margin: 0; font-size: 14px; color: #71717a;\">x${item.quantity}</p>\n                </td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n      `).join('')}\n    </table>\n  `;\n}\n\n/**\n * Generate shipping notification email content\n */\nexport function generateShippingNotificationContent(data: ShipmentData): string {\n  const { order, shipment, customer, isPartialShipment } = data;\n  const itemsToShow = shipment.items || order.items;\n\n  return `\n    ${emailComponents.heading.h1('Your order is on its way! ')}\n\n    ${emailComponents.paragraph(`Hi ${customer.name},`)}\n\n    ${emailComponents.paragraph(\n      isPartialShipment\n        ? `Part of your order #${order.orderNumber} has shipped! Here are the tracking details for this shipment.`\n        : `Great news! Your order #${order.orderNumber} has shipped and is on its way to you.`\n    )}\n\n    ${generateTrackingBox(shipment)}\n\n    ${shipment.trackingUrl ? emailComponents.button('Track Your Package', shipment.trackingUrl) : ''}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.heading.h2(isPartialShipment ? 'Items in This Shipment' : 'Items Shipped')}\n\n    ${generateShippedItems(itemsToShow)}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.heading.h2('Shipping To')}\n\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      <tr>\n        <td style=\"padding: 16px; background-color: #fafafa; border-radius: 6px;\">\n          <p style=\"margin: 0; line-height: 1.6; color: #3f3f46;\">\n            <strong>${shipment.shippingAddress.name}</strong><br>\n            ${shipment.shippingAddress.line1}<br>\n            ${shipment.shippingAddress.line2 ? shipment.shippingAddress.line2 + '<br>' : ''}\n            ${shipment.shippingAddress.city}, ${shipment.shippingAddress.state} ${shipment.shippingAddress.postalCode}<br>\n            ${shipment.shippingAddress.country}\n          </p>\n        </td>\n      </tr>\n    </table>\n\n    ${emailComponents.infoBox(`\n      <p style=\"margin: 0; font-size: 14px;\">\n        <strong>Tip:</strong> You can also track your package by visiting your\n        <a href=\"{{store.url}}/account/orders/${order.id}\" style=\"color: #3b82f6; text-decoration: none;\">order details page</a>.\n      </p>\n    `)}\n\n    ${emailComponents.mutedText('If you have any questions about your shipment, please contact our support team.')}\n  `;\n}\n\n/**\n * Render complete shipping notification email\n */\nexport function renderShippingNotificationEmail(\n  data: ShipmentData,\n  store?: Partial<StoreConfig>\n): { html: string; text: string; subject: string } {\n  const content = generateShippingNotificationContent(data);\n\n  const mergeData: Record<string, unknown> = {\n    order: data.order,\n    shipment: data.shipment,\n    customer: data.customer,\n  };\n\n  const html = renderEmail(\n    content,\n    {\n      title: `Your Order #${data.order.orderNumber} Has Shipped`,\n      preheader: `Your order is on its way! Track your package with ${data.shipment.carrierName || data.shipment.carrier}.`,\n    },\n    mergeData,\n    { store }\n  );\n\n  const itemsToShow = data.shipment.items || data.order.items;\n\n  const text = `\nYour order is on its way!\n\nHi ${data.customer.name},\n\n${data.isPartialShipment\n  ? `Part of your order #${data.order.orderNumber} has shipped!`\n  : `Great news! Your order #${data.order.orderNumber} has shipped and is on its way to you.`\n}\n\nSHIPMENT DETAILS:\nCarrier: ${data.shipment.carrierName || data.shipment.carrier}\nTracking Number: ${data.shipment.trackingNumber}\n${data.shipment.trackingUrl ? `Track your package: ${data.shipment.trackingUrl}` : ''}\n${data.shipment.estimatedDelivery ? `Estimated Delivery: ${data.shipment.estimatedDelivery}` : ''}\n\nITEMS SHIPPED:\n${itemsToShow.map(item => `- ${item.name}${item.variant ? ` (${item.variant})` : ''} x${item.quantity}`).join('\\n')}\n\nSHIPPING TO:\n${data.shipment.shippingAddress.name}\n${data.shipment.shippingAddress.line1}\n${data.shipment.shippingAddress.line2 ? data.shipment.shippingAddress.line2 + '\\n' : ''}${data.shipment.shippingAddress.city}, ${data.shipment.shippingAddress.state} ${data.shipment.shippingAddress.postalCode}\n${data.shipment.shippingAddress.country}\n\nIf you have any questions, please contact our support team.\n  `.trim();\n\n  return {\n    html,\n    text,\n    subject: `Your Order #${data.order.orderNumber} Has Shipped`,\n  };\n}\n","/**\n * Delivery Confirmation Email Template\n *\n * Sent when an order has been delivered.\n * Includes delivery details and prompts for feedback/review.\n */\n\nimport { renderEmail, StoreConfig, emailComponents } from './renderer';\nimport { OrderItem, OrderAddress } from './order-confirmation';\n\nexport interface DeliveryData {\n  order: {\n    id: string;\n    orderNumber: string;\n    items: OrderItem[];\n  };\n  delivery: {\n    deliveredAt: Date | string;\n    deliveredTo?: string;\n    signedBy?: string;\n    proofImageUrl?: string;\n    shippingAddress: OrderAddress;\n  };\n  customer: {\n    name: string;\n    email: string;\n  };\n}\n\n/**\n * Generate delivery confirmation box\n */\nfunction generateDeliveryBox(delivery: DeliveryData['delivery']): string {\n  const deliveredDate = new Date(delivery.deliveredAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  const deliveredTime = new Date(delivery.deliveredAt).toLocaleTimeString('en-US', {\n    hour: 'numeric',\n    minute: '2-digit',\n  });\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0; background-color: #f0fdf4; border-radius: 8px;\">\n      <tr>\n        <td style=\"padding: 24px;\">\n          <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n            <tr>\n              <td align=\"center\" style=\"padding-bottom: 16px;\">\n                <div style=\"width: 64px; height: 64px; background-color: #22c55e; border-radius: 50%; display: inline-block; text-align: center; line-height: 64px;\">\n                  <span style=\"font-size: 32px;\"></span>\n                </div>\n              </td>\n            </tr>\n            <tr>\n              <td align=\"center\">\n                <p style=\"margin: 0 0 8px 0; font-size: 20px; font-weight: 700; color: #166534;\">Delivered!</p>\n                <p style=\"margin: 0 0 4px 0; font-size: 16px; color: #3f3f46;\">${deliveredDate}</p>\n                <p style=\"margin: 0; font-size: 14px; color: #71717a;\">at ${deliveredTime}</p>\n              </td>\n            </tr>\n            ${delivery.signedBy ? `\n            <tr>\n              <td align=\"center\" style=\"padding-top: 16px; border-top: 1px solid #bbf7d0; margin-top: 16px;\">\n                <p style=\"margin: 0; font-size: 14px; color: #71717a;\">Signed by: <strong style=\"color: #3f3f46;\">${delivery.signedBy}</strong></p>\n              </td>\n            </tr>\n            ` : ''}\n            ${delivery.deliveredTo ? `\n            <tr>\n              <td align=\"center\" style=\"padding-top: 8px;\">\n                <p style=\"margin: 0; font-size: 14px; color: #71717a;\">Delivered to: <strong style=\"color: #3f3f46;\">${delivery.deliveredTo}</strong></p>\n              </td>\n            </tr>\n            ` : ''}\n          </table>\n        </td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate delivered items list (compact)\n */\nfunction generateDeliveredItems(items: OrderItem[]): string {\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      ${items.map(item => `\n        <tr>\n          <td style=\"padding: 10px 0; border-bottom: 1px solid #e4e4e7;\">\n            <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n              <tr>\n                ${item.imageUrl ? `\n                <td width=\"50\" valign=\"middle\" style=\"padding-right: 12px;\">\n                  <img src=\"${item.imageUrl}\" alt=\"${item.name}\" width=\"50\" height=\"50\" style=\"border-radius: 4px; object-fit: cover;\">\n                </td>\n                ` : ''}\n                <td valign=\"middle\">\n                  <p style=\"margin: 0; font-size: 15px; color: #18181b;\">${item.name}</p>\n                  ${item.variant ? `<p style=\"margin: 2px 0 0 0; font-size: 13px; color: #71717a;\">${item.variant}</p>` : ''}\n                </td>\n                <td width=\"40\" valign=\"middle\" align=\"right\">\n                  <p style=\"margin: 0; font-size: 14px; color: #71717a;\">x${item.quantity}</p>\n                </td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n      `).join('')}\n    </table>\n  `;\n}\n\n/**\n * Generate review prompt section\n */\nfunction generateReviewPrompt(orderId: string): string {\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0; background-color: #fefce8; border: 1px solid #fef08a; border-radius: 8px;\">\n      <tr>\n        <td style=\"padding: 24px;\">\n          <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n            <tr>\n              <td align=\"center\">\n                <p style=\"margin: 0 0 8px 0; font-size: 24px;\"></p>\n                <p style=\"margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #854d0e;\">How was your experience?</p>\n                <p style=\"margin: 0 0 16px 0; font-size: 14px; color: #713f12;\">We'd love to hear your feedback! Your review helps other shoppers and helps us improve.</p>\n              </td>\n            </tr>\n            <tr>\n              <td align=\"center\">\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n                  <tr>\n                    <td style=\"border-radius: 6px; background-color: #eab308;\">\n                      <a href=\"{{store.url}}/account/orders/${orderId}/review\" style=\"display: inline-block; padding: 12px 24px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 600; color: #ffffff; text-decoration: none; border-radius: 6px;\">\n                        Write a Review\n                      </a>\n                    </td>\n                  </tr>\n                </table>\n              </td>\n            </tr>\n          </table>\n        </td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate delivery confirmation email content\n */\nexport function generateDeliveryConfirmationContent(data: DeliveryData): string {\n  const { order, delivery, customer } = data;\n\n  return `\n    ${emailComponents.heading.h1('Your order has been delivered!')}\n\n    ${emailComponents.paragraph(`Hi ${customer.name},`)}\n\n    ${emailComponents.paragraph(`Great news! Your order #${order.orderNumber} has been delivered. We hope you love your purchase!`)}\n\n    ${generateDeliveryBox(delivery)}\n\n    ${delivery.proofImageUrl ? `\n    ${emailComponents.heading.h3('Delivery Photo')}\n    ${emailComponents.image(delivery.proofImageUrl, 'Delivery proof photo', 400)}\n    ` : ''}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.heading.h2('Items Delivered')}\n\n    ${generateDeliveredItems(order.items)}\n\n    ${emailComponents.heading.h3('Delivered To')}\n\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      <tr>\n        <td style=\"padding: 16px; background-color: #fafafa; border-radius: 6px;\">\n          <p style=\"margin: 0; line-height: 1.6; color: #3f3f46;\">\n            ${delivery.shippingAddress.name}<br>\n            ${delivery.shippingAddress.line1}<br>\n            ${delivery.shippingAddress.line2 ? delivery.shippingAddress.line2 + '<br>' : ''}\n            ${delivery.shippingAddress.city}, ${delivery.shippingAddress.state} ${delivery.shippingAddress.postalCode}<br>\n            ${delivery.shippingAddress.country}\n          </p>\n        </td>\n      </tr>\n    </table>\n\n    ${generateReviewPrompt(order.id)}\n\n    ${emailComponents.infoBox(`\n      <p style=\"margin: 0; font-size: 14px;\">\n        <strong>Didn't receive your package?</strong> If something doesn't look right,\n        please <a href=\"{{store.url}}/support\" style=\"color: #3b82f6; text-decoration: none;\">contact our support team</a>\n        and we'll help resolve the issue.\n      </p>\n    `)}\n\n    ${emailComponents.mutedText('Thank you for shopping with us! We appreciate your business.')}\n  `;\n}\n\n/**\n * Render complete delivery confirmation email\n */\nexport function renderDeliveryConfirmationEmail(\n  data: DeliveryData,\n  store?: Partial<StoreConfig>\n): { html: string; text: string; subject: string } {\n  const content = generateDeliveryConfirmationContent(data);\n\n  const mergeData: Record<string, unknown> = {\n    order: data.order,\n    delivery: data.delivery,\n    customer: data.customer,\n  };\n\n  const html = renderEmail(\n    content,\n    {\n      title: `Your Order #${data.order.orderNumber} Has Been Delivered`,\n      preheader: `Your order has been delivered! We hope you love your purchase.`,\n    },\n    mergeData,\n    { store }\n  );\n\n  const deliveredDate = new Date(data.delivery.deliveredAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  const text = `\nYour order has been delivered!\n\nHi ${data.customer.name},\n\nGreat news! Your order #${data.order.orderNumber} has been delivered. We hope you love your purchase!\n\nDELIVERY DETAILS:\nDelivered on: ${deliveredDate}\n${data.delivery.signedBy ? `Signed by: ${data.delivery.signedBy}` : ''}\n${data.delivery.deliveredTo ? `Delivered to: ${data.delivery.deliveredTo}` : ''}\n\nITEMS DELIVERED:\n${data.order.items.map(item => `- ${item.name}${item.variant ? ` (${item.variant})` : ''} x${item.quantity}`).join('\\n')}\n\nDELIVERED TO:\n${data.delivery.shippingAddress.name}\n${data.delivery.shippingAddress.line1}\n${data.delivery.shippingAddress.line2 ? data.delivery.shippingAddress.line2 + '\\n' : ''}${data.delivery.shippingAddress.city}, ${data.delivery.shippingAddress.state} ${data.delivery.shippingAddress.postalCode}\n${data.delivery.shippingAddress.country}\n\nHOW WAS YOUR EXPERIENCE?\nWe'd love to hear your feedback! Write a review at:\n{{store.url}}/account/orders/${data.order.id}/review\n\nIf something doesn't look right, please contact our support team.\n\nThank you for shopping with us!\n  `.trim();\n\n  return {\n    html,\n    text,\n    subject: `Your Order #${data.order.orderNumber} Has Been Delivered`,\n  };\n}\n","/**\n * Refund Notification Email Template\n *\n * Sent when a refund has been processed for an order.\n * Includes refund details and timeline.\n */\n\nimport { renderEmail, StoreConfig, emailComponents } from './renderer';\nimport { OrderItem } from './order-confirmation';\n\nexport interface RefundData {\n  order: {\n    id: string;\n    orderNumber: string;\n    items: OrderItem[];\n    total: number;\n    currency?: string;\n  };\n  refund: {\n    id: string;\n    amount: number;\n    reason?: string;\n    type: 'full' | 'partial';\n    refundedItems?: OrderItem[];\n    processedAt: Date | string;\n    estimatedArrival?: string;\n    paymentMethod?: string;\n    lastFourDigits?: string;\n  };\n  customer: {\n    name: string;\n    email: string;\n  };\n}\n\n/**\n * Generate refund summary box\n */\nfunction generateRefundBox(refund: RefundData['refund'], currency = 'USD'): string {\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  const processedDate = new Date(refund.processedAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0; background-color: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px;\">\n      <tr>\n        <td style=\"padding: 24px;\">\n          <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n            <tr>\n              <td align=\"center\" style=\"padding-bottom: 16px;\">\n                <p style=\"margin: 0; font-size: 14px; color: #166534; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;\">\n                   Refund Processed\n                </p>\n              </td>\n            </tr>\n            <tr>\n              <td align=\"center\">\n                <p style=\"margin: 0 0 8px 0; font-size: 36px; font-weight: 700; color: #166534;\">${formatPrice(refund.amount)}</p>\n                <p style=\"margin: 0; font-size: 14px; color: #71717a;\">${refund.type === 'full' ? 'Full Refund' : 'Partial Refund'}</p>\n              </td>\n            </tr>\n            <tr>\n              <td style=\"padding-top: 20px;\">\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                  <tr>\n                    <td width=\"50%\" style=\"padding: 8px 0;\">\n                      <p style=\"margin: 0 0 2px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Processed</p>\n                      <p style=\"margin: 0; font-size: 14px; font-weight: 500; color: #3f3f46;\">${processedDate}</p>\n                    </td>\n                    <td width=\"50%\" style=\"padding: 8px 0;\">\n                      <p style=\"margin: 0 0 2px 0; font-size: 12px; color: #71717a; text-transform: uppercase;\">Refund To</p>\n                      <p style=\"margin: 0; font-size: 14px; font-weight: 500; color: #3f3f46;\">\n                        ${refund.paymentMethod || 'Original payment method'}\n                        ${refund.lastFourDigits ? `  ${refund.lastFourDigits}` : ''}\n                      </p>\n                    </td>\n                  </tr>\n                </table>\n              </td>\n            </tr>\n            ${refund.estimatedArrival ? `\n            <tr>\n              <td style=\"padding-top: 16px; border-top: 1px solid #bbf7d0; margin-top: 16px;\">\n                <p style=\"margin: 0; font-size: 14px; color: #71717a;\">\n                  <strong>Estimated arrival:</strong> ${refund.estimatedArrival}\n                </p>\n              </td>\n            </tr>\n            ` : ''}\n          </table>\n        </td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate refunded items list\n */\nfunction generateRefundedItems(items: OrderItem[], currency = 'USD'): string {\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 16px 0;\">\n      ${items.map(item => `\n        <tr>\n          <td style=\"padding: 12px 0; border-bottom: 1px solid #e4e4e7;\">\n            <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n              <tr>\n                ${item.imageUrl ? `\n                <td width=\"50\" valign=\"middle\" style=\"padding-right: 12px;\">\n                  <img src=\"${item.imageUrl}\" alt=\"${item.name}\" width=\"50\" height=\"50\" style=\"border-radius: 4px; object-fit: cover;\">\n                </td>\n                ` : ''}\n                <td valign=\"middle\">\n                  <p style=\"margin: 0; font-size: 15px; color: #18181b;\">${item.name}</p>\n                  ${item.variant ? `<p style=\"margin: 2px 0 0 0; font-size: 13px; color: #71717a;\">${item.variant}</p>` : ''}\n                </td>\n                <td width=\"40\" valign=\"middle\" align=\"center\">\n                  <p style=\"margin: 0; font-size: 14px; color: #71717a;\">x${item.quantity}</p>\n                </td>\n                <td width=\"80\" valign=\"middle\" align=\"right\">\n                  <p style=\"margin: 0; font-size: 14px; font-weight: 500; color: #166534;\">${formatPrice(item.price * item.quantity)}</p>\n                </td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n      `).join('')}\n    </table>\n  `;\n}\n\n/**\n * Generate refund timeline\n */\nfunction generateRefundTimeline(): string {\n  return `\n    <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n      <tr>\n        <td style=\"padding: 20px; background-color: #fafafa; border-radius: 8px;\">\n          <p style=\"margin: 0 0 16px 0; font-weight: 600; color: #18181b;\">When will I receive my refund?</p>\n          <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n            <tr>\n              <td style=\"padding: 8px 0;\">\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                  <tr>\n                    <td width=\"24\" valign=\"top\">\n                      <div style=\"width: 20px; height: 20px; background-color: #22c55e; border-radius: 50%; text-align: center; line-height: 20px; color: white; font-size: 12px;\"></div>\n                    </td>\n                    <td style=\"padding-left: 12px;\">\n                      <p style=\"margin: 0; font-size: 14px; color: #3f3f46;\"><strong>Refund initiated</strong> - We've started processing your refund</p>\n                    </td>\n                  </tr>\n                </table>\n              </td>\n            </tr>\n            <tr>\n              <td style=\"padding: 8px 0;\">\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                  <tr>\n                    <td width=\"24\" valign=\"top\">\n                      <div style=\"width: 20px; height: 20px; background-color: #d4d4d8; border-radius: 50%; text-align: center; line-height: 20px; color: white; font-size: 12px;\">2</div>\n                    </td>\n                    <td style=\"padding-left: 12px;\">\n                      <p style=\"margin: 0; font-size: 14px; color: #71717a;\"><strong>Bank processing</strong> - Your bank will process the refund (1-3 business days)</p>\n                    </td>\n                  </tr>\n                </table>\n              </td>\n            </tr>\n            <tr>\n              <td style=\"padding: 8px 0;\">\n                <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n                  <tr>\n                    <td width=\"24\" valign=\"top\">\n                      <div style=\"width: 20px; height: 20px; background-color: #d4d4d8; border-radius: 50%; text-align: center; line-height: 20px; color: white; font-size: 12px;\">3</div>\n                    </td>\n                    <td style=\"padding-left: 12px;\">\n                      <p style=\"margin: 0; font-size: 14px; color: #71717a;\"><strong>Funds returned</strong> - The refund will appear on your statement (3-10 business days)</p>\n                    </td>\n                  </tr>\n                </table>\n              </td>\n            </tr>\n          </table>\n        </td>\n      </tr>\n    </table>\n  `;\n}\n\n/**\n * Generate refund notification email content\n */\nexport function generateRefundNotificationContent(data: RefundData): string {\n  const { order, refund, customer } = data;\n  const currency = order.currency || 'USD';\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  return `\n    ${emailComponents.heading.h1('Your refund has been processed')}\n\n    ${emailComponents.paragraph(`Hi ${customer.name},`)}\n\n    ${emailComponents.paragraph(\n      refund.type === 'full'\n        ? `We've processed a full refund of ${formatPrice(refund.amount)} for your order #${order.orderNumber}.`\n        : `We've processed a partial refund of ${formatPrice(refund.amount)} for your order #${order.orderNumber}.`\n    )}\n\n    ${generateRefundBox(refund, currency)}\n\n    ${refund.reason ? `\n    ${emailComponents.infoBox(`\n      <p style=\"margin: 0;\"><strong>Refund reason:</strong> ${refund.reason}</p>\n    `)}\n    ` : ''}\n\n    ${refund.refundedItems && refund.refundedItems.length > 0 ? `\n    ${emailComponents.divider()}\n\n    ${emailComponents.heading.h2('Refunded Items')}\n\n    ${generateRefundedItems(refund.refundedItems, currency)}\n    ` : ''}\n\n    ${generateRefundTimeline()}\n\n    ${emailComponents.button('View Order Details', `{{store.url}}/account/orders/${order.id}`)}\n\n    ${emailComponents.divider()}\n\n    ${emailComponents.warningBox(`\n      <p style=\"margin: 0; font-size: 14px;\">\n        <strong>Note:</strong> Refund processing times vary by payment method and bank.\n        If you don't see the refund after 10 business days, please\n        <a href=\"{{store.url}}/support\" style=\"color: #d97706; text-decoration: none;\">contact our support team</a>.\n      </p>\n    `)}\n\n    ${emailComponents.mutedText('We\\'re sorry to see this order returned. If there\\'s anything we could have done better, please let us know.')}\n  `;\n}\n\n/**\n * Render complete refund notification email\n */\nexport function renderRefundNotificationEmail(\n  data: RefundData,\n  store?: Partial<StoreConfig>\n): { html: string; text: string; subject: string } {\n  const content = generateRefundNotificationContent(data);\n  const currency = data.order.currency || 'USD';\n\n  const formatPrice = (amount: number) => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency,\n    }).format(amount / 100);\n  };\n\n  const mergeData: Record<string, unknown> = {\n    order: data.order,\n    refund: data.refund,\n    customer: data.customer,\n  };\n\n  const html = renderEmail(\n    content,\n    {\n      title: `Refund Processed for Order #${data.order.orderNumber}`,\n      preheader: `Your ${formatPrice(data.refund.amount)} refund has been processed and is on its way back to you.`,\n    },\n    mergeData,\n    { store }\n  );\n\n  const processedDate = new Date(data.refund.processedAt).toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n\n  const text = `\nYour refund has been processed\n\nHi ${data.customer.name},\n\n${data.refund.type === 'full'\n  ? `We've processed a full refund of ${formatPrice(data.refund.amount)} for your order #${data.order.orderNumber}.`\n  : `We've processed a partial refund of ${formatPrice(data.refund.amount)} for your order #${data.order.orderNumber}.`\n}\n\nREFUND DETAILS:\nAmount: ${formatPrice(data.refund.amount)}\nType: ${data.refund.type === 'full' ? 'Full Refund' : 'Partial Refund'}\nProcessed: ${processedDate}\nRefund to: ${data.refund.paymentMethod || 'Original payment method'}${data.refund.lastFourDigits ? `  ${data.refund.lastFourDigits}` : ''}\n${data.refund.estimatedArrival ? `Estimated arrival: ${data.refund.estimatedArrival}` : ''}\n\n${data.refund.reason ? `Reason: ${data.refund.reason}` : ''}\n\n${data.refund.refundedItems && data.refund.refundedItems.length > 0 ? `\nREFUNDED ITEMS:\n${data.refund.refundedItems.map(item => `- ${item.name}${item.variant ? ` (${item.variant})` : ''} x${item.quantity} - ${formatPrice(item.price * item.quantity)}`).join('\\n')}\n` : ''}\n\nWHEN WILL I RECEIVE MY REFUND?\n1. Refund initiated - We've started processing your refund\n2. Bank processing - Your bank will process the refund (1-3 business days)\n3. Funds returned - The refund will appear on your statement (3-10 business days)\n\nIf you don't see the refund after 10 business days, please contact our support team.\n\nView your order: {{store.url}}/account/orders/${data.order.id}\n  `.trim();\n\n  return {\n    html,\n    text,\n    subject: `Refund Processed for Order #${data.order.orderNumber}`,\n  };\n}\n","/**\n * Puck Email Template Renderer\n *\n * Renders EmailTemplate records that contain Puck JSON content\n */\n\nimport { prisma } from '../../db';\nimport { parseMergeTags, MergeTagData } from '../merge-tags';\nimport { wrapInBaseTemplate, htmlToPlainText } from './renderer';\nimport { getEmailSettings } from '../../settings';\n\ninterface RenderResult {\n  html: string;\n  text: string;\n  subject?: string;\n}\n\n/**\n * Render an email template by ID with merge data\n */\nexport async function renderEmailTemplate(\n  templateId: string,\n  data: Record<string, unknown>\n): Promise<RenderResult> {\n  const template = await prisma.emailTemplate.findUnique({\n    where: { id: templateId },\n  });\n\n  if (!template) {\n    throw new Error(`Email template not found: ${templateId}`);\n  }\n\n  return renderEmailTemplateData(template, data);\n}\n\n/**\n * Render an email template by slug with merge data\n */\nexport async function renderEmailTemplateBySlug(\n  slug: string,\n  data: Record<string, unknown>\n): Promise<RenderResult | null> {\n  const template = await prisma.emailTemplate.findUnique({\n    where: { slug },\n  });\n\n  if (!template) {\n    return null;\n  }\n\n  return renderEmailTemplateData(template, data);\n}\n\n/**\n * Render template data (internal helper)\n */\nasync function renderEmailTemplateData(\n  template: {\n    subject: string | null;\n    preheader: string | null;\n    content: unknown;\n    html: string | null;\n    name: string;\n  },\n  data: Record<string, unknown>\n): Promise<RenderResult> {\n  const emailSettings = await getEmailSettings();\n\n  // Build merge data with store info\n  const mergeData: MergeTagData = {\n    ...flattenData(data),\n    store: {\n      name: emailSettings.fromName || 'Our Store',\n      email: emailSettings.fromEmail || 'noreply@example.com',\n      url: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n    },\n    currentYear: new Date().getFullYear().toString(),\n  };\n\n  let html: string;\n  let subject = template.subject || template.name;\n\n  // Process subject merge tags\n  subject = parseMergeTags(subject, mergeData);\n\n  // If we have Puck JSON content, render it\n  if (template.content && typeof template.content === 'object') {\n    html = renderPuckContent(template.content as PuckContent, mergeData);\n  } else if (template.html) {\n    // Use pre-rendered HTML\n    html = template.html;\n  } else {\n    // Fallback to empty content\n    html = '<p>No content</p>';\n  }\n\n  // Process merge tags in HTML\n  html = parseMergeTags(html, mergeData);\n\n  // Wrap in base template\n  html = wrapInBaseTemplate(html, {\n    title: subject,\n    preheader: template.preheader ? parseMergeTags(template.preheader, mergeData) : undefined,\n    store: {\n      name: emailSettings.fromName || 'Our Store',\n      url: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n      supportEmail: emailSettings.replyTo || emailSettings.fromEmail || 'support@example.com',\n    },\n  });\n\n  // Generate plain text version\n  const text = htmlToPlainText(html);\n\n  return { html, text, subject };\n}\n\n/**\n * Puck content structure\n */\ninterface PuckContent {\n  content?: PuckComponent[];\n  root?: {\n    props?: Record<string, unknown>;\n  };\n}\n\ninterface PuckComponent {\n  type: string;\n  props?: Record<string, unknown>;\n}\n\n/**\n * Render Puck email content to HTML\n */\nfunction renderPuckContent(content: PuckContent, mergeData: MergeTagData): string {\n  if (!content.content || !Array.isArray(content.content)) {\n    return '';\n  }\n\n  return content.content\n    .map((component) => renderPuckComponent(component, mergeData))\n    .join('\\n');\n}\n\n/**\n * Render individual Puck component to HTML\n */\nfunction renderPuckComponent(component: PuckComponent, mergeData: MergeTagData): string {\n  const props = component.props || {};\n\n  switch (component.type) {\n    case 'Heading':\n      const level = props.level || 'h1';\n      const headingText = parseMergeTags(String(props.text || ''), mergeData);\n      return `<${level} style=\"color: #333; margin: 0 0 16px 0;\">${headingText}</${level}>`;\n\n    case 'Text':\n    case 'Paragraph':\n      const text = parseMergeTags(String(props.text || props.content || ''), mergeData);\n      return `<p style=\"color: #333; line-height: 1.6; margin: 0 0 16px 0;\">${text}</p>`;\n\n    case 'Button':\n      const buttonText = parseMergeTags(String(props.label || props.text || 'Click Here'), mergeData);\n      const buttonUrl = parseMergeTags(String(props.url || props.href || '#'), mergeData);\n      const buttonColor = props.color || '#000';\n      return `\n        <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"margin: 16px 0;\">\n          <tr>\n            <td style=\"background-color: ${buttonColor}; border-radius: 6px; padding: 12px 24px;\">\n              <a href=\"${buttonUrl}\" style=\"color: #ffffff; text-decoration: none; font-weight: 600;\">${buttonText}</a>\n            </td>\n          </tr>\n        </table>\n      `;\n\n    case 'Image':\n      const src = parseMergeTags(String(props.src || props.url || ''), mergeData);\n      const alt = parseMergeTags(String(props.alt || ''), mergeData);\n      const width = props.width || '100%';\n      return `<img src=\"${src}\" alt=\"${alt}\" width=\"${width}\" style=\"max-width: 100%; height: auto; margin: 16px 0; border-radius: 8px;\" />`;\n\n    case 'Divider':\n      return '<hr style=\"border: none; border-top: 1px solid #eee; margin: 24px 0;\" />';\n\n    case 'Spacer':\n      const height = props.height || 24;\n      return `<div style=\"height: ${height}px;\"></div>`;\n\n    case 'Card':\n    case 'Box':\n      const cardContent = props.content ? renderPuckContent(props.content as PuckContent, mergeData) : '';\n      return `<div style=\"background: #f9f9f9; border-radius: 8px; padding: 24px; margin: 16px 0;\">${cardContent}</div>`;\n\n    case 'Table':\n      // Render data table\n      const rows = (props.rows || props.data) as Array<Record<string, string>> || [];\n      if (rows.length === 0) return '';\n\n      const tableRows = rows\n        .map((row) => {\n          const cells = Object.entries(row)\n            .map(([key, value]) => `<td style=\"padding: 8px; border-bottom: 1px solid #eee;\">${parseMergeTags(String(value), mergeData)}</td>`)\n            .join('');\n          return `<tr>${cells}</tr>`;\n        })\n        .join('');\n\n      return `<table style=\"width: 100%; border-collapse: collapse; margin: 16px 0;\"><tbody>${tableRows}</tbody></table>`;\n\n    case 'OrderSummary':\n    case 'SubmissionData':\n      // Render dynamic data from merge tags\n      const dataKey = typeof props.dataKey === 'string' ? props.dataKey : 'submission.fields';\n      const fields = getNestedValue(mergeData, dataKey) as Array<{ label: string; value: string }> || [];\n\n      if (!Array.isArray(fields) || fields.length === 0) return '';\n\n      const summaryRows = fields\n        .map((field) => `\n          <tr>\n            <td style=\"padding: 8px; border-bottom: 1px solid #eee; font-weight: 500;\">${field.label}</td>\n            <td style=\"padding: 8px; border-bottom: 1px solid #eee;\">${field.value}</td>\n          </tr>\n        `)\n        .join('');\n\n      return `<table style=\"width: 100%; border-collapse: collapse; margin: 16px 0;\"><tbody>${summaryRows}</tbody></table>`;\n\n    default:\n      // Unknown component - try to render children or return empty\n      if (props.children && typeof props.children === 'string') {\n        return `<div>${parseMergeTags(props.children, mergeData)}</div>`;\n      }\n      return '';\n  }\n}\n\n/**\n * Flatten nested object for merge tag access\n */\nfunction flattenData(data: Record<string, unknown>, prefix = ''): MergeTagData {\n  const result: MergeTagData = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const fullKey = prefix ? `${prefix}.${key}` : key;\n\n    if (value === null || value === undefined) {\n      result[fullKey] = '';\n    } else if (typeof value === 'object' && !Array.isArray(value)) {\n      Object.assign(result, flattenData(value as Record<string, unknown>, fullKey));\n      result[fullKey] = value as MergeTagData;\n    } else if (Array.isArray(value)) {\n      result[fullKey] = value as MergeTagData[];\n    } else {\n      result[fullKey] = value as string | number | boolean;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get nested value from object using dot notation\n */\nfunction getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n  return path.split('.').reduce((current, key) => {\n    if (current && typeof current === 'object') {\n      return (current as Record<string, unknown>)[key];\n    }\n    return undefined;\n  }, obj as unknown);\n}\n","/**\n * Transactional Notifications Service\n *\n * Sends order lifecycle emails by fetching order data and using email templates.\n * Integrates with Stripe/Shippo webhooks for automatic notifications.\n *\n * Supports Puck-editable templates - falls back to hardcoded templates if not found.\n */\n\nimport { prisma } from '../db';\nimport { sendEmail } from '../email';\nimport { getEmailSettings } from '../settings';\nimport {\n  renderOrderConfirmationEmail,\n  renderShippingNotificationEmail,\n  renderDeliveryConfirmationEmail,\n  renderRefundNotificationEmail,\n  type OrderConfirmationData,\n  type ShipmentData,\n  type DeliveryData,\n  type RefundData,\n} from '../email/templates';\nimport { renderEmailTemplateBySlug } from '../email/templates/render';\n\nexport interface NotificationResult {\n  success: boolean;\n  messageId?: string;\n  error?: string;\n}\n\n/**\n * Get store configuration for email templates\n */\nasync function getStoreConfig() {\n  const settings = await getEmailSettings();\n  return {\n    name: settings.fromName || 'Our Store',\n    url: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n    supportEmail: settings.replyTo || settings.fromEmail,\n    logoUrl: process.env.NEXT_PUBLIC_LOGO_URL,\n  };\n}\n\n/**\n * Format address from Prisma Address model\n */\nfunction formatAddress(address: {\n  firstName: string;\n  lastName: string;\n  street1: string;\n  street2: string | null;\n  city: string;\n  state: string;\n  zip: string;\n  country: string;\n} | null) {\n  if (!address) {\n    return {\n      name: '',\n      line1: '',\n      city: '',\n      state: '',\n      postalCode: '',\n      country: 'US',\n    };\n  }\n  return {\n    name: `${address.firstName} ${address.lastName}`.trim(),\n    line1: address.street1,\n    line2: address.street2 || undefined,\n    city: address.city,\n    state: address.state,\n    postalCode: address.zip,\n    country: address.country,\n  };\n}\n\n/**\n * Get customer name from address or customer\n */\nfunction getCustomerName(\n  address: { firstName: string; lastName: string } | null | undefined,\n  customer: { firstName: string | null; lastName: string | null } | null | undefined\n): string {\n  if (address) {\n    return `${address.firstName} ${address.lastName}`.trim() || 'Customer';\n  }\n  if (customer) {\n    const name = [customer.firstName, customer.lastName].filter(Boolean).join(' ');\n    return name || 'Customer';\n  }\n  return 'Customer';\n}\n\n/**\n * Send order confirmation email\n */\nexport async function sendOrderConfirmation(orderId: string): Promise<NotificationResult> {\n  try {\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      include: {\n        items: {\n          include: {\n            product: {\n              include: {\n                images: {\n                  include: {\n                    media: true,\n                  },\n                  orderBy: { position: 'asc' },\n                  take: 1,\n                },\n              },\n            },\n          },\n        },\n        customer: true,\n        shippingAddress: true,\n        billingAddress: true,\n      },\n    });\n\n    if (!order) {\n      return { success: false, error: 'Order not found' };\n    }\n\n    const customerEmail = order.email || order.customer?.email;\n    if (!customerEmail) {\n      return { success: false, error: 'No customer email' };\n    }\n\n    const data: OrderConfirmationData = {\n      order: {\n        id: order.id,\n        orderNumber: order.orderNumber,\n        createdAt: order.createdAt,\n        items: order.items.map((item) => ({\n          id: item.id,\n          name: item.product?.title || item.title || 'Product',\n          variant: item.variantTitle || undefined,\n          quantity: item.quantity,\n          price: item.price, // Already in cents\n          imageUrl: item.product?.images?.[0]?.media?.url || undefined,\n        })),\n        subtotal: order.subtotal,\n        shipping: order.shippingTotal,\n        tax: order.taxTotal,\n        discount: order.discountTotal > 0 ? order.discountTotal : undefined,\n        total: order.total,\n        currency: 'USD', // Default currency\n        paymentMethod: 'Credit Card',\n        shippingAddress: formatAddress(order.shippingAddress),\n        billingAddress: order.billingAddress\n          ? formatAddress(order.billingAddress)\n          : undefined,\n        shippingMethod: undefined,\n        notes: order.customerNotes || undefined,\n      },\n      customer: {\n        name: getCustomerName(order.shippingAddress, order.customer),\n        email: customerEmail,\n      },\n    };\n\n    const store = await getStoreConfig();\n\n    // Try Puck template first, fall back to hardcoded\n    let html: string;\n    let text: string;\n    let subject: string;\n\n    const puckResult = await renderEmailTemplateBySlug('order-confirmation', {\n      order: data.order,\n      customer: data.customer,\n    });\n\n    if (puckResult) {\n      html = puckResult.html;\n      text = puckResult.text;\n      subject = puckResult.subject || `Order Confirmation #${data.order.orderNumber}`;\n    } else {\n      const fallback = renderOrderConfirmationEmail(data, store);\n      html = fallback.html;\n      text = fallback.text;\n      subject = fallback.subject;\n    }\n\n    const result = await sendEmail({\n      to: { email: customerEmail, name: data.customer.name },\n      subject,\n      html,\n      text,\n      metadata: {\n        orderId: order.id,\n        orderNumber: order.orderNumber,\n        type: 'order_confirmation',\n      },\n    });\n\n    return { success: result.success, messageId: result.messageId, error: result.error };\n  } catch (error) {\n    console.error('Error sending order confirmation:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Send shipping notification email\n */\nexport async function sendShippingNotification(\n  orderId: string,\n  shipmentId: string\n): Promise<NotificationResult> {\n  try {\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      include: {\n        items: {\n          include: {\n            product: {\n              include: {\n                images: {\n                  include: {\n                    media: true,\n                  },\n                  orderBy: { position: 'asc' },\n                  take: 1,\n                },\n              },\n            },\n          },\n        },\n        customer: true,\n        shippingAddress: true,\n      },\n    });\n\n    if (!order) {\n      return { success: false, error: 'Order not found' };\n    }\n\n    const shipment = await prisma.shipment.findUnique({\n      where: { id: shipmentId },\n    });\n\n    if (!shipment) {\n      return { success: false, error: 'Shipment not found' };\n    }\n\n    const customerEmail = order.email || order.customer?.email;\n    if (!customerEmail) {\n      return { success: false, error: 'No customer email' };\n    }\n\n    const data: ShipmentData = {\n      order: {\n        id: order.id,\n        orderNumber: order.orderNumber,\n        items: order.items.map((item) => ({\n          id: item.id,\n          name: item.product?.title || item.title || 'Product',\n          variant: item.variantTitle || undefined,\n          quantity: item.quantity,\n          price: item.price, // Already in cents\n          imageUrl: item.product?.images?.[0]?.media?.url || undefined,\n        })),\n      },\n      shipment: {\n        id: shipment.id,\n        carrier: shipment.carrier || 'Unknown',\n        carrierName: getCarrierName(shipment.carrier || ''),\n        trackingNumber: shipment.trackingNumber || '',\n        trackingUrl: shipment.trackingUrl || undefined,\n        shippedAt: shipment.shippedAt || new Date(),\n        estimatedDelivery: undefined, // Not available in schema\n        shippingAddress: formatAddress(order.shippingAddress),\n      },\n      customer: {\n        name: getCustomerName(order.shippingAddress, order.customer),\n        email: customerEmail,\n      },\n    };\n\n    const store = await getStoreConfig();\n\n    // Try Puck template first, fall back to hardcoded\n    let html: string;\n    let text: string;\n    let subject: string;\n\n    const puckResult = await renderEmailTemplateBySlug('shipping-notification', {\n      order: data.order,\n      shipment: data.shipment,\n      customer: data.customer,\n    });\n\n    if (puckResult) {\n      html = puckResult.html;\n      text = puckResult.text;\n      subject = puckResult.subject || `Your order #${data.order.orderNumber} has shipped!`;\n    } else {\n      const fallback = renderShippingNotificationEmail(data, store);\n      html = fallback.html;\n      text = fallback.text;\n      subject = fallback.subject;\n    }\n\n    const result = await sendEmail({\n      to: { email: customerEmail, name: data.customer.name },\n      subject,\n      html,\n      text,\n      metadata: {\n        orderId: order.id,\n        orderNumber: order.orderNumber,\n        shipmentId: shipment.id,\n        type: 'shipping_notification',\n      },\n    });\n\n    return { success: result.success, messageId: result.messageId, error: result.error };\n  } catch (error) {\n    console.error('Error sending shipping notification:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Send delivery confirmation email\n */\nexport async function sendDeliveryConfirmation(\n  orderId: string,\n  shipmentId: string\n): Promise<NotificationResult> {\n  try {\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      include: {\n        items: {\n          include: {\n            product: {\n              include: {\n                images: {\n                  include: {\n                    media: true,\n                  },\n                  orderBy: { position: 'asc' },\n                  take: 1,\n                },\n              },\n            },\n          },\n        },\n        customer: true,\n        shippingAddress: true,\n      },\n    });\n\n    if (!order) {\n      return { success: false, error: 'Order not found' };\n    }\n\n    const shipment = await prisma.shipment.findUnique({\n      where: { id: shipmentId },\n    });\n\n    if (!shipment) {\n      return { success: false, error: 'Shipment not found' };\n    }\n\n    const customerEmail = order.email || order.customer?.email;\n    if (!customerEmail) {\n      return { success: false, error: 'No customer email' };\n    }\n\n    const data: DeliveryData = {\n      order: {\n        id: order.id,\n        orderNumber: order.orderNumber,\n        items: order.items.map((item) => ({\n          id: item.id,\n          name: item.product?.title || item.title || 'Product',\n          variant: item.variantTitle || undefined,\n          quantity: item.quantity,\n          price: item.price, // Already in cents\n          imageUrl: item.product?.images?.[0]?.media?.url || undefined,\n        })),\n      },\n      delivery: {\n        deliveredAt: shipment.deliveredAt || new Date(),\n        signedBy: undefined, // Not tracked in schema\n        shippingAddress: formatAddress(order.shippingAddress),\n      },\n      customer: {\n        name: getCustomerName(order.shippingAddress, order.customer),\n        email: customerEmail,\n      },\n    };\n\n    const store = await getStoreConfig();\n\n    // Try Puck template first, fall back to hardcoded\n    let html: string;\n    let text: string;\n    let subject: string;\n\n    const puckResult = await renderEmailTemplateBySlug('delivery-confirmation', {\n      order: data.order,\n      delivery: data.delivery,\n      customer: data.customer,\n    });\n\n    if (puckResult) {\n      html = puckResult.html;\n      text = puckResult.text;\n      subject = puckResult.subject || `Your order #${data.order.orderNumber} has been delivered!`;\n    } else {\n      const fallback = renderDeliveryConfirmationEmail(data, store);\n      html = fallback.html;\n      text = fallback.text;\n      subject = fallback.subject;\n    }\n\n    const result = await sendEmail({\n      to: { email: customerEmail, name: data.customer.name },\n      subject,\n      html,\n      text,\n      metadata: {\n        orderId: order.id,\n        orderNumber: order.orderNumber,\n        shipmentId: shipment.id,\n        type: 'delivery_confirmation',\n      },\n    });\n\n    return { success: result.success, messageId: result.messageId, error: result.error };\n  } catch (error) {\n    console.error('Error sending delivery confirmation:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Send refund notification email\n */\nexport async function sendRefundNotification(\n  orderId: string,\n  refundAmount: number, // In cents\n  refundReason?: string,\n  isFullRefund = true\n): Promise<NotificationResult> {\n  try {\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      include: {\n        items: {\n          include: {\n            product: {\n              include: {\n                images: {\n                  include: {\n                    media: true,\n                  },\n                  orderBy: { position: 'asc' },\n                  take: 1,\n                },\n              },\n            },\n          },\n        },\n        customer: true,\n      },\n    });\n\n    if (!order) {\n      return { success: false, error: 'Order not found' };\n    }\n\n    const customerEmail = order.email || order.customer?.email;\n    if (!customerEmail) {\n      return { success: false, error: 'No customer email' };\n    }\n\n    const data: RefundData = {\n      order: {\n        id: order.id,\n        orderNumber: order.orderNumber,\n        total: order.total, // Already in cents\n        currency: 'USD',\n        items: order.items.map((item) => ({\n          id: item.id,\n          name: item.product?.title || item.title || 'Product',\n          variant: item.variantTitle || undefined,\n          quantity: item.quantity,\n          price: item.price, // Already in cents\n          imageUrl: item.product?.images?.[0]?.media?.url || undefined,\n        })),\n      },\n      refund: {\n        id: `refund_${Date.now()}`,\n        amount: refundAmount, // Already in cents\n        reason: refundReason,\n        type: isFullRefund ? 'full' : 'partial',\n        processedAt: new Date(),\n        paymentMethod: 'Original payment method',\n        estimatedArrival: '5-10 business days',\n      },\n      customer: {\n        name: order.customer ? [order.customer.firstName, order.customer.lastName].filter(Boolean).join(' ') || 'Customer' : 'Customer',\n        email: customerEmail,\n      },\n    };\n\n    const store = await getStoreConfig();\n\n    // Try Puck template first, fall back to hardcoded\n    let html: string;\n    let text: string;\n    let subject: string;\n\n    const puckResult = await renderEmailTemplateBySlug('refund-notification', {\n      order: data.order,\n      refund: data.refund,\n      customer: data.customer,\n    });\n\n    if (puckResult) {\n      html = puckResult.html;\n      text = puckResult.text;\n      subject = puckResult.subject || `Refund processed for order #${data.order.orderNumber}`;\n    } else {\n      const fallback = renderRefundNotificationEmail(data, store);\n      html = fallback.html;\n      text = fallback.text;\n      subject = fallback.subject;\n    }\n\n    const result = await sendEmail({\n      to: { email: customerEmail, name: data.customer.name },\n      subject,\n      html,\n      text,\n      metadata: {\n        orderId: order.id,\n        orderNumber: order.orderNumber,\n        type: 'refund_notification',\n      },\n    });\n\n    return { success: result.success, messageId: result.messageId, error: result.error };\n  } catch (error) {\n    console.error('Error sending refund notification:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Helper to get friendly carrier name\n */\nfunction getCarrierName(carrier: string): string {\n  const names: Record<string, string> = {\n    usps: 'USPS',\n    ups: 'UPS',\n    fedex: 'FedEx',\n    dhl: 'DHL',\n    fedex_ground: 'FedEx Ground',\n    fedex_express: 'FedEx Express',\n    ups_ground: 'UPS Ground',\n    usps_priority: 'USPS Priority Mail',\n    usps_express: 'USPS Express',\n  };\n  return names[carrier.toLowerCase()] || carrier;\n}\n\nexport * from './types';\n","/**\n * Permission Constants\n * Defines all available permissions in the system\n */\n\n// Permission string format: \"resource.action\"\n// Wildcard support: \"resource.*\" or \"*\" (super admin)\n\nexport const PERMISSIONS = {\n  // Products\n  PRODUCTS_VIEW: 'products.view',\n  PRODUCTS_CREATE: 'products.create',\n  PRODUCTS_EDIT: 'products.edit',\n  PRODUCTS_DELETE: 'products.delete',\n  PRODUCTS_PUBLISH: 'products.publish',\n  PRODUCTS_ALL: 'products.*',\n\n  // Product Variants\n  VARIANTS_VIEW: 'variants.view',\n  VARIANTS_CREATE: 'variants.create',\n  VARIANTS_EDIT: 'variants.edit',\n  VARIANTS_DELETE: 'variants.delete',\n  VARIANTS_ALL: 'variants.*',\n\n  // Orders\n  ORDERS_VIEW: 'orders.view',\n  ORDERS_CREATE: 'orders.create',\n  ORDERS_EDIT: 'orders.edit',\n  ORDERS_DELETE: 'orders.delete',\n  ORDERS_FULFILL: 'orders.fulfill',\n  ORDERS_REFUND: 'orders.refund',\n  ORDERS_CANCEL: 'orders.cancel',\n  ORDERS_ALL: 'orders.*',\n\n  // Inventory\n  INVENTORY_VIEW: 'inventory.view',\n  INVENTORY_EDIT: 'inventory.edit',\n  INVENTORY_ALL: 'inventory.*',\n\n  // Customers\n  CUSTOMERS_VIEW: 'customers.view',\n  CUSTOMERS_CREATE: 'customers.create',\n  CUSTOMERS_EDIT: 'customers.edit',\n  CUSTOMERS_DELETE: 'customers.delete',\n  CUSTOMERS_EXPORT: 'customers.export',\n  CUSTOMERS_ALL: 'customers.*',\n\n  // Content - Pages\n  PAGES_VIEW: 'pages.view',\n  PAGES_CREATE: 'pages.create',\n  PAGES_EDIT: 'pages.edit',\n  PAGES_DELETE: 'pages.delete',\n  PAGES_PUBLISH: 'pages.publish',\n  PAGES_ALL: 'pages.*',\n\n  // Puck Templates\n  PUCK_TEMPLATES_VIEW: 'puck_templates.view',\n  PUCK_TEMPLATES_CREATE: 'puck_templates.create',\n  PUCK_TEMPLATES_EDIT: 'puck_templates.edit',\n  PUCK_TEMPLATES_DELETE: 'puck_templates.delete',\n  PUCK_TEMPLATES_ALL: 'puck_templates.*',\n\n  // Routes Configuration\n  ROUTES_VIEW: 'routes.view',\n  ROUTES_CREATE: 'routes.create',\n  ROUTES_EDIT: 'routes.edit',\n  ROUTES_DELETE: 'routes.delete',\n  ROUTES_ALL: 'routes.*',\n\n  // Content - Blog\n  BLOG_VIEW: 'blog.view',\n  BLOG_CREATE: 'blog.create',\n  BLOG_EDIT: 'blog.edit',\n  BLOG_DELETE: 'blog.delete',\n  BLOG_PUBLISH: 'blog.publish',\n  BLOG_ALL: 'blog.*',\n\n  // Media\n  MEDIA_VIEW: 'media.view',\n  MEDIA_UPLOAD: 'media.upload',\n  MEDIA_EDIT: 'media.edit',\n  MEDIA_DELETE: 'media.delete',\n  MEDIA_ALL: 'media.*',\n\n  // Categories\n  CATEGORIES_VIEW: 'categories.view',\n  CATEGORIES_CREATE: 'categories.create',\n  CATEGORIES_EDIT: 'categories.edit',\n  CATEGORIES_DELETE: 'categories.delete',\n  CATEGORIES_ALL: 'categories.*',\n\n  // Custom Fields\n  CUSTOM_FIELDS_VIEW: 'custom_fields.view',\n  CUSTOM_FIELDS_CREATE: 'custom_fields.create',\n  CUSTOM_FIELDS_EDIT: 'custom_fields.edit',\n  CUSTOM_FIELDS_DELETE: 'custom_fields.delete',\n  CUSTOM_FIELDS_ALL: 'custom_fields.*',\n\n  // Settings\n  SETTINGS_VIEW: 'settings.view',\n  SETTINGS_GENERAL: 'settings.general',\n  SETTINGS_PAYMENTS: 'settings.payments',\n  SETTINGS_SHIPPING: 'settings.shipping',\n  SETTINGS_TAXES: 'settings.taxes',\n  SETTINGS_EMAIL: 'settings.email',\n  SETTINGS_STORAGE: 'settings.storage',\n  SETTINGS_AI: 'settings.ai',\n  SETTINGS_ALL: 'settings.*',\n\n  // Users & Roles\n  USERS_VIEW: 'users.view',\n  USERS_CREATE: 'users.create',\n  USERS_EDIT: 'users.edit',\n  USERS_DELETE: 'users.delete',\n  USERS_ROLES: 'users.roles', // Manage role assignments\n  USERS_PERMISSIONS: 'users.permissions', // Manage permission overrides\n  USERS_ALL: 'users.*',\n\n  // Roles Management\n  ROLES_VIEW: 'roles.view',\n  ROLES_CREATE: 'roles.create',\n  ROLES_EDIT: 'roles.edit',\n  ROLES_DELETE: 'roles.delete',\n  ROLES_ALL: 'roles.*',\n\n  // Analytics\n  ANALYTICS_VIEW: 'analytics.view',\n  ANALYTICS_EXPORT: 'analytics.export',\n  ANALYTICS_ALL: 'analytics.*',\n\n  // Plugins & Workflows\n  PLUGINS_VIEW: 'plugins.view',\n  PLUGINS_INSTALL: 'plugins.install',\n  PLUGINS_CONFIGURE: 'plugins.configure',\n  PLUGINS_DELETE: 'plugins.delete',\n  PLUGINS_ALL: 'plugins.*',\n\n  WORKFLOWS_VIEW: 'workflows.view',\n  WORKFLOWS_CREATE: 'workflows.create',\n  WORKFLOWS_EDIT: 'workflows.edit',\n  WORKFLOWS_DELETE: 'workflows.delete',\n  WORKFLOWS_EXECUTE: 'workflows.execute',\n  WORKFLOWS_ALL: 'workflows.*',\n\n  // Forms\n  FORMS_VIEW: 'forms.view',\n  FORMS_CREATE: 'forms.create',\n  FORMS_EDIT: 'forms.edit',\n  FORMS_DELETE: 'forms.delete',\n  FORMS_SUBMISSIONS: 'forms.submissions',\n  FORMS_ALL: 'forms.*',\n\n  // Email Campaigns\n  EMAIL_VIEW: 'email.view',\n  EMAIL_CREATE: 'email.create',\n  EMAIL_EDIT: 'email.edit',\n  EMAIL_DELETE: 'email.delete',\n  EMAIL_SEND: 'email.send',\n  EMAIL_ALL: 'email.*',\n\n  // Audit Log\n  AUDIT_VIEW: 'audit.view',\n\n  // Super Admin (all permissions)\n  SUPER_ADMIN: '*',\n} as const\n\nexport type Permission = (typeof PERMISSIONS)[keyof typeof PERMISSIONS]\n\n// Permission groups for UI display\nexport const PERMISSION_GROUPS = {\n  products: {\n    label: 'Products',\n    permissions: [\n      { key: PERMISSIONS.PRODUCTS_VIEW, label: 'View products' },\n      { key: PERMISSIONS.PRODUCTS_CREATE, label: 'Create products' },\n      { key: PERMISSIONS.PRODUCTS_EDIT, label: 'Edit products' },\n      { key: PERMISSIONS.PRODUCTS_DELETE, label: 'Delete products' },\n      { key: PERMISSIONS.PRODUCTS_PUBLISH, label: 'Publish/unpublish products' },\n    ],\n  },\n  variants: {\n    label: 'Product Variants',\n    permissions: [\n      { key: PERMISSIONS.VARIANTS_VIEW, label: 'View variants' },\n      { key: PERMISSIONS.VARIANTS_CREATE, label: 'Create variants' },\n      { key: PERMISSIONS.VARIANTS_EDIT, label: 'Edit variants' },\n      { key: PERMISSIONS.VARIANTS_DELETE, label: 'Delete variants' },\n    ],\n  },\n  orders: {\n    label: 'Orders',\n    permissions: [\n      { key: PERMISSIONS.ORDERS_VIEW, label: 'View orders' },\n      { key: PERMISSIONS.ORDERS_CREATE, label: 'Create orders' },\n      { key: PERMISSIONS.ORDERS_EDIT, label: 'Edit orders' },\n      { key: PERMISSIONS.ORDERS_DELETE, label: 'Delete orders' },\n      { key: PERMISSIONS.ORDERS_FULFILL, label: 'Fulfill orders' },\n      { key: PERMISSIONS.ORDERS_REFUND, label: 'Process refunds' },\n      { key: PERMISSIONS.ORDERS_CANCEL, label: 'Cancel orders' },\n    ],\n  },\n  inventory: {\n    label: 'Inventory',\n    permissions: [\n      { key: PERMISSIONS.INVENTORY_VIEW, label: 'View inventory' },\n      { key: PERMISSIONS.INVENTORY_EDIT, label: 'Edit inventory' },\n    ],\n  },\n  customers: {\n    label: 'Customers',\n    permissions: [\n      { key: PERMISSIONS.CUSTOMERS_VIEW, label: 'View customers' },\n      { key: PERMISSIONS.CUSTOMERS_CREATE, label: 'Create customers' },\n      { key: PERMISSIONS.CUSTOMERS_EDIT, label: 'Edit customers' },\n      { key: PERMISSIONS.CUSTOMERS_DELETE, label: 'Delete customers' },\n      { key: PERMISSIONS.CUSTOMERS_EXPORT, label: 'Export customer data' },\n    ],\n  },\n  pages: {\n    label: 'Pages',\n    permissions: [\n      { key: PERMISSIONS.PAGES_VIEW, label: 'View pages' },\n      { key: PERMISSIONS.PAGES_CREATE, label: 'Create pages' },\n      { key: PERMISSIONS.PAGES_EDIT, label: 'Edit pages' },\n      { key: PERMISSIONS.PAGES_DELETE, label: 'Delete pages' },\n      { key: PERMISSIONS.PAGES_PUBLISH, label: 'Publish pages' },\n    ],\n  },\n  puck_templates: {\n    label: 'Page Templates',\n    permissions: [\n      { key: PERMISSIONS.PUCK_TEMPLATES_VIEW, label: 'View templates' },\n      { key: PERMISSIONS.PUCK_TEMPLATES_CREATE, label: 'Create templates' },\n      { key: PERMISSIONS.PUCK_TEMPLATES_EDIT, label: 'Edit templates' },\n      { key: PERMISSIONS.PUCK_TEMPLATES_DELETE, label: 'Delete templates' },\n    ],\n  },\n  routes: {\n    label: 'Route Configuration',\n    permissions: [\n      { key: PERMISSIONS.ROUTES_VIEW, label: 'View routes' },\n      { key: PERMISSIONS.ROUTES_CREATE, label: 'Create routes' },\n      { key: PERMISSIONS.ROUTES_EDIT, label: 'Edit routes' },\n      { key: PERMISSIONS.ROUTES_DELETE, label: 'Delete routes' },\n    ],\n  },\n  blog: {\n    label: 'Blog',\n    permissions: [\n      { key: PERMISSIONS.BLOG_VIEW, label: 'View blog posts' },\n      { key: PERMISSIONS.BLOG_CREATE, label: 'Create blog posts' },\n      { key: PERMISSIONS.BLOG_EDIT, label: 'Edit blog posts' },\n      { key: PERMISSIONS.BLOG_DELETE, label: 'Delete blog posts' },\n      { key: PERMISSIONS.BLOG_PUBLISH, label: 'Publish blog posts' },\n    ],\n  },\n  media: {\n    label: 'Media',\n    permissions: [\n      { key: PERMISSIONS.MEDIA_VIEW, label: 'View media' },\n      { key: PERMISSIONS.MEDIA_UPLOAD, label: 'Upload media' },\n      { key: PERMISSIONS.MEDIA_EDIT, label: 'Edit media' },\n      { key: PERMISSIONS.MEDIA_DELETE, label: 'Delete media' },\n    ],\n  },\n  categories: {\n    label: 'Categories',\n    permissions: [\n      { key: PERMISSIONS.CATEGORIES_VIEW, label: 'View categories' },\n      { key: PERMISSIONS.CATEGORIES_CREATE, label: 'Create categories' },\n      { key: PERMISSIONS.CATEGORIES_EDIT, label: 'Edit categories' },\n      { key: PERMISSIONS.CATEGORIES_DELETE, label: 'Delete categories' },\n    ],\n  },\n  settings: {\n    label: 'Settings',\n    permissions: [\n      { key: PERMISSIONS.SETTINGS_VIEW, label: 'View settings' },\n      { key: PERMISSIONS.SETTINGS_GENERAL, label: 'General settings' },\n      { key: PERMISSIONS.SETTINGS_PAYMENTS, label: 'Payment settings' },\n      { key: PERMISSIONS.SETTINGS_SHIPPING, label: 'Shipping settings' },\n      { key: PERMISSIONS.SETTINGS_TAXES, label: 'Tax settings' },\n      { key: PERMISSIONS.SETTINGS_EMAIL, label: 'Email settings' },\n      { key: PERMISSIONS.SETTINGS_STORAGE, label: 'Storage settings' },\n      { key: PERMISSIONS.SETTINGS_AI, label: 'AI settings' },\n    ],\n  },\n  users: {\n    label: 'User Management',\n    permissions: [\n      { key: PERMISSIONS.USERS_VIEW, label: 'View users' },\n      { key: PERMISSIONS.USERS_CREATE, label: 'Create users' },\n      { key: PERMISSIONS.USERS_EDIT, label: 'Edit users' },\n      { key: PERMISSIONS.USERS_DELETE, label: 'Delete users' },\n      { key: PERMISSIONS.USERS_ROLES, label: 'Manage user roles' },\n      { key: PERMISSIONS.USERS_PERMISSIONS, label: 'Manage user permissions' },\n    ],\n  },\n  roles: {\n    label: 'Role Management',\n    permissions: [\n      { key: PERMISSIONS.ROLES_VIEW, label: 'View roles' },\n      { key: PERMISSIONS.ROLES_CREATE, label: 'Create roles' },\n      { key: PERMISSIONS.ROLES_EDIT, label: 'Edit roles' },\n      { key: PERMISSIONS.ROLES_DELETE, label: 'Delete roles' },\n    ],\n  },\n  analytics: {\n    label: 'Analytics',\n    permissions: [\n      { key: PERMISSIONS.ANALYTICS_VIEW, label: 'View analytics' },\n      { key: PERMISSIONS.ANALYTICS_EXPORT, label: 'Export analytics' },\n    ],\n  },\n  plugins: {\n    label: 'Plugins',\n    permissions: [\n      { key: PERMISSIONS.PLUGINS_VIEW, label: 'View plugins' },\n      { key: PERMISSIONS.PLUGINS_INSTALL, label: 'Install plugins' },\n      { key: PERMISSIONS.PLUGINS_CONFIGURE, label: 'Configure plugins' },\n      { key: PERMISSIONS.PLUGINS_DELETE, label: 'Delete plugins' },\n    ],\n  },\n  workflows: {\n    label: 'Workflows',\n    permissions: [\n      { key: PERMISSIONS.WORKFLOWS_VIEW, label: 'View workflows' },\n      { key: PERMISSIONS.WORKFLOWS_CREATE, label: 'Create workflows' },\n      { key: PERMISSIONS.WORKFLOWS_EDIT, label: 'Edit workflows' },\n      { key: PERMISSIONS.WORKFLOWS_DELETE, label: 'Delete workflows' },\n      { key: PERMISSIONS.WORKFLOWS_EXECUTE, label: 'Execute workflows' },\n    ],\n  },\n  forms: {\n    label: 'Forms',\n    permissions: [\n      { key: PERMISSIONS.FORMS_VIEW, label: 'View forms' },\n      { key: PERMISSIONS.FORMS_CREATE, label: 'Create forms' },\n      { key: PERMISSIONS.FORMS_EDIT, label: 'Edit forms' },\n      { key: PERMISSIONS.FORMS_DELETE, label: 'Delete forms' },\n      { key: PERMISSIONS.FORMS_SUBMISSIONS, label: 'View submissions' },\n    ],\n  },\n  email: {\n    label: 'Email Campaigns',\n    permissions: [\n      { key: PERMISSIONS.EMAIL_VIEW, label: 'View campaigns' },\n      { key: PERMISSIONS.EMAIL_CREATE, label: 'Create campaigns' },\n      { key: PERMISSIONS.EMAIL_EDIT, label: 'Edit campaigns' },\n      { key: PERMISSIONS.EMAIL_DELETE, label: 'Delete campaigns' },\n      { key: PERMISSIONS.EMAIL_SEND, label: 'Send campaigns' },\n    ],\n  },\n  audit: {\n    label: 'Audit Log',\n    permissions: [\n      { key: PERMISSIONS.AUDIT_VIEW, label: 'View audit log' },\n    ],\n  },\n} as const\n\n// Built-in role definitions\nexport const BUILT_IN_ROLES = {\n  super_admin: {\n    name: 'super_admin',\n    displayName: 'Super Admin',\n    description: 'Full access to all features and settings',\n    permissions: [PERMISSIONS.SUPER_ADMIN],\n    isSystem: true,\n    position: 0,\n  },\n  store_manager: {\n    name: 'store_manager',\n    displayName: 'Store Manager',\n    description: 'Manage products, orders, inventory, and customers',\n    permissions: [\n      PERMISSIONS.PRODUCTS_ALL,\n      PERMISSIONS.VARIANTS_ALL,\n      PERMISSIONS.ORDERS_ALL,\n      PERMISSIONS.INVENTORY_ALL,\n      PERMISSIONS.CUSTOMERS_VIEW,\n      PERMISSIONS.CUSTOMERS_EDIT,\n      PERMISSIONS.CATEGORIES_ALL,\n      PERMISSIONS.MEDIA_VIEW,\n      PERMISSIONS.MEDIA_UPLOAD,\n      PERMISSIONS.ANALYTICS_VIEW,\n    ],\n    isSystem: true,\n    position: 1,\n  },\n  content_editor: {\n    name: 'content_editor',\n    displayName: 'Content Editor',\n    description: 'Manage pages, blog posts, and media',\n    permissions: [\n      PERMISSIONS.PAGES_ALL,\n      PERMISSIONS.BLOG_ALL,\n      PERMISSIONS.MEDIA_ALL,\n      PERMISSIONS.CATEGORIES_VIEW,\n      PERMISSIONS.CATEGORIES_EDIT,\n    ],\n    isSystem: true,\n    position: 2,\n  },\n  order_fulfiller: {\n    name: 'order_fulfiller',\n    displayName: 'Order Fulfiller',\n    description: 'View and fulfill orders',\n    permissions: [\n      PERMISSIONS.ORDERS_VIEW,\n      PERMISSIONS.ORDERS_FULFILL,\n      PERMISSIONS.INVENTORY_VIEW,\n      PERMISSIONS.CUSTOMERS_VIEW,\n    ],\n    isSystem: true,\n    position: 3,\n  },\n  support_staff: {\n    name: 'support_staff',\n    displayName: 'Support Staff',\n    description: 'View orders and manage customer inquiries',\n    permissions: [\n      PERMISSIONS.ORDERS_VIEW,\n      PERMISSIONS.CUSTOMERS_VIEW,\n      PERMISSIONS.CUSTOMERS_EDIT,\n    ],\n    isSystem: true,\n    position: 4,\n  },\n} as const\n\nexport type BuiltInRoleName = keyof typeof BUILT_IN_ROLES\n","/**\n * Permission Checking Utilities\n * Core RBAC logic for checking user permissions\n */\n\nimport { prisma } from '../db'\nimport { PERMISSIONS, BUILT_IN_ROLES } from './constants'\nimport type {\n  UserWithPermissions,\n  RoleData,\n  PermissionOverride,\n  PermissionCheckResult,\n  AuditAction,\n} from './types'\n\nexport { PERMISSIONS, PERMISSION_GROUPS, BUILT_IN_ROLES } from './constants'\nexport type { Permission, BuiltInRoleName } from './constants'\nexport type * from './types'\n\n/**\n * Get a user's complete permission set (roles + overrides)\n */\nexport async function getUserPermissions(userId: string): Promise<UserWithPermissions | null> {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    include: {\n      roleAssignments: {\n        include: {\n          role: true,\n        },\n      },\n      permissions: {\n        where: {\n          OR: [\n            { expiresAt: null },\n            { expiresAt: { gt: new Date() } },\n          ],\n        },\n      },\n    },\n  })\n\n  if (!user) return null\n\n  // Extract roles\n  const roles: RoleData[] = user.roleAssignments.map((ra) => ({\n    id: ra.role.id,\n    name: ra.role.name,\n    displayName: ra.role.displayName,\n    description: ra.role.description,\n    permissions: ra.role.permissions as string[],\n    isSystem: ra.role.isSystem,\n  }))\n\n  // Extract overrides\n  const overrides: PermissionOverride[] = user.permissions.map((p) => ({\n    id: p.id,\n    permission: p.permission,\n    type: p.type as 'GRANT' | 'DENY',\n    expiresAt: p.expiresAt,\n    reason: p.reason,\n  }))\n\n  // Compute effective permissions\n  const permissions = computeEffectivePermissions(roles, overrides)\n\n  return {\n    id: user.id,\n    email: user.email,\n    name: user.name,\n    permissions,\n    roles,\n    overrides,\n  }\n}\n\n/**\n * Compute effective permissions from roles and overrides\n * Order: Collect from roles  Apply DENY overrides  Apply GRANT overrides\n */\nfunction computeEffectivePermissions(\n  roles: RoleData[],\n  overrides: PermissionOverride[]\n): Set<string> {\n  const permissions = new Set<string>()\n\n  // 1. Collect all permissions from roles\n  for (const role of roles) {\n    for (const perm of role.permissions) {\n      permissions.add(perm)\n    }\n  }\n\n  // 2. Apply DENY overrides (remove permissions)\n  for (const override of overrides) {\n    if (override.type === 'DENY') {\n      permissions.delete(override.permission)\n    }\n  }\n\n  // 3. Apply GRANT overrides (add permissions)\n  for (const override of overrides) {\n    if (override.type === 'GRANT') {\n      permissions.add(override.permission)\n    }\n  }\n\n  return permissions\n}\n\n/**\n * Check if a permission matches (including wildcards)\n * Examples:\n * - \"products.view\" matches \"products.view\" exactly\n * - \"products.*\" matches \"products.view\", \"products.edit\", etc.\n * - \"*\" matches everything\n */\nfunction permissionMatches(userPermission: string, requiredPermission: string): boolean {\n  // Exact match\n  if (userPermission === requiredPermission) return true\n\n  // Super admin wildcard\n  if (userPermission === '*') return true\n\n  // Resource wildcard (e.g., \"products.*\" matches \"products.view\")\n  if (userPermission.endsWith('.*')) {\n    const resource = userPermission.slice(0, -2) // Remove \".*\"\n    return requiredPermission.startsWith(resource + '.')\n  }\n\n  return false\n}\n\n/**\n * Check if user has a specific permission\n */\nexport async function hasPermission(\n  userId: string,\n  permission: string\n): Promise<PermissionCheckResult> {\n  const userPerms = await getUserPermissions(userId)\n\n  if (!userPerms) {\n    return { allowed: false, reason: 'User not found' }\n  }\n\n  return checkPermission(userPerms, permission)\n}\n\n/**\n * Check permission against a pre-loaded user permission set\n * (Use this in loops to avoid repeated DB queries)\n */\nexport function checkPermission(\n  userPerms: UserWithPermissions,\n  requiredPermission: string\n): PermissionCheckResult {\n  // Check for super admin first\n  if (userPerms.permissions.has('*')) {\n    return {\n      allowed: true,\n      source: { type: 'super_admin' },\n    }\n  }\n\n  // Check each user permission for a match\n  for (const userPerm of userPerms.permissions) {\n    if (permissionMatches(userPerm, requiredPermission)) {\n      // Determine source (role or override)\n      const grantOverride = userPerms.overrides.find(\n        (o) => o.type === 'GRANT' && o.permission === userPerm\n      )\n\n      if (grantOverride) {\n        return {\n          allowed: true,\n          source: {\n            type: 'override',\n            id: grantOverride.id,\n          },\n        }\n      }\n\n      // Find which role grants this\n      for (const role of userPerms.roles) {\n        if (role.permissions.some((p) => permissionMatches(p, requiredPermission))) {\n          return {\n            allowed: true,\n            source: {\n              type: 'role',\n              id: role.id,\n              name: role.displayName,\n            },\n          }\n        }\n      }\n\n      return { allowed: true }\n    }\n  }\n\n  // Check if explicitly denied\n  const denyOverride = userPerms.overrides.find(\n    (o) => o.type === 'DENY' && o.permission === requiredPermission\n  )\n\n  if (denyOverride) {\n    return {\n      allowed: false,\n      reason: denyOverride.reason || 'Permission explicitly denied',\n      source: {\n        type: 'override',\n        id: denyOverride.id,\n      },\n    }\n  }\n\n  return {\n    allowed: false,\n    reason: 'Permission not granted by any role',\n  }\n}\n\n/**\n * Check multiple permissions at once\n * Returns true only if ALL permissions are granted\n */\nexport async function hasAllPermissions(\n  userId: string,\n  permissions: string[]\n): Promise<boolean> {\n  const userPerms = await getUserPermissions(userId)\n  if (!userPerms) return false\n\n  return permissions.every((p) => checkPermission(userPerms, p).allowed)\n}\n\n/**\n * Check multiple permissions at once\n * Returns true if ANY permission is granted\n */\nexport async function hasAnyPermission(\n  userId: string,\n  permissions: string[]\n): Promise<boolean> {\n  const userPerms = await getUserPermissions(userId)\n  if (!userPerms) return false\n\n  return permissions.some((p) => checkPermission(userPerms, p).allowed)\n}\n\n/**\n * Check if user is a super admin\n */\nexport async function isSuperAdmin(userId: string): Promise<boolean> {\n  const userPerms = await getUserPermissions(userId)\n  return userPerms?.permissions.has('*') ?? false\n}\n\n/**\n * Log an audit event\n */\nexport async function logAuditEvent(params: {\n  userId?: string\n  userEmail?: string\n  action: AuditAction\n  targetType?: string\n  targetId?: string\n  details?: Record<string, unknown>\n  ipAddress?: string\n  userAgent?: string\n}): Promise<void> {\n  await prisma.auditLog.create({\n    data: {\n      userId: params.userId,\n      userEmail: params.userEmail,\n      action: params.action,\n      targetType: params.targetType,\n      targetId: params.targetId,\n      details: (params.details || {}) as any,\n      ipAddress: params.ipAddress,\n      userAgent: params.userAgent,\n    },\n  })\n}\n\n/**\n * Seed built-in roles (run on app startup or migration)\n */\nexport async function seedBuiltInRoles(): Promise<void> {\n  for (const [, roleData] of Object.entries(BUILT_IN_ROLES)) {\n    await prisma.role.upsert({\n      where: { name: roleData.name },\n      update: {\n        displayName: roleData.displayName,\n        description: roleData.description,\n        permissions: roleData.permissions,\n        position: roleData.position,\n      },\n      create: {\n        name: roleData.name,\n        displayName: roleData.displayName,\n        description: roleData.description,\n        permissions: roleData.permissions,\n        isSystem: roleData.isSystem,\n        position: roleData.position,\n      },\n    })\n  }\n}\n\n/**\n * Assign a role to a user\n */\nexport async function assignRole(params: {\n  userId: string\n  roleId: string\n  assignedBy?: string\n}): Promise<void> {\n  await prisma.roleAssignment.create({\n    data: {\n      userId: params.userId,\n      roleId: params.roleId,\n      assignedBy: params.assignedBy,\n    },\n  })\n\n  // Log the action\n  if (params.assignedBy) {\n    const assigner = await prisma.user.findUnique({\n      where: { id: params.assignedBy },\n      select: { email: true },\n    })\n\n    const role = await prisma.role.findUnique({\n      where: { id: params.roleId },\n      select: { name: true },\n    })\n\n    await logAuditEvent({\n      userId: params.assignedBy,\n      userEmail: assigner?.email,\n      action: 'role.assign',\n      targetType: 'user',\n      targetId: params.userId,\n      details: {\n        roleId: params.roleId,\n        roleName: role?.name,\n      },\n    })\n  }\n}\n\n/**\n * Remove a role from a user\n */\nexport async function removeRole(params: {\n  userId: string\n  roleId: string\n  removedBy?: string\n}): Promise<void> {\n  await prisma.roleAssignment.delete({\n    where: {\n      userId_roleId: {\n        userId: params.userId,\n        roleId: params.roleId,\n      },\n    },\n  })\n\n  // Log the action\n  if (params.removedBy) {\n    const remover = await prisma.user.findUnique({\n      where: { id: params.removedBy },\n      select: { email: true },\n    })\n\n    const role = await prisma.role.findUnique({\n      where: { id: params.roleId },\n      select: { name: true },\n    })\n\n    await logAuditEvent({\n      userId: params.removedBy,\n      userEmail: remover?.email,\n      action: 'role.remove',\n      targetType: 'user',\n      targetId: params.userId,\n      details: {\n        roleId: params.roleId,\n        roleName: role?.name,\n      },\n    })\n  }\n}\n\n/**\n * Grant a permission override to a user\n */\nexport async function grantPermission(params: {\n  userId: string\n  permission: string\n  expiresAt?: Date\n  reason?: string\n  grantedBy?: string\n}): Promise<void> {\n  await prisma.userPermission.upsert({\n    where: {\n      userId_permission: {\n        userId: params.userId,\n        permission: params.permission,\n      },\n    },\n    update: {\n      type: 'GRANT',\n      expiresAt: params.expiresAt,\n      reason: params.reason,\n      grantedBy: params.grantedBy,\n    },\n    create: {\n      userId: params.userId,\n      permission: params.permission,\n      type: 'GRANT',\n      expiresAt: params.expiresAt,\n      reason: params.reason,\n      grantedBy: params.grantedBy,\n    },\n  })\n\n  // Log the action\n  if (params.grantedBy) {\n    const granter = await prisma.user.findUnique({\n      where: { id: params.grantedBy },\n      select: { email: true },\n    })\n\n    await logAuditEvent({\n      userId: params.grantedBy,\n      userEmail: granter?.email,\n      action: 'permission.grant',\n      targetType: 'user',\n      targetId: params.userId,\n      details: {\n        permission: params.permission,\n        expiresAt: params.expiresAt?.toISOString(),\n        reason: params.reason,\n      },\n    })\n  }\n}\n\n/**\n * Deny a permission override to a user\n */\nexport async function denyPermission(params: {\n  userId: string\n  permission: string\n  expiresAt?: Date\n  reason?: string\n  deniedBy?: string\n}): Promise<void> {\n  await prisma.userPermission.upsert({\n    where: {\n      userId_permission: {\n        userId: params.userId,\n        permission: params.permission,\n      },\n    },\n    update: {\n      type: 'DENY',\n      expiresAt: params.expiresAt,\n      reason: params.reason,\n      grantedBy: params.deniedBy,\n    },\n    create: {\n      userId: params.userId,\n      permission: params.permission,\n      type: 'DENY',\n      expiresAt: params.expiresAt,\n      reason: params.reason,\n      grantedBy: params.deniedBy,\n    },\n  })\n\n  // Log the action\n  if (params.deniedBy) {\n    const denier = await prisma.user.findUnique({\n      where: { id: params.deniedBy },\n      select: { email: true },\n    })\n\n    await logAuditEvent({\n      userId: params.deniedBy,\n      userEmail: denier?.email,\n      action: 'permission.deny',\n      targetType: 'user',\n      targetId: params.userId,\n      details: {\n        permission: params.permission,\n        expiresAt: params.expiresAt?.toISOString(),\n        reason: params.reason,\n      },\n    })\n  }\n}\n\n/**\n * Remove a permission override from a user\n */\nexport async function removePermissionOverride(params: {\n  userId: string\n  permission: string\n  removedBy?: string\n}): Promise<void> {\n  const existing = await prisma.userPermission.findUnique({\n    where: {\n      userId_permission: {\n        userId: params.userId,\n        permission: params.permission,\n      },\n    },\n  })\n\n  if (!existing) return\n\n  await prisma.userPermission.delete({\n    where: {\n      userId_permission: {\n        userId: params.userId,\n        permission: params.permission,\n      },\n    },\n  })\n\n  // Log the action\n  if (params.removedBy) {\n    const remover = await prisma.user.findUnique({\n      where: { id: params.removedBy },\n      select: { email: true },\n    })\n\n    await logAuditEvent({\n      userId: params.removedBy,\n      userEmail: remover?.email,\n      action: 'permission.remove',\n      targetType: 'user',\n      targetId: params.userId,\n      details: {\n        permission: params.permission,\n        previousType: existing.type,\n      },\n    })\n  }\n}\n","/**\n * Order Workflow Types\n *\n * Type definitions for the order progress management system\n */\n\n// =============================================================================\n// SHIPPO EVENT TYPES\n// =============================================================================\n\nexport type ShippoTrackingEvent =\n  | 'PRE_TRANSIT'\n  | 'TRANSIT'\n  | 'DELIVERED'\n  | 'RETURNED'\n  | 'FAILURE'\n  | 'UNKNOWN'\n\n// =============================================================================\n// PROGRESS SOURCE TYPES\n// =============================================================================\n\nexport type ProgressSource = 'manual' | 'shippo' | 'system' | 'webhook'\n\n// =============================================================================\n// WORKFLOW TYPES\n// =============================================================================\n\nexport interface WorkflowStageInput {\n  name: string\n  slug: string\n  displayName: string\n  customerMessage?: string\n  icon?: string\n  color?: string\n  position: number\n  isTerminal?: boolean\n  notifyCustomer?: boolean\n  estimatedDuration?: number\n  shippoEventTrigger?: ShippoTrackingEvent | null\n}\n\nexport interface WorkflowCreateInput {\n  name: string\n  slug: string\n  description?: string\n  isDefault?: boolean\n  isActive?: boolean\n  enableShippoSync?: boolean\n  stages?: WorkflowStageInput[]\n}\n\nexport interface WorkflowUpdateInput {\n  name?: string\n  slug?: string\n  description?: string\n  isDefault?: boolean\n  isActive?: boolean\n  enableShippoSync?: boolean\n}\n\nexport interface StageUpdateInput {\n  name?: string\n  slug?: string\n  displayName?: string\n  customerMessage?: string\n  icon?: string\n  color?: string\n  position?: number\n  isTerminal?: boolean\n  notifyCustomer?: boolean\n  estimatedDuration?: number\n  shippoEventTrigger?: ShippoTrackingEvent | null\n}\n\n// =============================================================================\n// PROGRESS TYPES\n// =============================================================================\n\nexport interface ProgressTransitionInput {\n  orderId: string\n  stageId: string\n  source?: ProgressSource\n  isOverride?: boolean\n  reason?: string\n  updatedById?: string\n  notes?: string\n}\n\nexport interface ProgressRevertInput {\n  orderId: string\n  targetStageId: string\n  reason: string\n  updatedById?: string\n  notes?: string\n}\n\n// =============================================================================\n// RESPONSE TYPES\n// =============================================================================\n\nexport interface WorkflowWithStages {\n  id: string\n  name: string\n  slug: string\n  description: string | null\n  isDefault: boolean\n  isActive: boolean\n  enableShippoSync: boolean\n  createdAt: Date\n  updatedAt: Date\n  stages: WorkflowStage[]\n}\n\nexport interface WorkflowStage {\n  id: string\n  workflowId: string\n  name: string\n  slug: string\n  displayName: string\n  customerMessage: string | null\n  icon: string | null\n  color: string | null\n  position: number\n  isTerminal: boolean\n  notifyCustomer: boolean\n  estimatedDuration: number | null\n  shippoEventTrigger: string | null\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport interface OrderProgressEntry {\n  id: string\n  orderId: string\n  stageId: string\n  enteredAt: Date\n  exitedAt: Date | null\n  source: string\n  isOverride: boolean\n  reason: string | null\n  updatedById: string | null\n  notes: string | null\n  createdAt: Date\n  stage: WorkflowStage\n  updatedBy?: {\n    id: string\n    name: string | null\n    email: string\n  } | null\n}\n\nexport interface OrderWithProgress {\n  id: string\n  orderNumber: string\n  workflowId: string | null\n  currentStageId: string | null\n  trackingAutoSync: boolean\n  workflow: WorkflowWithStages | null\n  currentStage: WorkflowStage | null\n  progress: OrderProgressEntry[]\n}\n\n// =============================================================================\n// CUSTOMER-FACING TYPES\n// =============================================================================\n\nexport interface CustomerProgressView {\n  orderId: string\n  orderNumber: string\n  currentStage: {\n    displayName: string\n    customerMessage: string | null\n    icon: string | null\n    color: string | null\n    isTerminal: boolean\n  } | null\n  stages: {\n    displayName: string\n    icon: string | null\n    color: string | null\n    isCompleted: boolean\n    isCurrent: boolean\n    completedAt: Date | null\n  }[]\n  estimatedDelivery: Date | null\n}\n\n// =============================================================================\n// DEFAULT WORKFLOW TEMPLATES\n// =============================================================================\n\nexport interface WorkflowTemplate {\n  name: string\n  slug: string\n  description: string\n  enableShippoSync: boolean\n  stages: WorkflowStageInput[]\n}\n\nexport const DEFAULT_WORKFLOW_TEMPLATES: WorkflowTemplate[] = [\n  {\n    name: 'Standard Shipping',\n    slug: 'standard-shipping',\n    description: 'Default workflow for physical products requiring shipping',\n    enableShippoSync: true,\n    stages: [\n      {\n        name: 'order_received',\n        slug: 'order-received',\n        displayName: 'Order Received',\n        customerMessage: \"We've received your order and are preparing it for processing.\",\n        icon: 'inbox',\n        color: '#3B82F6',\n        position: 0,\n        notifyCustomer: true,\n        estimatedDuration: 24,\n        shippoEventTrigger: null,\n      },\n      {\n        name: 'processing',\n        slug: 'processing',\n        displayName: 'Processing',\n        customerMessage: \"Your order is being prepared and will be shipped soon.\",\n        icon: 'package',\n        color: '#F59E0B',\n        position: 1,\n        notifyCustomer: true,\n        estimatedDuration: 48,\n        shippoEventTrigger: 'PRE_TRANSIT',\n      },\n      {\n        name: 'shipped',\n        slug: 'shipped',\n        displayName: 'Shipped',\n        customerMessage: \"Great news! Your order is on its way.\",\n        icon: 'truck',\n        color: '#8B5CF6',\n        position: 2,\n        notifyCustomer: true,\n        estimatedDuration: 72,\n        shippoEventTrigger: 'TRANSIT',\n      },\n      {\n        name: 'delivered',\n        slug: 'delivered',\n        displayName: 'Delivered',\n        customerMessage: \"Your order has been delivered. Thank you for shopping with us!\",\n        icon: 'check-circle',\n        color: '#10B981',\n        position: 3,\n        isTerminal: true,\n        notifyCustomer: true,\n        shippoEventTrigger: 'DELIVERED',\n      },\n    ],\n  },\n  {\n    name: 'Digital Download',\n    slug: 'digital-download',\n    description: 'Workflow for digital products with instant delivery',\n    enableShippoSync: false,\n    stages: [\n      {\n        name: 'order_received',\n        slug: 'order-received',\n        displayName: 'Order Received',\n        customerMessage: \"We've received your order.\",\n        icon: 'inbox',\n        color: '#3B82F6',\n        position: 0,\n        notifyCustomer: true,\n        estimatedDuration: 1,\n      },\n      {\n        name: 'ready',\n        slug: 'ready',\n        displayName: 'Ready for Download',\n        customerMessage: \"Your files are ready! Check your email for download links.\",\n        icon: 'download',\n        color: '#10B981',\n        position: 1,\n        isTerminal: true,\n        notifyCustomer: true,\n      },\n    ],\n  },\n  {\n    name: 'Custom Order',\n    slug: 'custom-order',\n    description: 'Workflow for made-to-order or customized products',\n    enableShippoSync: true,\n    stages: [\n      {\n        name: 'order_received',\n        slug: 'order-received',\n        displayName: 'Order Received',\n        customerMessage: \"We've received your custom order request.\",\n        icon: 'inbox',\n        color: '#3B82F6',\n        position: 0,\n        notifyCustomer: true,\n        estimatedDuration: 24,\n      },\n      {\n        name: 'design_review',\n        slug: 'design-review',\n        displayName: 'Design Review',\n        customerMessage: \"Our team is reviewing your customization details.\",\n        icon: 'eye',\n        color: '#6366F1',\n        position: 1,\n        notifyCustomer: true,\n        estimatedDuration: 48,\n      },\n      {\n        name: 'in_production',\n        slug: 'in-production',\n        displayName: 'In Production',\n        customerMessage: \"Your custom item is being crafted with care.\",\n        icon: 'hammer',\n        color: '#F59E0B',\n        position: 2,\n        notifyCustomer: true,\n        estimatedDuration: 120,\n        shippoEventTrigger: 'PRE_TRANSIT',\n      },\n      {\n        name: 'quality_check',\n        slug: 'quality-check',\n        displayName: 'Quality Check',\n        customerMessage: \"Your item is undergoing final quality inspection.\",\n        icon: 'shield-check',\n        color: '#8B5CF6',\n        position: 3,\n        notifyCustomer: true,\n        estimatedDuration: 24,\n      },\n      {\n        name: 'shipped',\n        slug: 'shipped',\n        displayName: 'Shipped',\n        customerMessage: \"Your custom order is on its way!\",\n        icon: 'truck',\n        color: '#EC4899',\n        position: 4,\n        notifyCustomer: true,\n        estimatedDuration: 72,\n        shippoEventTrigger: 'TRANSIT',\n      },\n      {\n        name: 'delivered',\n        slug: 'delivered',\n        displayName: 'Delivered',\n        customerMessage: \"Your custom order has been delivered. Enjoy!\",\n        icon: 'check-circle',\n        color: '#10B981',\n        position: 5,\n        isTerminal: true,\n        notifyCustomer: true,\n        shippoEventTrigger: 'DELIVERED',\n      },\n    ],\n  },\n  {\n    name: 'Local Pickup',\n    slug: 'local-pickup',\n    description: 'Workflow for in-store or local pickup orders',\n    enableShippoSync: false,\n    stages: [\n      {\n        name: 'order_received',\n        slug: 'order-received',\n        displayName: 'Order Received',\n        customerMessage: \"We've received your order.\",\n        icon: 'inbox',\n        color: '#3B82F6',\n        position: 0,\n        notifyCustomer: true,\n        estimatedDuration: 24,\n      },\n      {\n        name: 'preparing',\n        slug: 'preparing',\n        displayName: 'Preparing',\n        customerMessage: \"We're preparing your order for pickup.\",\n        icon: 'package',\n        color: '#F59E0B',\n        position: 1,\n        notifyCustomer: true,\n        estimatedDuration: 24,\n      },\n      {\n        name: 'ready_for_pickup',\n        slug: 'ready-for-pickup',\n        displayName: 'Ready for Pickup',\n        customerMessage: \"Your order is ready! Come pick it up at your convenience.\",\n        icon: 'map-pin',\n        color: '#10B981',\n        position: 2,\n        notifyCustomer: true,\n        estimatedDuration: 168, // 7 days\n      },\n      {\n        name: 'picked_up',\n        slug: 'picked-up',\n        displayName: 'Picked Up',\n        customerMessage: \"Thank you for picking up your order!\",\n        icon: 'check-circle',\n        color: '#10B981',\n        position: 3,\n        isTerminal: true,\n        notifyCustomer: true,\n      },\n    ],\n  },\n]\n","/**\n * Order Workflows - Core CRUD Operations\n *\n * Manage order workflow templates and stages\n */\n\nimport { prisma } from '../db'\nimport type {\n  WorkflowCreateInput,\n  WorkflowUpdateInput,\n  WorkflowStageInput,\n  StageUpdateInput,\n  WorkflowWithStages,\n  WorkflowStage,\n} from './types'\n\n// =============================================================================\n// WORKFLOW CRUD\n// =============================================================================\n\n/**\n * List all workflows\n */\nexport async function listWorkflows(includeInactive = false): Promise<WorkflowWithStages[]> {\n  const workflows = await prisma.orderWorkflow.findMany({\n    where: includeInactive ? {} : { isActive: true },\n    include: {\n      stages: {\n        orderBy: { position: 'asc' },\n      },\n    },\n    orderBy: [{ isDefault: 'desc' }, { name: 'asc' }],\n  })\n\n  return workflows as WorkflowWithStages[]\n}\n\n/**\n * Get a single workflow by ID or slug\n */\nexport async function getWorkflow(idOrSlug: string): Promise<WorkflowWithStages | null> {\n  const workflow = await prisma.orderWorkflow.findFirst({\n    where: {\n      OR: [{ id: idOrSlug }, { slug: idOrSlug }],\n    },\n    include: {\n      stages: {\n        orderBy: { position: 'asc' },\n      },\n    },\n  })\n\n  return workflow as WorkflowWithStages | null\n}\n\n/**\n * Get the default workflow\n */\nexport async function getDefaultWorkflow(): Promise<WorkflowWithStages | null> {\n  const workflow = await prisma.orderWorkflow.findFirst({\n    where: { isDefault: true, isActive: true },\n    include: {\n      stages: {\n        orderBy: { position: 'asc' },\n      },\n    },\n  })\n\n  return workflow as WorkflowWithStages | null\n}\n\n/**\n * Create a new workflow with stages\n */\nexport async function createWorkflow(input: WorkflowCreateInput): Promise<WorkflowWithStages> {\n  const { stages, ...workflowData } = input\n\n  // If setting as default, unset other defaults first\n  if (workflowData.isDefault) {\n    await prisma.orderWorkflow.updateMany({\n      where: { isDefault: true },\n      data: { isDefault: false },\n    })\n  }\n\n  const workflow = await prisma.orderWorkflow.create({\n    data: {\n      ...workflowData,\n      stages: stages\n        ? {\n            create: stages.map((stage, index) => ({\n              ...stage,\n              position: stage.position ?? index,\n            })),\n          }\n        : undefined,\n    },\n    include: {\n      stages: {\n        orderBy: { position: 'asc' },\n      },\n    },\n  })\n\n  return workflow as WorkflowWithStages\n}\n\n/**\n * Update a workflow\n */\nexport async function updateWorkflow(\n  id: string,\n  input: WorkflowUpdateInput\n): Promise<WorkflowWithStages> {\n  // If setting as default, unset other defaults first\n  if (input.isDefault) {\n    await prisma.orderWorkflow.updateMany({\n      where: { isDefault: true, id: { not: id } },\n      data: { isDefault: false },\n    })\n  }\n\n  const workflow = await prisma.orderWorkflow.update({\n    where: { id },\n    data: input,\n    include: {\n      stages: {\n        orderBy: { position: 'asc' },\n      },\n    },\n  })\n\n  return workflow as WorkflowWithStages\n}\n\n/**\n * Delete a workflow\n */\nexport async function deleteWorkflow(id: string): Promise<void> {\n  // Check if any orders are using this workflow\n  const orderCount = await prisma.order.count({\n    where: { workflowId: id },\n  })\n\n  if (orderCount > 0) {\n    throw new Error(`Cannot delete workflow: ${orderCount} orders are using it`)\n  }\n\n  await prisma.orderWorkflow.delete({\n    where: { id },\n  })\n}\n\n/**\n * Duplicate a workflow\n */\nexport async function duplicateWorkflow(\n  id: string,\n  newName: string,\n  newSlug: string\n): Promise<WorkflowWithStages> {\n  const original = await getWorkflow(id)\n  if (!original) {\n    throw new Error('Workflow not found')\n  }\n\n  return createWorkflow({\n    name: newName,\n    slug: newSlug,\n    description: original.description || undefined,\n    isDefault: false,\n    isActive: true,\n    enableShippoSync: original.enableShippoSync,\n    stages: original.stages.map((stage) => ({\n      name: stage.name,\n      slug: stage.slug,\n      displayName: stage.displayName,\n      customerMessage: stage.customerMessage || undefined,\n      icon: stage.icon || undefined,\n      color: stage.color || undefined,\n      position: stage.position,\n      isTerminal: stage.isTerminal,\n      notifyCustomer: stage.notifyCustomer,\n      estimatedDuration: stage.estimatedDuration || undefined,\n      shippoEventTrigger: (stage.shippoEventTrigger as any) || null,\n    })),\n  })\n}\n\n// =============================================================================\n// STAGE CRUD\n// =============================================================================\n\n/**\n * Get a single stage\n */\nexport async function getStage(id: string): Promise<WorkflowStage | null> {\n  const stage = await prisma.orderWorkflowStage.findUnique({\n    where: { id },\n  })\n\n  return stage as WorkflowStage | null\n}\n\n/**\n * Add a stage to a workflow\n */\nexport async function addStage(\n  workflowId: string,\n  input: WorkflowStageInput\n): Promise<WorkflowStage> {\n  // If no position specified, add at end\n  if (input.position === undefined) {\n    const lastStage = await prisma.orderWorkflowStage.findFirst({\n      where: { workflowId },\n      orderBy: { position: 'desc' },\n    })\n    input.position = lastStage ? lastStage.position + 1 : 0\n  }\n\n  // Shift existing stages if needed\n  await prisma.orderWorkflowStage.updateMany({\n    where: {\n      workflowId,\n      position: { gte: input.position },\n    },\n    data: {\n      position: { increment: 1 },\n    },\n  })\n\n  const stage = await prisma.orderWorkflowStage.create({\n    data: {\n      workflowId,\n      ...input,\n    },\n  })\n\n  return stage as WorkflowStage\n}\n\n/**\n * Update a stage\n */\nexport async function updateStage(id: string, input: StageUpdateInput): Promise<WorkflowStage> {\n  const stage = await prisma.orderWorkflowStage.update({\n    where: { id },\n    data: input,\n  })\n\n  return stage as WorkflowStage\n}\n\n/**\n * Delete a stage\n */\nexport async function deleteStage(id: string): Promise<void> {\n  // Check if any orders are at this stage\n  const orderCount = await prisma.order.count({\n    where: { currentStageId: id },\n  })\n\n  if (orderCount > 0) {\n    throw new Error(`Cannot delete stage: ${orderCount} orders are currently at this stage`)\n  }\n\n  const stage = await prisma.orderWorkflowStage.findUnique({\n    where: { id },\n  })\n\n  if (!stage) {\n    throw new Error('Stage not found')\n  }\n\n  // Delete the stage\n  await prisma.orderWorkflowStage.delete({\n    where: { id },\n  })\n\n  // Reorder remaining stages\n  await prisma.orderWorkflowStage.updateMany({\n    where: {\n      workflowId: stage.workflowId,\n      position: { gt: stage.position },\n    },\n    data: {\n      position: { decrement: 1 },\n    },\n  })\n}\n\n/**\n * Reorder stages within a workflow\n */\nexport async function reorderStages(\n  workflowId: string,\n  stageIds: string[]\n): Promise<WorkflowStage[]> {\n  // Update positions in a transaction\n  await prisma.$transaction(\n    stageIds.map((stageId, index) =>\n      prisma.orderWorkflowStage.update({\n        where: { id: stageId },\n        data: { position: index },\n      })\n    )\n  )\n\n  const stages = await prisma.orderWorkflowStage.findMany({\n    where: { workflowId },\n    orderBy: { position: 'asc' },\n  })\n\n  return stages as WorkflowStage[]\n}\n\n// =============================================================================\n// WORKFLOW ASSIGNMENT\n// =============================================================================\n\n/**\n * Determine the workflow for an order based on its items\n * Priority: Product workflow > Category workflow > Default workflow\n */\nexport async function determineOrderWorkflow(orderId: string): Promise<string | null> {\n  // Get order items with product and category info\n  const orderItems = await prisma.orderItem.findMany({\n    where: { orderId },\n    include: {\n      product: {\n        include: {\n          categories: {\n            include: {\n              category: true,\n            },\n          },\n        },\n      },\n    },\n  })\n\n  // Check for product-level workflow\n  for (const item of orderItems) {\n    if (item.product.orderWorkflowId) {\n      return item.product.orderWorkflowId\n    }\n  }\n\n  // Check for category-level workflow\n  for (const item of orderItems) {\n    for (const pc of item.product.categories) {\n      if (pc.category.orderWorkflowId) {\n        return pc.category.orderWorkflowId\n      }\n    }\n  }\n\n  // Fall back to default workflow\n  const defaultWorkflow = await getDefaultWorkflow()\n  return defaultWorkflow?.id || null\n}\n\n/**\n * Assign a workflow to an order\n */\nexport async function assignWorkflowToOrder(\n  orderId: string,\n  workflowId: string | null\n): Promise<void> {\n  // Get the first stage of the workflow\n  let firstStageId: string | null = null\n\n  if (workflowId) {\n    const workflow = await getWorkflow(workflowId)\n    if (workflow && workflow.stages.length > 0) {\n      firstStageId = workflow.stages[0].id\n    }\n  }\n\n  await prisma.order.update({\n    where: { id: orderId },\n    data: {\n      workflowId,\n      currentStageId: firstStageId,\n    },\n  })\n}\n\n/**\n * Initialize workflow for a new order\n */\nexport async function initializeOrderWorkflow(orderId: string): Promise<void> {\n  const workflowId = await determineOrderWorkflow(orderId)\n\n  if (workflowId) {\n    await assignWorkflowToOrder(orderId, workflowId)\n\n    // Create initial progress entry\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      select: { currentStageId: true },\n    })\n\n    if (order?.currentStageId) {\n      await prisma.orderProgress.create({\n        data: {\n          orderId,\n          stageId: order.currentStageId,\n          source: 'system',\n          notes: 'Order created - workflow initialized',\n        },\n      })\n    }\n  }\n}\n\n// Re-export types\nexport * from './types'\n","/**\n * Plugin System Types\n *\n * Core type definitions for the self-extending agent architecture.\n * Inspired by vmcp (Virtual Model Context Protocol) patterns.\n */\n\n/**\n * JSON Schema types for input validation\n */\nexport interface JSONSchemaProperty {\n  type?: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'null';\n  description?: string;\n  enum?: string[];\n  items?: JSONSchemaProperty;\n  properties?: Record<string, JSONSchemaProperty>;\n  required?: string[];\n  default?: unknown;\n  minLength?: number;\n  maxLength?: number;\n  minimum?: number;\n  maximum?: number;\n  pattern?: string;\n}\n\nexport interface JSONSchema {\n  type: 'object';\n  properties: Record<string, JSONSchemaProperty>;\n  required?: string[];\n  additionalProperties?: boolean;\n}\n\n/**\n * Primitive - Atomic unit of tool definition\n *\n * This is the core data structure representing a dynamic tool.\n * Compatible with MCP tool definitions for AI agent integration.\n */\nexport interface PrimitiveDefinition {\n  // Identity\n  id: string;\n  name: string;\n  version: string;\n\n  // Schema (MCP-compatible)\n  description: string;\n  inputSchema: JSONSchema;\n\n  // Implementation\n  handler: string;           // JavaScript code\n  dependencies?: string[];   // npm packages (allowlisted)\n\n  // Metadata\n  author?: string;\n  tags?: string[];\n  tier?: 'FREE' | 'PROPRIETARY';\n  category?: string;\n  icon?: string;\n\n  // Runtime hints\n  timeout?: number;          // ms (default: 30000)\n  memory?: number;           // MB (default: 128)\n  sandbox?: boolean;         // Run in sandbox (default: true)\n\n  // Status\n  enabled?: boolean;\n  builtIn?: boolean;\n\n  // Plugin relationship\n  pluginId?: string | null;\n\n  // Timestamps\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\n/**\n * Mounted Primitive - A primitive that is currently active and available\n */\nexport interface MountedPrimitive {\n  definition: PrimitiveDefinition;\n  mountedAt: number;\n  config?: Record<string, unknown>;\n  invocationCount: number;\n  lastInvoked?: number;\n  compiledHandler?: Function;\n}\n\n/**\n * Plugin - Collection of primitives forming a feature unit\n */\nexport interface PluginDefinition {\n  id: string;\n  name: string;\n  slug: string;\n  description?: string;\n  version: string;\n\n  // Display\n  icon?: string;\n  color?: string;\n\n  // Configuration\n  config?: Record<string, unknown>;\n  configSchema?: JSONSchema;\n\n  // Status\n  enabled?: boolean;\n  installed?: boolean;\n  builtIn?: boolean;\n\n  // Author info\n  author?: string;\n  authorUrl?: string;\n  repository?: string;\n\n  // Timestamps\n  createdAt?: Date;\n  updatedAt?: Date;\n  installedAt?: Date;\n}\n\n/**\n * Workflow - Visual composition of primitives\n */\nexport interface WorkflowDefinition {\n  id: string;\n  name: string;\n  slug: string;\n  description?: string;\n\n  // React Flow data\n  nodes: WorkflowNodeData[];\n  edges: WorkflowEdgeData[];\n  viewport?: {\n    x: number;\n    y: number;\n    zoom: number;\n  };\n\n  // Configuration\n  config?: Record<string, unknown>;\n  variables?: Record<string, unknown>;\n\n  // Trigger\n  triggerType: 'MANUAL' | 'SCHEDULE' | 'WEBHOOK' | 'EVENT' | 'AI_AGENT';\n  triggerConfig?: Record<string, unknown>;\n\n  // Status\n  enabled?: boolean;\n\n  // Plugin relationship\n  pluginId?: string | null;\n\n  // Timestamps\n  createdAt?: Date;\n  updatedAt?: Date;\n  lastRunAt?: Date;\n}\n\n/**\n * Workflow Node Data - React Flow node structure\n */\nexport interface WorkflowNodeData {\n  id: string;\n  type: 'primitive' | 'trigger' | 'condition' | 'loop' | 'output';\n  position: { x: number; y: number };\n  data: {\n    label?: string;\n    primitiveId?: string;\n    config?: Record<string, unknown>;\n    inputMappings?: Record<string, string>; // Map workflow vars to inputs\n  };\n}\n\n/**\n * Workflow Edge Data - React Flow edge structure\n */\nexport interface WorkflowEdgeData {\n  id: string;\n  source: string;\n  target: string;\n  sourceHandle?: string;\n  targetHandle?: string;\n  data?: {\n    condition?: string;  // For conditional edges\n    label?: string;\n  };\n}\n\n/**\n * Execution Context - Passed to primitive handlers\n */\nexport interface ExecutionContext {\n  primitiveId: string;\n  primitiveName: string;\n  invocationId: string;\n  startTime: number;\n  timeout?: number;\n  config?: Record<string, unknown>;\n  debug?: boolean;\n\n  // Workflow context (if part of workflow execution)\n  workflowExecutionId?: string;\n  workflowVariables?: Record<string, unknown>;\n\n  // User context\n  userId?: string;\n  agentId?: string;\n\n  // Platform info\n  platform?: {\n    os: 'windows' | 'mac' | 'linux';\n    isWSL: boolean;\n    arch: string;\n  };\n}\n\n/**\n * Execution Result\n */\nexport interface ExecutionResult {\n  success: boolean;\n  result?: unknown;\n  error?: string;\n  executionTime: number;\n  invocationId?: string;\n}\n\n/**\n * Primitive Info - Simplified for listings\n */\nexport interface PrimitiveInfo {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  tags: string[];\n  category?: string;\n  icon?: string;\n  mounted: boolean;\n  enabled: boolean;\n  author?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n/**\n * Plugin Info - Simplified for listings\n */\nexport interface PluginInfo {\n  id: string;\n  name: string;\n  slug: string;\n  description?: string;\n  version: string;\n  icon?: string;\n  color?: string;\n  enabled: boolean;\n  installed: boolean;\n  builtIn: boolean;\n  primitiveCount: number;\n  author?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n/**\n * Registry Statistics\n */\nexport interface RegistryStats {\n  primitiveCount: number;\n  mountedCount: number;\n  pluginCount: number;\n  enabledPluginCount: number;\n  workflowCount: number;\n  totalExecutions: number;\n}\n\n/**\n * Create Primitive Request\n */\nexport interface CreatePrimitiveRequest {\n  name: string;\n  description: string;\n  inputSchema: JSONSchema;\n  handler: string;\n  category?: string;\n  tags?: string[];\n  icon?: string;\n  timeout?: number;\n  pluginId?: string;\n  autoMount?: boolean;\n}\n\n/**\n * Update Primitive Request\n */\nexport interface UpdatePrimitiveRequest {\n  description?: string;\n  inputSchema?: JSONSchema;\n  handler?: string;\n  category?: string;\n  tags?: string[];\n  icon?: string;\n  timeout?: number;\n  enabled?: boolean;\n}\n\n/**\n * Create Plugin Request\n */\nexport interface CreatePluginRequest {\n  name: string;\n  slug: string;\n  description?: string;\n  icon?: string;\n  color?: string;\n  config?: Record<string, unknown>;\n  configSchema?: JSONSchema;\n  author?: string;\n}\n\n/**\n * Standard Response Format\n */\nexport interface PluginResponse<T = unknown> {\n  status: 'success' | 'error';\n  data?: T;\n  message?: string;\n  hint?: string;\n}\n\n/**\n * Generate a unique ID with optional prefix\n */\nexport function generateId(prefix: string = 'id'): string {\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 8);\n  return `${prefix}_${timestamp}${random}`;\n}\n\n/**\n * Increment semver patch version\n */\nexport function incrementVersion(version: string): string {\n  const parts = version.split('.').map(Number);\n  parts[2] = (parts[2] || 0) + 1;\n  return parts.join('.');\n}\n\n/**\n * Slugify a string\n */\nexport function slugify(str: string): string {\n  return str\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/[\\s_-]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}\n","/**\n * Sandbox - Isolated Execution Environment for Primitive Handlers\n *\n * Provides a restricted execution environment for user-provided code.\n * Security measures:\n * - No access to Node.js built-ins (fs, path, child_process, etc.)\n * - No access to global objects (process, global, globalThis)\n * - Limited JavaScript APIs (JSON, Math, Date, String, Number, etc.)\n * - Timeout enforcement\n * - Output size limits\n */\n\nimport type { ExecutionContext } from './types';\n\n/**\n * Sandbox Configuration\n */\nexport interface SandboxConfig {\n  timeout: number;         // Max execution time in ms\n  allowAsync: boolean;     // Allow async operations\n  maxOutputSize: number;   // Max output size in bytes\n}\n\n/**\n * Sandbox Execution Result\n */\nexport interface SandboxResult {\n  success: boolean;\n  result?: unknown;\n  error?: string;\n  executionTime: number;\n  outputSize?: number;\n}\n\n/**\n * Default sandbox configuration\n */\nconst DEFAULT_CONFIG: SandboxConfig = {\n  timeout: 30000,\n  allowAsync: true,\n  maxOutputSize: 1024 * 1024,  // 1MB\n};\n\n/**\n * Allowed globals in sandbox - safe JavaScript APIs only\n */\nconst SANDBOX_GLOBALS: Record<string, unknown> = {\n  // Core JavaScript\n  Object,\n  Array,\n  String,\n  Number,\n  Boolean,\n  Date,\n  RegExp,\n  Error,\n  TypeError,\n  RangeError,\n  SyntaxError,\n\n  // JSON operations\n  JSON,\n\n  // Math operations\n  Math,\n\n  // Data structures\n  Map,\n  Set,\n  WeakMap,\n  WeakSet,\n\n  // Utilities\n  parseInt,\n  parseFloat,\n  isNaN,\n  isFinite,\n  encodeURIComponent,\n  decodeURIComponent,\n  encodeURI,\n  decodeURI,\n\n  // Promises (if async allowed)\n  Promise,\n\n  // Console (captured, not actual logging)\n  console: {\n    log: (..._args: unknown[]) => {},\n    warn: (..._args: unknown[]) => {},\n    error: (..._args: unknown[]) => {},\n    info: (..._args: unknown[]) => {},\n  },\n\n  // URL parsing\n  URL,\n  URLSearchParams,\n\n  // Typed arrays\n  Uint8Array,\n  Int8Array,\n  Uint16Array,\n  Int16Array,\n  Uint32Array,\n  Int32Array,\n  Float32Array,\n  Float64Array,\n  ArrayBuffer,\n  DataView,\n\n  // Text encoding\n  TextEncoder,\n  TextDecoder,\n\n  // Explicit undefined values\n  undefined,\n  NaN,\n  Infinity,\n};\n\n/**\n * Security patterns - blocked code patterns\n */\nconst BLOCKED_PATTERNS: Array<{ pattern: RegExp; message: string }> = [\n  { pattern: /\\bprocess\\b/, message: 'Access to process object' },\n  { pattern: /\\brequire\\s*\\(/, message: 'CommonJS require' },\n  { pattern: /\\bimport\\s*\\(/, message: 'Dynamic import' },\n  { pattern: /\\bglobal\\b/, message: 'Access to global object' },\n  { pattern: /\\bglobalThis\\b/, message: 'Access to globalThis' },\n  { pattern: /\\beval\\s*\\(/, message: 'Use of eval()' },\n  { pattern: /\\bFunction\\s*\\(/, message: 'Function constructor' },\n  { pattern: /\\bchild_process\\b/, message: 'child_process module' },\n  { pattern: /\\b__proto__\\b/, message: 'Prototype manipulation' },\n  { pattern: /\\.constructor\\s*\\(/, message: 'Constructor access' },\n  { pattern: /\\bProxy\\b/, message: 'Proxy object' },\n  { pattern: /\\bReflect\\b/, message: 'Reflect object' },\n  { pattern: /\\bfetch\\b/, message: 'fetch API (use HTTP primitive instead)' },\n  { pattern: /\\bXMLHttpRequest\\b/, message: 'XMLHttpRequest (use HTTP primitive instead)' },\n];\n\n/**\n * Warning patterns - not blocked but flagged\n */\nconst WARNING_PATTERNS: Array<{ pattern: RegExp; message: string }> = [\n  { pattern: /\\bwhile\\s*\\(\\s*true\\s*\\)/, message: 'Potential infinite loop' },\n  { pattern: /\\bfor\\s*\\(\\s*;\\s*;\\s*\\)/, message: 'Potential infinite loop' },\n  { pattern: /\\bsetTimeout\\b/, message: 'Use of setTimeout' },\n  { pattern: /\\bsetInterval\\b/, message: 'Use of setInterval' },\n  { pattern: /\\.prototype\\b/, message: 'Prototype access' },\n];\n\n/**\n * Validate handler code for security issues\n */\nexport function validateHandlerSecurity(code: string): {\n  safe: boolean;\n  warnings: string[];\n  blocked: string[];\n} {\n  const warnings: string[] = [];\n  const blocked: string[] = [];\n\n  // Check blocked patterns\n  for (const { pattern, message } of BLOCKED_PATTERNS) {\n    if (pattern.test(code)) {\n      blocked.push(message);\n    }\n  }\n\n  // Check warning patterns\n  for (const { pattern, message } of WARNING_PATTERNS) {\n    if (pattern.test(code)) {\n      warnings.push(message);\n    }\n  }\n\n  return {\n    safe: blocked.length === 0,\n    warnings,\n    blocked,\n  };\n}\n\n/**\n * Create a sandbox function with restricted globals\n */\nexport function createSandboxFunction(\n  code: string,\n  config: Partial<SandboxConfig> = {}\n): (args: unknown, context: ExecutionContext) => unknown {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { allowAsync: _allowAsync } = { ...DEFAULT_CONFIG, ...config };\n\n  // Wrap code in strict mode\n  const wrappedCode = `\n    \"use strict\";\n    ${code}\n  `;\n\n  // Get global names and values for shadowing\n  const globalNames = Object.keys(SANDBOX_GLOBALS);\n  const globalValues = Object.values(SANDBOX_GLOBALS);\n\n  try {\n    // Create the sandbox function with shadowed globals\n    const sandboxFn = new Function(\n      'args',\n      'context',\n      ...globalNames,\n      // Add dummy parameters for blocked globals (shadowing)\n      '__blocked_process__',\n      '__blocked_require__',\n      '__blocked_global__',\n      '__blocked_globalThis__',\n      '__blocked_eval__',\n      '__blocked_Function__',\n      // The actual code\n      wrappedCode\n    );\n\n    // Return wrapped executor\n    return (args: unknown, context: ExecutionContext) => {\n      return sandboxFn(\n        args,\n        context,\n        ...globalValues,\n        // Pass undefined for blocked globals\n        undefined,  // process\n        undefined,  // require\n        undefined,  // global\n        undefined,  // globalThis\n        undefined,  // eval\n        undefined,  // Function\n      );\n    };\n  } catch (e) {\n    throw new Error(`Failed to compile handler: ${e instanceof Error ? e.message : String(e)}`);\n  }\n}\n\n/**\n * Execute function with timeout\n */\nasync function executeWithTimeout<T>(\n  fn: () => T | Promise<T>,\n  timeout: number\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Execution timeout after ${timeout}ms`));\n    }, timeout);\n\n    try {\n      const result = fn();\n\n      if (result instanceof Promise) {\n        result\n          .then((value) => {\n            clearTimeout(timeoutId);\n            resolve(value);\n          })\n          .catch((err) => {\n            clearTimeout(timeoutId);\n            reject(err);\n          });\n      } else {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    } catch (e) {\n      clearTimeout(timeoutId);\n      reject(e);\n    }\n  });\n}\n\n/**\n * Get the size of output in bytes\n */\nfunction getOutputSize(output: unknown): number {\n  try {\n    return new TextEncoder().encode(JSON.stringify(output)).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Execute code in sandbox with timeout\n */\nexport async function executeSandbox(\n  code: string,\n  args: unknown,\n  context: ExecutionContext,\n  config: Partial<SandboxConfig> = {}\n): Promise<SandboxResult> {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const startTime = Date.now();\n\n  try {\n    // Validate security first\n    const securityCheck = validateHandlerSecurity(code);\n    if (!securityCheck.safe) {\n      return {\n        success: false,\n        error: `Security validation failed: ${securityCheck.blocked.join(', ')}`,\n        executionTime: Date.now() - startTime,\n      };\n    }\n\n    // Create sandbox function\n    const sandboxFn = createSandboxFunction(code, fullConfig);\n\n    // Execute with timeout\n    const result = await executeWithTimeout(\n      () => sandboxFn(args, context),\n      fullConfig.timeout\n    );\n\n    // Check output size\n    const outputSize = getOutputSize(result);\n    if (outputSize > fullConfig.maxOutputSize) {\n      return {\n        success: false,\n        error: `Output too large: ${outputSize} bytes (max: ${fullConfig.maxOutputSize})`,\n        executionTime: Date.now() - startTime,\n        outputSize,\n      };\n    }\n\n    return {\n      success: true,\n      result,\n      executionTime: Date.now() - startTime,\n      outputSize,\n    };\n  } catch (e) {\n    return {\n      success: false,\n      error: e instanceof Error ? e.message : String(e),\n      executionTime: Date.now() - startTime,\n    };\n  }\n}\n\n/**\n * Handler cache for compiled functions\n */\nconst handlerCache = new Map<string, (args: unknown, context: ExecutionContext) => unknown>();\n\n/**\n * Get or compile a handler function (cached)\n */\nexport function getOrCompileHandler(\n  primitiveId: string,\n  code: string,\n  config: Partial<SandboxConfig> = {}\n): (args: unknown, context: ExecutionContext) => unknown {\n  const cacheKey = `${primitiveId}:${hashCode(code)}`;\n\n  let handler = handlerCache.get(cacheKey);\n  if (!handler) {\n    handler = createSandboxFunction(code, config);\n    handlerCache.set(cacheKey, handler);\n  }\n\n  return handler;\n}\n\n/**\n * Invalidate cached handler for a primitive\n */\nexport function invalidateHandler(primitiveId: string): void {\n  for (const key of handlerCache.keys()) {\n    if (key.startsWith(`${primitiveId}:`)) {\n      handlerCache.delete(key);\n    }\n  }\n}\n\n/**\n * Clear all cached handlers\n */\nexport function clearHandlerCache(): void {\n  handlerCache.clear();\n}\n\n/**\n * Simple hash function for cache keys\n */\nfunction hashCode(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash);\n}\n","/**\n * Plugin Registry - Manages primitives, plugins, and workflows\n *\n * Two-tier architecture:\n * - Tier 1: In-memory cache (fast access for mounted primitives)\n * - Tier 2: PostgreSQL via Prisma (persistent storage)\n *\n * Read path: Memory -> DB (on cache miss)\n * Write path: Memory + DB (write-through)\n */\n\nimport { prisma } from '../db';\nimport type {\n  PrimitiveDefinition,\n  MountedPrimitive,\n  PluginDefinition,\n  WorkflowDefinition,\n  PrimitiveInfo,\n  PluginInfo,\n  RegistryStats,\n  CreatePrimitiveRequest,\n  UpdatePrimitiveRequest,\n  CreatePluginRequest,\n  JSONSchema,\n} from './types';\nimport { generateId, incrementVersion, slugify } from './types';\nimport { validateHandlerSecurity, createSandboxFunction, invalidateHandler } from './sandbox';\n\n/**\n * Plugin Registry - Singleton class managing the plugin system\n */\nexport class PluginRegistry {\n  // Tier 1: In-memory mounted primitives\n  private mountedPrimitives: Map<string, MountedPrimitive> = new Map();\n\n  // In-memory primitive definitions cache\n  private primitiveCache: Map<string, PrimitiveDefinition> = new Map();\n\n  // Compiled handlers cache\n  private handlerCache: Map<string, Function> = new Map();\n\n  // Initialization flag\n  private initialized: boolean = false;\n\n  /**\n   * Initialize the registry - load primitives from DB into memory\n   */\n  async initialize(): Promise<{ loaded: number; mounted: number; errors: string[] }> {\n    if (this.initialized) {\n      return { loaded: 0, mounted: 0, errors: [] };\n    }\n\n    const errors: string[] = [];\n    let loaded = 0;\n    let mounted = 0;\n\n    try {\n      // Load all enabled primitives from DB\n      const primitives = await prisma.primitive.findMany({\n        where: { enabled: true },\n      });\n\n      for (const dbPrimitive of primitives) {\n        try {\n          const definition = this.dbToPrimitiveDefinition(dbPrimitive);\n          this.primitiveCache.set(definition.id, definition);\n          loaded++;\n\n          // Auto-mount all enabled primitives\n          const mountResult = this.mountPrimitive(definition.id);\n          if (mountResult.success) {\n            mounted++;\n          } else {\n            errors.push(`Failed to mount ${definition.name}: ${mountResult.error}`);\n          }\n        } catch (e) {\n          errors.push(`Failed to load primitive ${dbPrimitive.id}: ${e instanceof Error ? e.message : String(e)}`);\n        }\n      }\n\n      this.initialized = true;\n    } catch (e) {\n      errors.push(`Failed to initialize registry: ${e instanceof Error ? e.message : String(e)}`);\n    }\n\n    return { loaded, mounted, errors };\n  }\n\n  // ============================================================================\n  // PRIMITIVE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Create a new primitive\n   */\n  async createPrimitive(request: CreatePrimitiveRequest): Promise<{ success: boolean; primitiveId?: string; error?: string }> {\n    // Validate handler security\n    const securityCheck = validateHandlerSecurity(request.handler);\n    if (!securityCheck.safe) {\n      return { success: false, error: `Handler security failed: ${securityCheck.blocked.join(', ')}` };\n    }\n\n    // Check for duplicate name\n    const existing = await prisma.primitive.findUnique({ where: { name: request.name } });\n    if (existing) {\n      return { success: false, error: `Primitive with name \"${request.name}\" already exists` };\n    }\n\n    // Validate handler can compile\n    try {\n      createSandboxFunction(request.handler);\n    } catch (e) {\n      return { success: false, error: `Handler compilation failed: ${e instanceof Error ? e.message : String(e)}` };\n    }\n\n    const id = generateId('prim');\n\n    try {\n      // Create in DB\n      const dbPrimitive = await prisma.primitive.create({\n        data: {\n          id,\n          name: request.name,\n          description: request.description,\n          inputSchema: request.inputSchema as object,\n          handler: request.handler,\n          category: request.category,\n          tags: request.tags || [],\n          icon: request.icon,\n          timeout: request.timeout || 30000,\n          enabled: true,\n          pluginId: request.pluginId,\n        },\n      });\n\n      // Add to memory cache\n      const definition = this.dbToPrimitiveDefinition(dbPrimitive);\n      this.primitiveCache.set(id, definition);\n\n      // Auto-mount if requested\n      if (request.autoMount !== false) {\n        const mountResult = this.mountPrimitive(id);\n        if (!mountResult.success) {\n          return { success: true, primitiveId: id, error: `Created but mount failed: ${mountResult.error}` };\n        }\n      }\n\n      return { success: true, primitiveId: id };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * Update an existing primitive\n   */\n  async updatePrimitive(id: string, request: UpdatePrimitiveRequest): Promise<{ success: boolean; error?: string }> {\n    const existing = this.primitiveCache.get(id) || await this.getPrimitiveFromDb(id);\n    if (!existing) {\n      return { success: false, error: `Primitive not found: ${id}` };\n    }\n\n    // Validate new handler if provided\n    if (request.handler) {\n      const securityCheck = validateHandlerSecurity(request.handler);\n      if (!securityCheck.safe) {\n        return { success: false, error: `Handler security failed: ${securityCheck.blocked.join(', ')}` };\n      }\n\n      try {\n        createSandboxFunction(request.handler);\n      } catch (e) {\n        return { success: false, error: `Handler compilation failed: ${e instanceof Error ? e.message : String(e)}` };\n      }\n    }\n\n    try {\n      // Update in DB\n      const updated = await prisma.primitive.update({\n        where: { id },\n        data: {\n          description: request.description ?? existing.description,\n          inputSchema: (request.inputSchema ?? existing.inputSchema) as object,\n          handler: request.handler ?? existing.handler,\n          category: request.category ?? existing.category,\n          tags: request.tags ?? existing.tags,\n          icon: request.icon ?? existing.icon,\n          timeout: request.timeout ?? existing.timeout,\n          enabled: request.enabled ?? existing.enabled,\n          version: incrementVersion(existing.version),\n        },\n      });\n\n      // Update memory cache\n      const definition = this.dbToPrimitiveDefinition(updated);\n      this.primitiveCache.set(id, definition);\n\n      // Invalidate handler cache\n      invalidateHandler(id);\n      this.handlerCache.delete(id);\n\n      // Re-mount if currently mounted\n      if (this.mountedPrimitives.has(id)) {\n        this.dismountPrimitive(id);\n        this.mountPrimitive(id);\n      }\n\n      return { success: true };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * Delete a primitive\n   */\n  async deletePrimitive(id: string, force: boolean = false): Promise<{ success: boolean; error?: string }> {\n    if (this.mountedPrimitives.has(id) && !force) {\n      return { success: false, error: 'Primitive is mounted. Use force=true to dismount and delete.' };\n    }\n\n    // Dismount if mounted\n    if (this.mountedPrimitives.has(id)) {\n      this.dismountPrimitive(id);\n    }\n\n    try {\n      await prisma.primitive.delete({ where: { id } });\n      this.primitiveCache.delete(id);\n      invalidateHandler(id);\n      this.handlerCache.delete(id);\n\n      return { success: true };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * Mount a primitive to make it active\n   */\n  mountPrimitive(id: string, config?: Record<string, unknown>): { success: boolean; error?: string } {\n    const definition = this.primitiveCache.get(id);\n    if (!definition) {\n      return { success: false, error: `Primitive not found in cache: ${id}` };\n    }\n\n    if (this.mountedPrimitives.has(id)) {\n      return { success: false, error: `Primitive already mounted: ${id}` };\n    }\n\n    // Compile handler\n    let compiledHandler: Function;\n    try {\n      compiledHandler = createSandboxFunction(definition.handler);\n      this.handlerCache.set(id, compiledHandler);\n    } catch (e) {\n      return { success: false, error: `Handler compilation failed: ${e instanceof Error ? e.message : String(e)}` };\n    }\n\n    // Mount\n    const mounted: MountedPrimitive = {\n      definition,\n      mountedAt: Date.now(),\n      config,\n      invocationCount: 0,\n      compiledHandler,\n    };\n\n    this.mountedPrimitives.set(id, mounted);\n    return { success: true };\n  }\n\n  /**\n   * Dismount a primitive\n   */\n  dismountPrimitive(id: string): { success: boolean; error?: string } {\n    if (!this.mountedPrimitives.has(id)) {\n      return { success: false, error: `Primitive not mounted: ${id}` };\n    }\n\n    this.mountedPrimitives.delete(id);\n    this.handlerCache.delete(id);\n    invalidateHandler(id);\n\n    return { success: true };\n  }\n\n  /**\n   * Get a mounted primitive by ID or name\n   */\n  getMountedPrimitive(idOrName: string): MountedPrimitive | undefined {\n    // Try by ID first\n    let primitive = this.mountedPrimitives.get(idOrName);\n    if (primitive) return primitive;\n\n    // Try by name\n    for (const mounted of this.mountedPrimitives.values()) {\n      if (mounted.definition.name === idOrName) {\n        return mounted;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get all mounted primitives\n   */\n  getMountedPrimitives(): MountedPrimitive[] {\n    return Array.from(this.mountedPrimitives.values());\n  }\n\n  /**\n   * Get compiled handler for a primitive\n   */\n  getCompiledHandler(id: string): Function | undefined {\n    return this.handlerCache.get(id);\n  }\n\n  /**\n   * Record a primitive invocation\n   */\n  recordInvocation(id: string): void {\n    const mounted = this.mountedPrimitives.get(id);\n    if (mounted) {\n      mounted.invocationCount++;\n      mounted.lastInvoked = Date.now();\n    }\n  }\n\n  /**\n   * List primitives with filtering\n   */\n  async listPrimitives(options: {\n    filter?: 'mounted' | 'available' | 'all';\n    category?: string;\n    tags?: string[];\n    pluginId?: string;\n    search?: string;\n  } = {}): Promise<PrimitiveInfo[]> {\n    const { filter = 'all', category, tags, pluginId, search } = options;\n\n    let primitives: PrimitiveInfo[] = [];\n\n    if (filter === 'mounted') {\n      // Only mounted primitives (from memory)\n      for (const mounted of this.mountedPrimitives.values()) {\n        primitives.push(this.toPrimitiveInfo(mounted.definition, true));\n      }\n    } else {\n      // Query from DB\n      const where: any = {};\n      if (category) where.category = category;\n      if (pluginId) where.pluginId = pluginId;\n      if (tags?.length) where.tags = { hasSome: tags };\n      if (search) {\n        where.OR = [\n          { name: { contains: search, mode: 'insensitive' } },\n          { description: { contains: search, mode: 'insensitive' } },\n        ];\n      }\n\n      const dbPrimitives = await prisma.primitive.findMany({ where });\n\n      for (const dbPrim of dbPrimitives) {\n        const isMounted = this.mountedPrimitives.has(dbPrim.id);\n        if (filter === 'available' && isMounted) continue;\n\n        primitives.push({\n          id: dbPrim.id,\n          name: dbPrim.name,\n          description: dbPrim.description,\n          version: dbPrim.version,\n          tags: dbPrim.tags,\n          category: dbPrim.category || undefined,\n          icon: dbPrim.icon || undefined,\n          mounted: isMounted,\n          enabled: dbPrim.enabled,\n          author: dbPrim.author || undefined,\n          createdAt: dbPrim.createdAt,\n          updatedAt: dbPrim.updatedAt,\n        });\n      }\n    }\n\n    return primitives;\n  }\n\n  // ============================================================================\n  // PLUGIN MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Create a new plugin\n   */\n  async createPlugin(request: CreatePluginRequest): Promise<{ success: boolean; pluginId?: string; error?: string }> {\n    const slug = request.slug || slugify(request.name);\n\n    // Check for duplicate\n    const existing = await prisma.plugin.findFirst({\n      where: { OR: [{ name: request.name }, { slug }] },\n    });\n    if (existing) {\n      return { success: false, error: `Plugin with name or slug already exists` };\n    }\n\n    const id = generateId('plug');\n\n    try {\n      await prisma.plugin.create({\n        data: {\n          id,\n          name: request.name,\n          slug,\n          description: request.description,\n          icon: request.icon,\n          color: request.color,\n          config: request.config as object,\n          configSchema: request.configSchema as object,\n          author: request.author,\n          enabled: false, // Disabled by default\n        },\n      });\n\n      return { success: true, pluginId: id };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * Enable/disable a plugin\n   */\n  async setPluginEnabled(id: string, enabled: boolean): Promise<{ success: boolean; error?: string }> {\n    try {\n      const plugin = await prisma.plugin.findUnique({ where: { id } });\n      if (!plugin) {\n        return { success: false, error: `Plugin not found: ${id}` };\n      }\n\n      // Update plugin\n      await prisma.plugin.update({\n        where: { id },\n        data: { enabled },\n      });\n\n      // Mount/dismount plugin's primitives\n      const primitives = await prisma.primitive.findMany({\n        where: { pluginId: id, enabled: true },\n      });\n\n      for (const prim of primitives) {\n        if (enabled) {\n          const def = this.dbToPrimitiveDefinition(prim);\n          this.primitiveCache.set(prim.id, def);\n          this.mountPrimitive(prim.id);\n        } else {\n          this.dismountPrimitive(prim.id);\n        }\n      }\n\n      return { success: true };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * Delete a plugin and its primitives\n   */\n  async deletePlugin(id: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      // Get primitives to dismount\n      const primitives = await prisma.primitive.findMany({ where: { pluginId: id } });\n\n      for (const prim of primitives) {\n        this.dismountPrimitive(prim.id);\n        this.primitiveCache.delete(prim.id);\n      }\n\n      // Delete plugin (cascades to primitives)\n      await prisma.plugin.delete({ where: { id } });\n\n      return { success: true };\n    } catch (e) {\n      return { success: false, error: `Database error: ${e instanceof Error ? e.message : String(e)}` };\n    }\n  }\n\n  /**\n   * List plugins\n   */\n  async listPlugins(options: {\n    enabled?: boolean;\n    search?: string;\n  } = {}): Promise<PluginInfo[]> {\n    const { enabled, search } = options;\n\n    const where: any = {};\n    if (enabled !== undefined) where.enabled = enabled;\n    if (search) {\n      where.OR = [\n        { name: { contains: search, mode: 'insensitive' } },\n        { description: { contains: search, mode: 'insensitive' } },\n      ];\n    }\n\n    const plugins = await prisma.plugin.findMany({\n      where,\n      include: { _count: { select: { primitives: true } } },\n    });\n\n    return plugins.map(p => ({\n      id: p.id,\n      name: p.name,\n      slug: p.slug,\n      description: p.description || undefined,\n      version: p.version,\n      icon: p.icon || undefined,\n      color: p.color || undefined,\n      enabled: p.enabled,\n      installed: p.installed,\n      builtIn: p.builtIn,\n      primitiveCount: p._count.primitives,\n      author: p.author || undefined,\n      createdAt: p.createdAt,\n      updatedAt: p.updatedAt,\n    }));\n  }\n\n  // ============================================================================\n  // WORKFLOW MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Get workflow by ID\n   */\n  async getWorkflow(id: string): Promise<WorkflowDefinition | null> {\n    const workflow = await prisma.workflow.findUnique({ where: { id } });\n    if (!workflow) return null;\n\n    return {\n      id: workflow.id,\n      name: workflow.name,\n      slug: workflow.slug,\n      description: workflow.description || undefined,\n      nodes: workflow.nodes as any[],\n      edges: workflow.edges as any[],\n      viewport: workflow.viewport as any,\n      config: workflow.config as any,\n      variables: workflow.variables as any,\n      triggerType: workflow.triggerType,\n      triggerConfig: workflow.triggerConfig as any,\n      enabled: workflow.enabled,\n      pluginId: workflow.pluginId,\n      createdAt: workflow.createdAt,\n      updatedAt: workflow.updatedAt,\n      lastRunAt: workflow.lastRunAt || undefined,\n    };\n  }\n\n  /**\n   * List workflows\n   */\n  async listWorkflows(options: {\n    enabled?: boolean;\n    pluginId?: string;\n    triggerType?: string;\n  } = {}): Promise<WorkflowDefinition[]> {\n    const where: any = {};\n    if (options.enabled !== undefined) where.enabled = options.enabled;\n    if (options.pluginId) where.pluginId = options.pluginId;\n    if (options.triggerType) where.triggerType = options.triggerType;\n\n    const workflows = await prisma.workflow.findMany({ where });\n\n    return workflows.map(w => ({\n      id: w.id,\n      name: w.name,\n      slug: w.slug,\n      description: w.description || undefined,\n      nodes: w.nodes as any[],\n      edges: w.edges as any[],\n      viewport: w.viewport as any,\n      config: w.config as any,\n      variables: w.variables as any,\n      triggerType: w.triggerType,\n      triggerConfig: w.triggerConfig as any,\n      enabled: w.enabled,\n      pluginId: w.pluginId,\n      createdAt: w.createdAt,\n      updatedAt: w.updatedAt,\n      lastRunAt: w.lastRunAt || undefined,\n    }));\n  }\n\n  // ============================================================================\n  // STATISTICS\n  // ============================================================================\n\n  /**\n   * Get registry statistics\n   */\n  async getStats(): Promise<RegistryStats> {\n    const [primitiveCount, pluginStats, workflowCount, executionCount] = await Promise.all([\n      prisma.primitive.count(),\n      prisma.plugin.aggregate({\n        _count: true,\n        where: { enabled: true },\n      }),\n      prisma.workflow.count(),\n      prisma.primitiveExecution.count(),\n    ]);\n\n    return {\n      primitiveCount,\n      mountedCount: this.mountedPrimitives.size,\n      pluginCount: await prisma.plugin.count(),\n      enabledPluginCount: pluginStats._count,\n      workflowCount,\n      totalExecutions: executionCount,\n    };\n  }\n\n  // ============================================================================\n  // HELPER METHODS\n  // ============================================================================\n\n  private dbToPrimitiveDefinition(db: any): PrimitiveDefinition {\n    return {\n      id: db.id,\n      name: db.name,\n      version: db.version,\n      description: db.description,\n      inputSchema: db.inputSchema as JSONSchema,\n      handler: db.handler,\n      dependencies: db.dependencies,\n      author: db.author || undefined,\n      tags: db.tags,\n      tier: db.tier,\n      category: db.category || undefined,\n      icon: db.icon || undefined,\n      timeout: db.timeout,\n      memory: db.memory,\n      sandbox: db.sandbox,\n      enabled: db.enabled,\n      builtIn: db.builtIn,\n      pluginId: db.pluginId,\n      createdAt: db.createdAt,\n      updatedAt: db.updatedAt,\n    };\n  }\n\n  private async getPrimitiveFromDb(id: string): Promise<PrimitiveDefinition | null> {\n    const db = await prisma.primitive.findUnique({ where: { id } });\n    if (!db) return null;\n    return this.dbToPrimitiveDefinition(db);\n  }\n\n  private toPrimitiveInfo(def: PrimitiveDefinition, mounted: boolean): PrimitiveInfo {\n    return {\n      id: def.id,\n      name: def.name,\n      description: def.description,\n      version: def.version,\n      tags: def.tags || [],\n      category: def.category,\n      icon: def.icon,\n      mounted,\n      enabled: def.enabled ?? true,\n      author: def.author,\n      createdAt: def.createdAt ?? new Date(),\n      updatedAt: def.updatedAt ?? new Date(),\n    };\n  }\n\n  /**\n   * Check if registry is initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Singleton instance\nlet registryInstance: PluginRegistry | null = null;\n\n/**\n * Get the global plugin registry instance\n */\nexport function getPluginRegistry(): PluginRegistry {\n  if (!registryInstance) {\n    registryInstance = new PluginRegistry();\n  }\n  return registryInstance;\n}\n\n/**\n * Reset the registry (for testing)\n */\nexport function resetPluginRegistry(): void {\n  registryInstance = new PluginRegistry();\n}\n","/**\n * Primitive Executor - Orchestrates execution with validation and sandboxing\n *\n * Ties together:\n * - Input validation\n * - Sandboxed execution\n * - Output validation\n * - Error handling and metrics\n * - Execution logging\n */\n\nimport { prisma } from '../db';\nimport type {\n  PrimitiveDefinition,\n  ExecutionContext,\n  ExecutionResult,\n  JSONSchema,\n} from './types';\nimport { generateId } from './types';\nimport {\n  executeSandbox,\n  validateHandlerSecurity,\n  getOrCompileHandler,\n  type SandboxConfig,\n} from './sandbox';\nimport { getPluginRegistry } from './registry';\n\n/**\n * Execution Options\n */\nexport interface ExecutionOptions {\n  timeout?: number;          // Override default timeout\n  skipValidation?: boolean;  // Skip input validation\n  skipSandbox?: boolean;     // Run without sandbox (trusted code only)\n  recordMetrics?: boolean;   // Record execution to DB (default: true)\n  debug?: boolean;           // Enable debug mode\n}\n\n/**\n * Validate input against JSON Schema\n */\nfunction validateInput(\n  input: Record<string, unknown>,\n  schema: JSONSchema\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  // Check required fields\n  if (schema.required) {\n    for (const field of schema.required) {\n      if (!(field in input)) {\n        errors.push(`Missing required field: ${field}`);\n      }\n    }\n  }\n\n  // Check property types\n  for (const [key, prop] of Object.entries(schema.properties)) {\n    if (key in input) {\n      const value = input[key];\n      const expectedType = prop.type;\n\n      if (expectedType === 'array' && !Array.isArray(value)) {\n        errors.push(`Field \"${key}\" should be an array`);\n      } else if (expectedType === 'object' && (typeof value !== 'object' || value === null || Array.isArray(value))) {\n        errors.push(`Field \"${key}\" should be an object`);\n      } else if (expectedType === 'string' && typeof value !== 'string') {\n        errors.push(`Field \"${key}\" should be a string`);\n      } else if (expectedType === 'number' && typeof value !== 'number') {\n        errors.push(`Field \"${key}\" should be a number`);\n      } else if (expectedType === 'boolean' && typeof value !== 'boolean') {\n        errors.push(`Field \"${key}\" should be a boolean`);\n      }\n\n      // Check enum values\n      if (prop.enum && !prop.enum.includes(value as string)) {\n        errors.push(`Field \"${key}\" must be one of: ${prop.enum.join(', ')}`);\n      }\n\n      // Check string constraints\n      if (typeof value === 'string') {\n        if (prop.minLength && value.length < prop.minLength) {\n          errors.push(`Field \"${key}\" must be at least ${prop.minLength} characters`);\n        }\n        if (prop.maxLength && value.length > prop.maxLength) {\n          errors.push(`Field \"${key}\" must be at most ${prop.maxLength} characters`);\n        }\n        if (prop.pattern && !new RegExp(prop.pattern).test(value)) {\n          errors.push(`Field \"${key}\" must match pattern: ${prop.pattern}`);\n        }\n      }\n\n      // Check number constraints\n      if (typeof value === 'number') {\n        if (prop.minimum !== undefined && value < prop.minimum) {\n          errors.push(`Field \"${key}\" must be at least ${prop.minimum}`);\n        }\n        if (prop.maximum !== undefined && value > prop.maximum) {\n          errors.push(`Field \"${key}\" must be at most ${prop.maximum}`);\n        }\n      }\n    }\n  }\n\n  // Check for extra fields if additionalProperties is false\n  if (schema.additionalProperties === false) {\n    for (const key of Object.keys(input)) {\n      if (!(key in schema.properties)) {\n        errors.push(`Unknown field: ${key}`);\n      }\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Execute a primitive with full validation and sandboxing\n */\nexport async function executePrimitive(\n  primitive: PrimitiveDefinition,\n  args: Record<string, unknown>,\n  context: Partial<ExecutionContext> = {},\n  options: ExecutionOptions = {}\n): Promise<ExecutionResult> {\n  const startTime = Date.now();\n  const invocationId = generateId('exec');\n  const {\n    timeout = primitive.timeout || 30000,\n    skipValidation = false,\n    skipSandbox = false,\n    recordMetrics = true,\n    debug = false,\n  } = options;\n\n  // Build full execution context\n  const execContext: ExecutionContext = {\n    primitiveId: primitive.id,\n    primitiveName: primitive.name,\n    invocationId,\n    startTime,\n    timeout,\n    debug,\n    ...context,\n  };\n\n  try {\n    // Step 1: Input validation\n    if (!skipValidation) {\n      const validation = validateInput(args, primitive.inputSchema);\n      if (!validation.valid) {\n        return createErrorResult(\n          `Input validation failed:\\n- ${validation.errors.join('\\n- ')}`,\n          startTime,\n          invocationId\n        );\n      }\n    }\n\n    // Step 2: Security check on handler\n    const securityCheck = validateHandlerSecurity(primitive.handler);\n    if (!securityCheck.safe) {\n      return createErrorResult(\n        `Handler security validation failed:\\n- ${securityCheck.blocked.join('\\n- ')}`,\n        startTime,\n        invocationId\n      );\n    }\n\n    // Log warnings in debug mode\n    if (debug && securityCheck.warnings.length > 0) {\n      console.warn(`[${primitive.name}] Security warnings:\\n- ${securityCheck.warnings.join('\\n- ')}`);\n    }\n\n    // Step 3: Execute handler\n    let result: unknown;\n\n    if (skipSandbox) {\n      // Direct execution (trusted code only)\n      result = await executeDirectly(primitive, args, execContext, timeout);\n    } else {\n      // Sandboxed execution\n      const sandboxConfig: Partial<SandboxConfig> = {\n        timeout,\n        allowAsync: true,\n        maxOutputSize: 1024 * 1024, // 1MB\n      };\n\n      const sandboxResult = await executeSandbox(\n        primitive.handler,\n        args,\n        execContext,\n        sandboxConfig\n      );\n\n      if (!sandboxResult.success) {\n        const errorResult = createErrorResult(\n          sandboxResult.error || 'Unknown execution error',\n          startTime,\n          invocationId\n        );\n\n        // Record failed execution\n        if (recordMetrics) {\n          await recordExecution(\n            primitive.id,\n            args,\n            null,\n            false,\n            sandboxResult.error,\n            startTime,\n            Date.now(),\n            execContext\n          );\n        }\n\n        return errorResult;\n      }\n\n      result = sandboxResult.result;\n    }\n\n    // Step 4: Success\n    const endTime = Date.now();\n    const executionResult: ExecutionResult = {\n      success: true,\n      result,\n      executionTime: endTime - startTime,\n      invocationId,\n    };\n\n    // Record successful execution\n    if (recordMetrics) {\n      await recordExecution(\n        primitive.id,\n        args,\n        result,\n        true,\n        undefined,\n        startTime,\n        endTime,\n        execContext\n      );\n    }\n\n    // Update registry invocation count\n    const registry = getPluginRegistry();\n    registry.recordInvocation(primitive.id);\n\n    return executionResult;\n\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorResult = createErrorResult(errorMessage, startTime, invocationId);\n\n    // Record failed execution\n    if (recordMetrics) {\n      await recordExecution(\n        primitive.id,\n        args,\n        null,\n        false,\n        errorMessage,\n        startTime,\n        Date.now(),\n        execContext\n      );\n    }\n\n    return errorResult;\n  }\n}\n\n/**\n * Execute handler directly without sandbox (for trusted code)\n */\nasync function executeDirectly(\n  primitive: PrimitiveDefinition,\n  args: Record<string, unknown>,\n  context: ExecutionContext,\n  timeout: number\n): Promise<unknown> {\n  const handler = getOrCompileHandler(primitive.id, primitive.handler);\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Execution timeout after ${timeout}ms`));\n    }, timeout);\n\n    try {\n      const result = handler(args, context);\n\n      if (result instanceof Promise) {\n        result\n          .then((value) => {\n            clearTimeout(timeoutId);\n            resolve(value);\n          })\n          .catch((err) => {\n            clearTimeout(timeoutId);\n            reject(err);\n          });\n      } else {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    } catch (e) {\n      clearTimeout(timeoutId);\n      reject(e);\n    }\n  });\n}\n\n/**\n * Create an error result\n */\nfunction createErrorResult(\n  error: string,\n  startTime: number,\n  invocationId: string\n): ExecutionResult {\n  return {\n    success: false,\n    error,\n    executionTime: Date.now() - startTime,\n    invocationId,\n  };\n}\n\n/**\n * Record execution to database for audit trail\n */\nasync function recordExecution(\n  primitiveId: string,\n  input: Record<string, unknown>,\n  output: unknown,\n  success: boolean,\n  error: string | undefined,\n  startedAt: number,\n  completedAt: number,\n  context: ExecutionContext\n): Promise<void> {\n  try {\n    await prisma.primitiveExecution.create({\n      data: {\n        primitiveId,\n        workflowExecutionId: context.workflowExecutionId,\n        userId: context.userId,\n        agentId: context.agentId,\n        input: input as object,\n        output: output as object,\n        success,\n        error,\n        startedAt: new Date(startedAt),\n        completedAt: new Date(completedAt),\n        executionTime: completedAt - startedAt,\n      },\n    });\n  } catch (e) {\n    // Don't fail execution if metrics recording fails\n    console.error('Failed to record execution:', e);\n  }\n}\n\n/**\n * Test a primitive with sample input\n */\nexport async function testPrimitive(\n  primitive: PrimitiveDefinition,\n  testInput: Record<string, unknown>,\n  context?: Partial<ExecutionContext>\n): Promise<{\n  success: boolean;\n  result?: unknown;\n  error?: string;\n  validationErrors?: string[];\n  securityWarnings?: string[];\n  executionTime: number;\n}> {\n  const startTime = Date.now();\n\n  // Check input validation\n  const inputValidation = validateInput(testInput, primitive.inputSchema);\n\n  // Check handler security\n  const securityCheck = validateHandlerSecurity(primitive.handler);\n\n  // If validation fails, return early\n  if (!inputValidation.valid) {\n    return {\n      success: false,\n      error: 'Input validation failed',\n      validationErrors: inputValidation.errors,\n      securityWarnings: securityCheck.warnings,\n      executionTime: Date.now() - startTime,\n    };\n  }\n\n  if (!securityCheck.safe) {\n    return {\n      success: false,\n      error: 'Handler security check failed',\n      validationErrors: securityCheck.blocked,\n      securityWarnings: securityCheck.warnings,\n      executionTime: Date.now() - startTime,\n    };\n  }\n\n  // Execute (without recording metrics)\n  const result = await executePrimitive(primitive, testInput, context, {\n    recordMetrics: false,\n    debug: true,\n  });\n\n  return {\n    success: result.success,\n    result: result.result,\n    error: result.error,\n    securityWarnings: securityCheck.warnings,\n    executionTime: result.executionTime,\n  };\n}\n\n/**\n * Execute a primitive by ID or name\n */\nexport async function executeByIdOrName(\n  idOrName: string,\n  args: Record<string, unknown>,\n  context?: Partial<ExecutionContext>,\n  options?: ExecutionOptions\n): Promise<ExecutionResult> {\n  const registry = getPluginRegistry();\n  const mounted = registry.getMountedPrimitive(idOrName);\n\n  if (!mounted) {\n    return {\n      success: false,\n      error: `Primitive not found or not mounted: ${idOrName}`,\n      executionTime: 0,\n    };\n  }\n\n  return executePrimitive(mounted.definition, args, context, options);\n}\n\n/**\n * Get execution statistics for a primitive\n */\nexport async function getExecutionStats(primitiveId: string): Promise<{\n  totalExecutions: number;\n  successCount: number;\n  errorCount: number;\n  averageExecutionTime: number;\n  lastExecution?: Date;\n}> {\n  const stats = await prisma.primitiveExecution.aggregate({\n    where: { primitiveId },\n    _count: true,\n    _avg: { executionTime: true },\n  });\n\n  const successCount = await prisma.primitiveExecution.count({\n    where: { primitiveId, success: true },\n  });\n\n  const lastExecution = await prisma.primitiveExecution.findFirst({\n    where: { primitiveId },\n    orderBy: { startedAt: 'desc' },\n    select: { startedAt: true },\n  });\n\n  return {\n    totalExecutions: stats._count,\n    successCount,\n    errorCount: stats._count - successCount,\n    averageExecutionTime: stats._avg.executionTime || 0,\n    lastExecution: lastExecution?.startedAt,\n  };\n}\n\n/**\n * Get recent executions for a primitive\n */\nexport async function getRecentExecutions(\n  primitiveId: string,\n  limit: number = 10\n): Promise<Array<{\n  id: string;\n  success: boolean;\n  error?: string;\n  executionTime: number;\n  startedAt: Date;\n  userId?: string;\n  agentId?: string;\n}>> {\n  const executions = await prisma.primitiveExecution.findMany({\n    where: { primitiveId },\n    orderBy: { startedAt: 'desc' },\n    take: limit,\n    select: {\n      id: true,\n      success: true,\n      error: true,\n      executionTime: true,\n      startedAt: true,\n      userId: true,\n      agentId: true,\n    },\n  });\n\n  return executions.map(e => ({\n    id: e.id,\n    success: e.success,\n    error: e.error || undefined,\n    executionTime: e.executionTime,\n    startedAt: e.startedAt,\n    userId: e.userId || undefined,\n    agentId: e.agentId || undefined,\n  }));\n}\n","/**\n * AI Chat Primitives\n *\n * AI-callable primitives for AI chat functionality.\n * Enables store owners to build custom AI chat interfaces.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const AI_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // SEND MESSAGE\n  // ============================================================================\n  {\n    name: 'ai.chat',\n    description: 'Send a message to the AI assistant and get a response',\n    category: 'ai',\n    tags: ['ai', 'chat', 'assistant', 'conversation'],\n    icon: 'MessageSquare',\n    timeout: 60000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        message: {\n          type: 'string',\n          description: 'User message',\n          minLength: 1,\n        },\n        conversationId: {\n          type: 'string',\n          description: 'Existing conversation ID to continue',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'Custom system prompt (for new conversations)',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        context: {\n          type: 'object',\n          description: 'Additional context (product info, order details, etc.)',\n        },\n      },\n      required: ['message'],\n    },\n    handler: `\n      const { message, conversationId, systemPrompt, userId, context } = input;\n\n      let conversation;\n\n      if (conversationId) {\n        conversation = await prisma.aIConversation.findFirst({\n          where: { id: conversationId, deletedAt: null },\n          include: {\n            messages: { orderBy: { createdAt: 'asc' }, take: 20 },\n          },\n        });\n\n        if (!conversation) {\n          throw new Error('Conversation not found');\n        }\n      } else {\n        // Create new conversation\n        conversation = await prisma.aIConversation.create({\n          data: {\n            userId: userId || null,\n            title: message.substring(0, 50) + (message.length > 50 ? '...' : ''),\n            systemPrompt: systemPrompt || 'You are a helpful e-commerce assistant.',\n            context: context || {},\n          },\n          include: { messages: true },\n        });\n      }\n\n      // Save user message\n      await prisma.aIMessage.create({\n        data: {\n          conversationId: conversation.id,\n          role: 'user',\n          content: message,\n        },\n      });\n\n      // Note: Actual AI response would be generated via API route using AI SDK\n      // This primitive sets up the conversation structure\n      return {\n        conversationId: conversation.id,\n        message,\n        context: conversation.context,\n        previousMessages: conversation.messages.map(m => ({\n          role: m.role,\n          content: m.content,\n          createdAt: m.createdAt,\n        })),\n        systemPrompt: conversation.systemPrompt,\n        note: 'Use /api/ai/chat endpoint for actual AI responses with streaming',\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET CONVERSATIONS\n  // ============================================================================\n  {\n    name: 'ai.getConversations',\n    description: 'Get list of AI chat conversations for a user',\n    category: 'ai',\n    tags: ['ai', 'chat', 'history', 'conversations'],\n    icon: 'MessageCircle',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, page = 1, limit = 20 } = input;\n\n      const where = { userId, deletedAt: null };\n\n      const [conversations, total] = await Promise.all([\n        prisma.aIConversation.findMany({\n          where,\n          include: {\n            messages: {\n              orderBy: { createdAt: 'desc' },\n              take: 1,\n            },\n            _count: { select: { messages: true } },\n          },\n          orderBy: { updatedAt: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.aIConversation.count({ where }),\n      ]);\n\n      return {\n        conversations: conversations.map(c => ({\n          id: c.id,\n          title: c.title,\n          lastMessage: c.messages[0]?.content?.substring(0, 100),\n          messageCount: c._count.messages,\n          createdAt: c.createdAt,\n          updatedAt: c.updatedAt,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET CONVERSATION\n  // ============================================================================\n  {\n    name: 'ai.getConversation',\n    description: 'Get a single conversation with all messages',\n    category: 'ai',\n    tags: ['ai', 'chat', 'conversation', 'messages'],\n    icon: 'MessagesSquare',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        conversationId: {\n          type: 'string',\n          description: 'Conversation ID',\n        },\n        limit: {\n          type: 'number',\n          description: 'Max messages to return',\n          default: 50,\n        },\n        before: {\n          type: 'string',\n          description: 'Get messages before this message ID (for pagination)',\n        },\n      },\n      required: ['conversationId'],\n    },\n    handler: `\n      const { conversationId, limit = 50, before } = input;\n\n      const conversation = await prisma.aIConversation.findFirst({\n        where: { id: conversationId, deletedAt: null },\n      });\n\n      if (!conversation) {\n        throw new Error('Conversation not found');\n      }\n\n      const messageWhere = { conversationId };\n      if (before) {\n        const beforeMsg = await prisma.aIMessage.findUnique({ where: { id: before } });\n        if (beforeMsg) {\n          messageWhere.createdAt = { lt: beforeMsg.createdAt };\n        }\n      }\n\n      const messages = await prisma.aIMessage.findMany({\n        where: messageWhere,\n        orderBy: { createdAt: 'asc' },\n        take: limit,\n      });\n\n      return {\n        id: conversation.id,\n        title: conversation.title,\n        systemPrompt: conversation.systemPrompt,\n        context: conversation.context,\n        messages: messages.map(m => ({\n          id: m.id,\n          role: m.role,\n          content: m.content,\n          toolCalls: m.toolCalls,\n          createdAt: m.createdAt,\n        })),\n        createdAt: conversation.createdAt,\n        updatedAt: conversation.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // DELETE CONVERSATION\n  // ============================================================================\n  {\n    name: 'ai.deleteConversation',\n    description: 'Delete an AI chat conversation',\n    category: 'ai',\n    tags: ['ai', 'chat', 'delete', 'conversation'],\n    icon: 'Trash2',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        conversationId: {\n          type: 'string',\n          description: 'Conversation ID',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (for authorization)',\n        },\n      },\n      required: ['conversationId'],\n    },\n    handler: `\n      const { conversationId, userId } = input;\n\n      const conversation = await prisma.aIConversation.findFirst({\n        where: { id: conversationId, deletedAt: null },\n      });\n\n      if (!conversation) {\n        throw new Error('Conversation not found');\n      }\n\n      // Check ownership if userId provided\n      if (userId && conversation.userId !== userId) {\n        throw new Error('Not authorized to delete this conversation');\n      }\n\n      await prisma.aIConversation.update({\n        where: { id: conversationId },\n        data: { deletedAt: new Date() },\n      });\n\n      return {\n        deleted: true,\n        conversationId,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // UPDATE CONVERSATION\n  // ============================================================================\n  {\n    name: 'ai.updateConversation',\n    description: 'Update conversation title or context',\n    category: 'ai',\n    tags: ['ai', 'chat', 'update', 'conversation'],\n    icon: 'Edit',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        conversationId: {\n          type: 'string',\n          description: 'Conversation ID',\n        },\n        title: {\n          type: 'string',\n          description: 'New conversation title',\n        },\n        context: {\n          type: 'object',\n          description: 'Updated context object',\n        },\n      },\n      required: ['conversationId'],\n    },\n    handler: `\n      const { conversationId, title, context } = input;\n\n      const conversation = await prisma.aIConversation.findFirst({\n        where: { id: conversationId, deletedAt: null },\n      });\n\n      if (!conversation) {\n        throw new Error('Conversation not found');\n      }\n\n      const updateData = {};\n      if (title !== undefined) updateData.title = title;\n      if (context !== undefined) updateData.context = context;\n\n      const updated = await prisma.aIConversation.update({\n        where: { id: conversationId },\n        data: updateData,\n      });\n\n      return {\n        id: updated.id,\n        title: updated.title,\n        context: updated.context,\n        updatedAt: updated.updatedAt,\n      };\n    `,\n  },\n];\n","/**\n * Analytics Primitives\n *\n * AI-callable primitives for event tracking and analytics.\n * Integrates with the existing analytics system in src/lib/analytics/.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const ANALYTICS_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // TRACK EVENT\n  // ============================================================================\n  {\n    name: 'analytics.trackEvent',\n    description: 'Track a custom analytics event',\n    category: 'analytics',\n    tags: ['analytics', 'tracking', 'events'],\n    icon: 'Activity',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        event: {\n          type: 'string',\n          description: 'Event name (e.g., button_click, form_submit)',\n          minLength: 1,\n          maxLength: 100,\n        },\n        category: {\n          type: 'string',\n          description: 'Event category (e.g., engagement, conversion)',\n        },\n        properties: {\n          type: 'object',\n          description: 'Additional event properties',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (if authenticated)',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID',\n        },\n      },\n      required: ['event'],\n    },\n    handler: `\n      const { event, category, properties = {}, userId, sessionId } = input;\n\n      const analyticsEvent = await prisma.analyticsEvent.create({\n        data: {\n          event,\n          category: category || 'custom',\n          properties,\n          userId: userId || null,\n          sessionId: sessionId || null,\n          timestamp: new Date(),\n          url: properties.url || null,\n          referrer: properties.referrer || null,\n          userAgent: properties.userAgent || null,\n        },\n      });\n\n      return {\n        tracked: true,\n        eventId: analyticsEvent.id,\n        event,\n        category: category || 'custom',\n        timestamp: analyticsEvent.timestamp,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // TRACK PAGE VIEW\n  // ============================================================================\n  {\n    name: 'analytics.trackPageView',\n    description: 'Track a page view event',\n    category: 'analytics',\n    tags: ['analytics', 'tracking', 'pageview'],\n    icon: 'Eye',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        url: {\n          type: 'string',\n          description: 'Page URL',\n        },\n        title: {\n          type: 'string',\n          description: 'Page title',\n        },\n        referrer: {\n          type: 'string',\n          description: 'Referrer URL',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (if authenticated)',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID',\n        },\n        userAgent: {\n          type: 'string',\n          description: 'User agent string',\n        },\n      },\n      required: ['url'],\n    },\n    handler: `\n      const { url, title, referrer, userId, sessionId, userAgent } = input;\n\n      const event = await prisma.analyticsEvent.create({\n        data: {\n          event: 'page_view',\n          category: 'navigation',\n          properties: { title },\n          url,\n          referrer: referrer || null,\n          userId: userId || null,\n          sessionId: sessionId || null,\n          userAgent: userAgent || null,\n          timestamp: new Date(),\n        },\n      });\n\n      return {\n        tracked: true,\n        eventId: event.id,\n        url,\n        title,\n        timestamp: event.timestamp,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // TRACK PURCHASE\n  // ============================================================================\n  {\n    name: 'analytics.trackPurchase',\n    description: 'Track an e-commerce purchase event',\n    category: 'analytics',\n    tags: ['analytics', 'tracking', 'ecommerce', 'purchase'],\n    icon: 'ShoppingCart',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID',\n        },\n        total: {\n          type: 'number',\n          description: 'Order total',\n        },\n        currency: {\n          type: 'string',\n          description: 'Currency code',\n          default: 'USD',\n        },\n        items: {\n          type: 'array',\n          description: 'Purchased items',\n          items: {\n            type: 'object',\n            properties: {\n              productId: { type: 'string' },\n              name: { type: 'string' },\n              price: { type: 'number' },\n              quantity: { type: 'number' },\n            },\n          },\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID',\n        },\n      },\n      required: ['orderId', 'total'],\n    },\n    handler: `\n      const { orderId, total, currency = 'USD', items = [], userId, sessionId } = input;\n\n      const event = await prisma.analyticsEvent.create({\n        data: {\n          event: 'purchase',\n          category: 'ecommerce',\n          properties: {\n            orderId,\n            total,\n            currency,\n            items,\n            itemCount: items.length,\n          },\n          userId: userId || null,\n          sessionId: sessionId || null,\n          timestamp: new Date(),\n        },\n      });\n\n      return {\n        tracked: true,\n        eventId: event.id,\n        orderId,\n        total,\n        currency,\n        itemCount: items.length,\n        timestamp: event.timestamp,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET EVENTS\n  // ============================================================================\n  {\n    name: 'analytics.getEvents',\n    description: 'Query analytics events with filtering',\n    category: 'analytics',\n    tags: ['analytics', 'reporting', 'events'],\n    icon: 'BarChart',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        event: {\n          type: 'string',\n          description: 'Filter by event name',\n        },\n        category: {\n          type: 'string',\n          description: 'Filter by category',\n        },\n        userId: {\n          type: 'string',\n          description: 'Filter by user ID',\n        },\n        startDate: {\n          type: 'string',\n          description: 'Start date (ISO 8601)',\n        },\n        endDate: {\n          type: 'string',\n          description: 'End date (ISO 8601)',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 50,\n          maximum: 200,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { event, category, userId, startDate, endDate, page = 1, limit = 50 } = input;\n\n      const where = {};\n      if (event) where.event = event;\n      if (category) where.category = category;\n      if (userId) where.userId = userId;\n      if (startDate || endDate) {\n        where.timestamp = {};\n        if (startDate) where.timestamp.gte = new Date(startDate);\n        if (endDate) where.timestamp.lte = new Date(endDate);\n      }\n\n      const [events, total] = await Promise.all([\n        prisma.analyticsEvent.findMany({\n          where,\n          orderBy: { timestamp: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.analyticsEvent.count({ where }),\n      ]);\n\n      return {\n        events: events.map(e => ({\n          id: e.id,\n          event: e.event,\n          category: e.category,\n          properties: e.properties,\n          url: e.url,\n          userId: e.userId,\n          sessionId: e.sessionId,\n          timestamp: e.timestamp,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET AGGREGATED STATS\n  // ============================================================================\n  {\n    name: 'analytics.getStats',\n    description: 'Get aggregated analytics statistics',\n    category: 'analytics',\n    tags: ['analytics', 'reporting', 'statistics'],\n    icon: 'TrendingUp',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        period: {\n          type: 'string',\n          description: 'Time period',\n          enum: ['today', 'yesterday', '7d', '30d', '90d', 'custom'],\n          default: '7d',\n        },\n        startDate: {\n          type: 'string',\n          description: 'Custom start date (ISO 8601)',\n        },\n        endDate: {\n          type: 'string',\n          description: 'Custom end date (ISO 8601)',\n        },\n        metrics: {\n          type: 'array',\n          description: 'Metrics to include',\n          items: {\n            type: 'string',\n            enum: ['pageViews', 'uniqueVisitors', 'purchases', 'revenue', 'topPages', 'topEvents'],\n          },\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { period = '7d', startDate, endDate, metrics = ['pageViews', 'uniqueVisitors', 'purchases', 'revenue'] } = input;\n\n      // Calculate date range\n      let start, end = new Date();\n      if (period === 'custom' && startDate) {\n        start = new Date(startDate);\n        if (endDate) end = new Date(endDate);\n      } else {\n        const days = { today: 0, yesterday: 1, '7d': 7, '30d': 30, '90d': 90 }[period] || 7;\n        start = new Date();\n        start.setDate(start.getDate() - days);\n        if (period === 'yesterday') {\n          end = new Date(start);\n          end.setDate(end.getDate() + 1);\n        }\n      }\n\n      const where = {\n        timestamp: { gte: start, lte: end },\n      };\n\n      const stats = {};\n\n      if (metrics.includes('pageViews')) {\n        stats.pageViews = await prisma.analyticsEvent.count({\n          where: { ...where, event: 'page_view' },\n        });\n      }\n\n      if (metrics.includes('uniqueVisitors')) {\n        const visitors = await prisma.analyticsEvent.findMany({\n          where: { ...where, event: 'page_view', sessionId: { not: null } },\n          select: { sessionId: true },\n          distinct: ['sessionId'],\n        });\n        stats.uniqueVisitors = visitors.length;\n      }\n\n      if (metrics.includes('purchases')) {\n        stats.purchases = await prisma.analyticsEvent.count({\n          where: { ...where, event: 'purchase' },\n        });\n      }\n\n      if (metrics.includes('revenue')) {\n        const purchases = await prisma.analyticsEvent.findMany({\n          where: { ...where, event: 'purchase' },\n          select: { properties: true },\n        });\n        stats.revenue = purchases.reduce((sum, p) => sum + (p.properties?.total || 0), 0);\n      }\n\n      if (metrics.includes('topPages')) {\n        const pages = await prisma.analyticsEvent.groupBy({\n          by: ['url'],\n          where: { ...where, event: 'page_view', url: { not: null } },\n          _count: { url: true },\n          orderBy: { _count: { url: 'desc' } },\n          take: 10,\n        });\n        stats.topPages = pages.map(p => ({ url: p.url, views: p._count.url }));\n      }\n\n      if (metrics.includes('topEvents')) {\n        const events = await prisma.analyticsEvent.groupBy({\n          by: ['event'],\n          where,\n          _count: { event: true },\n          orderBy: { _count: { event: 'desc' } },\n          take: 10,\n        });\n        stats.topEvents = events.map(e => ({ event: e.event, count: e._count.event }));\n      }\n\n      return {\n        period,\n        startDate: start.toISOString(),\n        endDate: end.toISOString(),\n        ...stats,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // TRACK ADD TO CART\n  // ============================================================================\n  {\n    name: 'analytics.trackAddToCart',\n    description: 'Track add to cart event for e-commerce analytics',\n    category: 'analytics',\n    tags: ['analytics', 'tracking', 'ecommerce', 'cart'],\n    icon: 'ShoppingBag',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Variant ID',\n        },\n        productName: {\n          type: 'string',\n          description: 'Product name',\n        },\n        price: {\n          type: 'number',\n          description: 'Product price',\n        },\n        quantity: {\n          type: 'number',\n          description: 'Quantity added',\n          default: 1,\n        },\n        currency: {\n          type: 'string',\n          description: 'Currency code',\n          default: 'USD',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID',\n        },\n      },\n      required: ['productId'],\n    },\n    handler: `\n      const { productId, variantId, productName, price, quantity = 1, currency = 'USD', userId, sessionId } = input;\n\n      const event = await prisma.analyticsEvent.create({\n        data: {\n          event: 'add_to_cart',\n          category: 'ecommerce',\n          properties: {\n            productId,\n            variantId,\n            productName,\n            price,\n            quantity,\n            currency,\n            value: (price || 0) * quantity,\n          },\n          userId: userId || null,\n          sessionId: sessionId || null,\n          timestamp: new Date(),\n        },\n      });\n\n      return {\n        tracked: true,\n        eventId: event.id,\n        productId,\n        quantity,\n        timestamp: event.timestamp,\n      };\n    `,\n  },\n];\n","/**\n * Blog/CMS Primitives\n *\n * AI-callable primitives for blog and content management.\n * These enable store owners to build custom blog displays via Puck.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const BLOG_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // GET POSTS\n  // ============================================================================\n  {\n    name: 'blog.getPosts',\n    description: 'Get blog posts with pagination, filtering, and sorting',\n    category: 'blog',\n    tags: ['blog', 'cms', 'content', 'posts'],\n    icon: 'FileText',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        page: {\n          type: 'number',\n          description: 'Page number (1-based)',\n          default: 1,\n          minimum: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 10,\n          minimum: 1,\n          maximum: 50,\n        },\n        categoryId: {\n          type: 'string',\n          description: 'Filter by category ID',\n        },\n        categorySlug: {\n          type: 'string',\n          description: 'Filter by category slug',\n        },\n        tagId: {\n          type: 'string',\n          description: 'Filter by tag ID',\n        },\n        tagSlug: {\n          type: 'string',\n          description: 'Filter by tag slug',\n        },\n        authorId: {\n          type: 'string',\n          description: 'Filter by author ID',\n        },\n        featured: {\n          type: 'boolean',\n          description: 'Filter to featured posts only',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by status (admin only)',\n          enum: ['DRAFT', 'PUBLISHED', 'SCHEDULED', 'ARCHIVED'],\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['publishedAt', 'createdAt', 'title', 'views'],\n          default: 'publishedAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { page = 1, limit = 10, categoryId, categorySlug, tagId, tagSlug, authorId, featured, status, sortBy = 'publishedAt', sortOrder = 'desc' } = input;\n\n      const where = { deletedAt: null };\n\n      // Default to published only unless admin\n      where.status = status || 'PUBLISHED';\n      if (!status) {\n        where.publishedAt = { lte: new Date() };\n      }\n\n      if (categoryId) where.categoryId = categoryId;\n      if (categorySlug) {\n        const cat = await prisma.blogCategory.findFirst({ where: { slug: categorySlug } });\n        if (cat) where.categoryId = cat.id;\n      }\n      if (tagId || tagSlug) {\n        where.tags = {\n          some: tagId ? { id: tagId } : { slug: tagSlug },\n        };\n      }\n      if (authorId) where.authorId = authorId;\n      if (featured !== undefined) where.featured = featured;\n\n      const [posts, total] = await Promise.all([\n        prisma.blogPost.findMany({\n          where,\n          include: {\n            author: { select: { id: true, name: true, email: true } },\n            category: { select: { id: true, name: true, slug: true } },\n            tags: { select: { id: true, name: true, slug: true } },\n          },\n          orderBy: { [sortBy]: sortOrder },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.blogPost.count({ where }),\n      ]);\n\n      return {\n        posts: posts.map(p => ({\n          id: p.id,\n          title: p.title,\n          slug: p.slug,\n          excerpt: p.excerpt,\n          featuredImage: p.featuredImage,\n          author: p.author,\n          category: p.category,\n          tags: p.tags,\n          featured: p.featured,\n          publishedAt: p.publishedAt,\n          readingTime: p.readingTime,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n          hasNext: page * limit < total,\n          hasPrev: page > 1,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET SINGLE POST\n  // ============================================================================\n  {\n    name: 'blog.getPost',\n    description: 'Get a single blog post by ID or slug with full content',\n    category: 'blog',\n    tags: ['blog', 'cms', 'content', 'post'],\n    icon: 'FileText',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        postId: {\n          type: 'string',\n          description: 'Post ID',\n        },\n        slug: {\n          type: 'string',\n          description: 'Post slug (alternative to ID)',\n        },\n        incrementViews: {\n          type: 'boolean',\n          description: 'Increment view count',\n          default: true,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { postId, slug, incrementViews = true } = input;\n\n      if (!postId && !slug) {\n        throw new Error('Either postId or slug is required');\n      }\n\n      const where = postId ? { id: postId } : { slug };\n      where.deletedAt = null;\n\n      const post = await prisma.blogPost.findFirst({\n        where,\n        include: {\n          author: { select: { id: true, name: true, email: true, avatar: true } },\n          category: true,\n          tags: true,\n        },\n      });\n\n      if (!post) {\n        throw new Error('Post not found');\n      }\n\n      // Only show published posts to public\n      if (post.status !== 'PUBLISHED' || post.publishedAt > new Date()) {\n        throw new Error('Post not found');\n      }\n\n      // Increment view count\n      if (incrementViews) {\n        await prisma.blogPost.update({\n          where: { id: post.id },\n          data: { views: { increment: 1 } },\n        });\n      }\n\n      // Get related posts\n      const related = await prisma.blogPost.findMany({\n        where: {\n          categoryId: post.categoryId,\n          id: { not: post.id },\n          status: 'PUBLISHED',\n          publishedAt: { lte: new Date() },\n          deletedAt: null,\n        },\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n          excerpt: true,\n          featuredImage: true,\n          publishedAt: true,\n        },\n        take: 3,\n        orderBy: { publishedAt: 'desc' },\n      });\n\n      return {\n        id: post.id,\n        title: post.title,\n        slug: post.slug,\n        content: post.content,\n        excerpt: post.excerpt,\n        featuredImage: post.featuredImage,\n        author: post.author,\n        category: post.category,\n        tags: post.tags,\n        featured: post.featured,\n        views: post.views + (incrementViews ? 1 : 0),\n        publishedAt: post.publishedAt,\n        readingTime: post.readingTime,\n        seo: {\n          title: post.seoTitle || post.title,\n          description: post.seoDescription || post.excerpt,\n          keywords: post.seoKeywords,\n        },\n        related,\n        createdAt: post.createdAt,\n        updatedAt: post.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET CATEGORIES\n  // ============================================================================\n  {\n    name: 'blog.getCategories',\n    description: 'Get all blog categories with post counts',\n    category: 'blog',\n    tags: ['blog', 'cms', 'categories'],\n    icon: 'FolderOpen',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includePostCount: {\n          type: 'boolean',\n          description: 'Include post count per category',\n          default: true,\n        },\n        activeOnly: {\n          type: 'boolean',\n          description: 'Only return categories with published posts',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { includePostCount = true, activeOnly = false } = input;\n\n      const categories = await prisma.blogCategory.findMany({\n        include: {\n          _count: includePostCount ? {\n            select: {\n              posts: {\n                where: { status: 'PUBLISHED', publishedAt: { lte: new Date() }, deletedAt: null },\n              },\n            },\n          } : false,\n        },\n        orderBy: { name: 'asc' },\n      });\n\n      let result = categories.map(c => ({\n        id: c.id,\n        name: c.name,\n        slug: c.slug,\n        description: c.description,\n        postCount: c._count?.posts || 0,\n      }));\n\n      if (activeOnly) {\n        result = result.filter(c => c.postCount > 0);\n      }\n\n      return {\n        categories: result,\n        total: result.length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET TAGS\n  // ============================================================================\n  {\n    name: 'blog.getTags',\n    description: 'Get all blog tags with post counts',\n    category: 'blog',\n    tags: ['blog', 'cms', 'tags'],\n    icon: 'Tag',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includePostCount: {\n          type: 'boolean',\n          description: 'Include post count per tag',\n          default: true,\n        },\n        limit: {\n          type: 'number',\n          description: 'Max tags to return (for tag clouds)',\n          minimum: 1,\n          maximum: 100,\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['name', 'postCount'],\n          default: 'name',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { includePostCount = true, limit, sortBy = 'name' } = input;\n\n      const tags = await prisma.blogTag.findMany({\n        include: {\n          _count: includePostCount ? {\n            select: {\n              posts: {\n                where: { status: 'PUBLISHED', publishedAt: { lte: new Date() }, deletedAt: null },\n              },\n            },\n          } : false,\n        },\n      });\n\n      let result = tags.map(t => ({\n        id: t.id,\n        name: t.name,\n        slug: t.slug,\n        postCount: t._count?.posts || 0,\n      }));\n\n      // Sort\n      if (sortBy === 'postCount') {\n        result.sort((a, b) => b.postCount - a.postCount);\n      } else {\n        result.sort((a, b) => a.name.localeCompare(b.name));\n      }\n\n      // Limit\n      if (limit) {\n        result = result.slice(0, limit);\n      }\n\n      return {\n        tags: result,\n        total: result.length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // SEARCH POSTS\n  // ============================================================================\n  {\n    name: 'blog.search',\n    description: 'Search blog posts by keyword',\n    category: 'blog',\n    tags: ['blog', 'cms', 'search'],\n    icon: 'Search',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        query: {\n          type: 'string',\n          description: 'Search query',\n          minLength: 2,\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 10,\n        },\n      },\n      required: ['query'],\n    },\n    handler: `\n      const { query, page = 1, limit = 10 } = input;\n\n      const where = {\n        status: 'PUBLISHED',\n        publishedAt: { lte: new Date() },\n        deletedAt: null,\n        OR: [\n          { title: { contains: query, mode: 'insensitive' } },\n          { content: { contains: query, mode: 'insensitive' } },\n          { excerpt: { contains: query, mode: 'insensitive' } },\n        ],\n      };\n\n      const [posts, total] = await Promise.all([\n        prisma.blogPost.findMany({\n          where,\n          include: {\n            author: { select: { id: true, name: true } },\n            category: { select: { id: true, name: true, slug: true } },\n          },\n          orderBy: { publishedAt: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.blogPost.count({ where }),\n      ]);\n\n      return {\n        query,\n        results: posts.map(p => ({\n          id: p.id,\n          title: p.title,\n          slug: p.slug,\n          excerpt: p.excerpt,\n          featuredImage: p.featuredImage,\n          author: p.author,\n          category: p.category,\n          publishedAt: p.publishedAt,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET PAGES\n  // ============================================================================\n  {\n    name: 'blog.getPages',\n    description: 'Get CMS pages (about, contact, etc.)',\n    category: 'blog',\n    tags: ['cms', 'pages', 'content'],\n    icon: 'Layout',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        status: {\n          type: 'string',\n          description: 'Filter by status',\n          enum: ['DRAFT', 'PUBLISHED'],\n        },\n        includeContent: {\n          type: 'boolean',\n          description: 'Include full page content',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { status = 'PUBLISHED', includeContent = false } = input;\n\n      const pages = await prisma.page.findMany({\n        where: { status, deletedAt: null },\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n          description: true,\n          template: true,\n          content: includeContent,\n          puckContent: includeContent,\n          order: true,\n          showInNav: true,\n          createdAt: true,\n          updatedAt: true,\n        },\n        orderBy: { order: 'asc' },\n      });\n\n      return {\n        pages,\n        total: pages.length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET SINGLE PAGE\n  // ============================================================================\n  {\n    name: 'blog.getPage',\n    description: 'Get a single CMS page by slug',\n    category: 'blog',\n    tags: ['cms', 'pages', 'content'],\n    icon: 'Layout',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        slug: {\n          type: 'string',\n          description: 'Page slug',\n        },\n        pageId: {\n          type: 'string',\n          description: 'Page ID (alternative to slug)',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { slug, pageId } = input;\n\n      if (!slug && !pageId) {\n        throw new Error('Either slug or pageId is required');\n      }\n\n      const where = pageId ? { id: pageId } : { slug };\n      where.status = 'PUBLISHED';\n      where.deletedAt = null;\n\n      const page = await prisma.page.findFirst({ where });\n\n      if (!page) {\n        throw new Error('Page not found');\n      }\n\n      return {\n        id: page.id,\n        title: page.title,\n        slug: page.slug,\n        description: page.description,\n        content: page.content,\n        puckContent: page.puckContent,\n        template: page.template,\n        seo: {\n          title: page.seoTitle || page.title,\n          description: page.seoDescription || page.description,\n        },\n        createdAt: page.createdAt,\n        updatedAt: page.updatedAt,\n      };\n    `,\n  },\n];\n","/**\n * Cart Primitives\n *\n * Primitives for shopping cart management including items,\n * coupons, and shipping rate calculations.\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const CART_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // CART RETRIEVAL\n  // ============================================================================\n  {\n    name: 'cart.get',\n    description: 'Get a cart by ID, session ID, or user ID. Returns cart with items and totals.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'get'],\n    icon: 'ShoppingCart',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID to retrieve',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID (for guest carts)',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (for logged-in users)',\n        },\n        includeItems: {\n          type: 'boolean',\n          description: 'Include cart items in response (default: true)',\n          default: true,\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      let cart = null;\n      const include = args.includeItems !== false ? {\n        items: {\n          include: {\n            product: { select: { id: true, slug: true, status: true } },\n            variant: { select: { id: true, sku: true, inventory: true } },\n          },\n          orderBy: { createdAt: 'asc' },\n        },\n      } : undefined;\n\n      if (args.cartId) {\n        cart = await prisma.cart.findUnique({\n          where: { id: args.cartId },\n          include,\n        });\n      } else if (args.sessionId) {\n        cart = await prisma.cart.findFirst({\n          where: { sessionId: args.sessionId, status: 'ACTIVE' },\n          include,\n        });\n      } else if (args.userId) {\n        cart = await prisma.cart.findFirst({\n          where: { userId: args.userId, status: 'ACTIVE' },\n          include,\n        });\n      } else {\n        throw new Error('Must provide cartId, sessionId, or userId');\n      }\n\n      return cart;\n    `,\n  },\n\n  // ============================================================================\n  // CART CREATION\n  // ============================================================================\n  {\n    name: 'cart.create',\n    description: 'Create a new shopping cart for a session or user.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'create'],\n    icon: 'ShoppingCart',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for guest cart',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID for logged-in user cart',\n        },\n        email: {\n          type: 'string',\n          description: 'Email for cart recovery',\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.sessionId && !args.userId) {\n        throw new Error('Must provide sessionId or userId');\n      }\n\n      // Check for existing active cart\n      const existing = await prisma.cart.findFirst({\n        where: {\n          OR: [\n            args.sessionId ? { sessionId: args.sessionId, status: 'ACTIVE' } : {},\n            args.userId ? { userId: args.userId, status: 'ACTIVE' } : {},\n          ].filter(c => Object.keys(c).length > 0),\n        },\n      });\n\n      if (existing) {\n        return existing;\n      }\n\n      // Create new cart\n      const cart = await prisma.cart.create({\n        data: {\n          sessionId: args.sessionId,\n          userId: args.userId,\n          email: args.email,\n          status: 'ACTIVE',\n          subtotal: 0,\n          discountTotal: 0,\n          taxTotal: 0,\n          shippingTotal: 0,\n          total: 0,\n        },\n      });\n\n      return cart;\n    `,\n  },\n\n  // ============================================================================\n  // CART ITEM MANAGEMENT\n  // ============================================================================\n  {\n    name: 'cart.addItem',\n    description: 'Add a product to the cart. Creates cart item or increments quantity if exists.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'add', 'item'],\n    icon: 'Plus',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n        productId: {\n          type: 'string',\n          description: 'Product ID to add',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Product variant ID (optional)',\n        },\n        quantity: {\n          type: 'number',\n          description: 'Quantity to add (default: 1)',\n          default: 1,\n        },\n      },\n      required: ['cartId', 'productId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const quantity = args.quantity || 1;\n\n      // Get product and variant info\n      const product = await prisma.product.findUnique({\n        where: { id: args.productId },\n        include: {\n          images: { take: 1, orderBy: { position: 'asc' } },\n          variants: args.variantId ? { where: { id: args.variantId } } : undefined,\n        },\n      });\n\n      if (!product) {\n        throw new Error('Product not found');\n      }\n\n      if (product.status !== 'ACTIVE') {\n        throw new Error('Product is not available');\n      }\n\n      const variant = args.variantId ? product.variants?.[0] : null;\n      const price = variant?.price ?? product.price;\n      const imageUrl = product.images[0]?.url || null;\n\n      // Check for existing item\n      const existingItem = await prisma.cartItem.findFirst({\n        where: {\n          cartId: args.cartId,\n          productId: args.productId,\n          variantId: args.variantId || null,\n        },\n      });\n\n      let item;\n      if (existingItem) {\n        // Update quantity\n        item = await prisma.cartItem.update({\n          where: { id: existingItem.id },\n          data: { quantity: existingItem.quantity + quantity },\n        });\n      } else {\n        // Create new item\n        item = await prisma.cartItem.create({\n          data: {\n            cartId: args.cartId,\n            productId: args.productId,\n            variantId: args.variantId || null,\n            quantity,\n            title: product.title,\n            variantTitle: variant?.title || null,\n            price,\n            imageUrl,\n          },\n        });\n      }\n\n      // Recalculate cart totals\n      const items = await prisma.cartItem.findMany({\n        where: { cartId: args.cartId },\n      });\n\n      const subtotal = items.reduce((sum, i) => sum + (i.price * i.quantity), 0);\n\n      await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          subtotal,\n          total: subtotal, // Will be adjusted when discount/shipping applied\n        },\n      });\n\n      return item;\n    `,\n  },\n  {\n    name: 'cart.updateItem',\n    description: 'Update quantity of a cart item.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'update', 'item'],\n    icon: 'Edit',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n        itemId: {\n          type: 'string',\n          description: 'Cart item ID',\n        },\n        quantity: {\n          type: 'number',\n          description: 'New quantity (0 removes item)',\n        },\n      },\n      required: ['cartId', 'itemId', 'quantity'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (args.quantity <= 0) {\n        // Remove item\n        await prisma.cartItem.delete({\n          where: { id: args.itemId },\n        });\n      } else {\n        // Update quantity\n        await prisma.cartItem.update({\n          where: { id: args.itemId },\n          data: { quantity: args.quantity },\n        });\n      }\n\n      // Recalculate cart totals\n      const items = await prisma.cartItem.findMany({\n        where: { cartId: args.cartId },\n      });\n\n      const subtotal = items.reduce((sum, i) => sum + (i.price * i.quantity), 0);\n\n      const cart = await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          subtotal,\n          total: subtotal - (await prisma.cart.findUnique({ where: { id: args.cartId } }))?.discountTotal || 0,\n        },\n        include: { items: true },\n      });\n\n      return cart;\n    `,\n  },\n  {\n    name: 'cart.removeItem',\n    description: 'Remove an item from the cart.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'remove', 'item'],\n    icon: 'Trash',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n        itemId: {\n          type: 'string',\n          description: 'Cart item ID to remove',\n        },\n      },\n      required: ['cartId', 'itemId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      await prisma.cartItem.delete({\n        where: { id: args.itemId },\n      });\n\n      // Recalculate cart totals\n      const items = await prisma.cartItem.findMany({\n        where: { cartId: args.cartId },\n      });\n\n      const subtotal = items.reduce((sum, i) => sum + (i.price * i.quantity), 0);\n      const cart = await prisma.cart.findUnique({ where: { id: args.cartId } });\n\n      const updated = await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          subtotal,\n          total: subtotal - (cart?.discountTotal || 0) + (cart?.shippingTotal || 0) + (cart?.taxTotal || 0),\n        },\n        include: { items: true },\n      });\n\n      return updated;\n    `,\n  },\n  {\n    name: 'cart.clear',\n    description: 'Remove all items from a cart.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'clear'],\n    icon: 'Trash2',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID to clear',\n        },\n      },\n      required: ['cartId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      // Delete all items\n      await prisma.cartItem.deleteMany({\n        where: { cartId: args.cartId },\n      });\n\n      // Reset cart totals\n      const cart = await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          subtotal: 0,\n          discountTotal: 0,\n          taxTotal: 0,\n          shippingTotal: 0,\n          total: 0,\n          discountCodeId: null,\n        },\n        include: { items: true },\n      });\n\n      return cart;\n    `,\n  },\n\n  // ============================================================================\n  // COUPON/DISCOUNT MANAGEMENT\n  // ============================================================================\n  {\n    name: 'cart.applyCoupon',\n    description: 'Apply a discount code to the cart.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'coupon', 'discount'],\n    icon: 'Tag',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n        code: {\n          type: 'string',\n          description: 'Discount code to apply',\n        },\n        email: {\n          type: 'string',\n          description: 'Customer email (for usage validation)',\n        },\n      },\n      required: ['cartId', 'code'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      // Find the discount code\n      const discount = await prisma.discountCode.findUnique({\n        where: { code: args.code.toUpperCase() },\n      });\n\n      if (!discount) {\n        throw new Error('Invalid discount code');\n      }\n\n      // Check if active\n      if (!discount.isActive) {\n        throw new Error('Discount code is not active');\n      }\n\n      // Check dates\n      const now = new Date();\n      if (discount.startDate && discount.startDate > now) {\n        throw new Error('Discount code is not yet valid');\n      }\n      if (discount.endDate && discount.endDate < now) {\n        throw new Error('Discount code has expired');\n      }\n\n      // Check usage limit\n      if (discount.usageLimit && discount.usageCount >= discount.usageLimit) {\n        throw new Error('Discount code usage limit reached');\n      }\n\n      // Check per-customer limit\n      if (discount.perCustomerLimit && args.email) {\n        const customerUsage = await prisma.discountUsage.count({\n          where: {\n            discountCodeId: discount.id,\n            email: args.email,\n          },\n        });\n        if (customerUsage >= discount.perCustomerLimit) {\n          throw new Error('You have already used this discount code');\n        }\n      }\n\n      // Get cart\n      const cart = await prisma.cart.findUnique({\n        where: { id: args.cartId },\n        include: { items: true },\n      });\n\n      if (!cart) {\n        throw new Error('Cart not found');\n      }\n\n      // Check minimum order value\n      if (discount.minOrderValue && cart.subtotal < discount.minOrderValue) {\n        throw new Error('Order does not meet minimum value for this discount');\n      }\n\n      // Calculate discount amount\n      let discountAmount = 0;\n\n      if (discount.type === 'PERCENTAGE') {\n        discountAmount = Math.floor(cart.subtotal * (discount.value / 100));\n        if (discount.maxDiscount) {\n          discountAmount = Math.min(discountAmount, discount.maxDiscount);\n        }\n      } else if (discount.type === 'FIXED') {\n        discountAmount = discount.value;\n      } else if (discount.type === 'FREE_SHIPPING') {\n        discountAmount = cart.shippingTotal;\n      }\n\n      // Don't discount more than the subtotal\n      discountAmount = Math.min(discountAmount, cart.subtotal);\n\n      // Update cart\n      const updated = await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          discountCodeId: discount.id,\n          discountTotal: discountAmount,\n          total: cart.subtotal - discountAmount + cart.shippingTotal + cart.taxTotal,\n        },\n        include: { items: true },\n      });\n\n      return {\n        cart: updated,\n        discount: {\n          code: discount.code,\n          type: discount.type,\n          value: discount.value,\n          discountAmount,\n        },\n      };\n    `,\n  },\n  {\n    name: 'cart.removeCoupon',\n    description: 'Remove applied discount code from the cart.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'coupon', 'remove'],\n    icon: 'X',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n      },\n      required: ['cartId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const cart = await prisma.cart.findUnique({\n        where: { id: args.cartId },\n      });\n\n      if (!cart) {\n        throw new Error('Cart not found');\n      }\n\n      const updated = await prisma.cart.update({\n        where: { id: args.cartId },\n        data: {\n          discountCodeId: null,\n          discountTotal: 0,\n          total: cart.subtotal + cart.shippingTotal + cart.taxTotal,\n        },\n        include: { items: true },\n      });\n\n      return updated;\n    `,\n  },\n\n  // ============================================================================\n  // SHIPPING\n  // ============================================================================\n  {\n    name: 'cart.getShippingRates',\n    description: 'Get available shipping rates for the cart based on address.',\n    category: 'cart',\n    tags: ['cart', 'ecommerce', 'shipping', 'rates'],\n    icon: 'Truck',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cartId: {\n          type: 'string',\n          description: 'Cart ID',\n        },\n        address: {\n          type: 'object',\n          description: 'Shipping address',\n          properties: {\n            street1: { type: 'string' },\n            street2: { type: 'string' },\n            city: { type: 'string' },\n            state: { type: 'string' },\n            postalCode: { type: 'string' },\n            country: { type: 'string' },\n          },\n          required: ['city', 'state', 'postalCode', 'country'],\n        },\n      },\n      required: ['cartId', 'address'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const cart = await prisma.cart.findUnique({\n        where: { id: args.cartId },\n        include: { items: { include: { product: true, variant: true } } },\n      });\n\n      if (!cart || cart.items.length === 0) {\n        throw new Error('Cart is empty');\n      }\n\n      // Calculate total weight\n      let totalWeightGrams = 0;\n      for (const item of cart.items) {\n        const weight = item.variant?.weight ?? item.product?.weight ?? 100; // Default 100g\n        totalWeightGrams += weight * item.quantity;\n      }\n\n      // Try to get rates from Shippo if configured\n      try {\n        const { getShippingRates } = await import('../../shippo');\n        const rates = await getShippingRates({\n          addressTo: {\n            street1: args.address.street1,\n            street2: args.address.street2,\n            city: args.address.city,\n            state: args.address.state,\n            zip: args.address.postalCode,\n            country: args.address.country,\n          },\n          parcels: [{\n            length: 10,\n            width: 10,\n            height: 10,\n            weight: totalWeightGrams / 1000, // Convert to kg\n            massUnit: 'kg',\n            distanceUnit: 'cm',\n          }],\n        });\n\n        return {\n          rates: rates.map(r => ({\n            id: r.objectId,\n            carrier: r.provider,\n            service: r.servicelevel?.name || 'Standard',\n            price: Math.round(parseFloat(r.amount) * 100), // Convert to cents\n            currency: r.currency,\n            estimatedDays: r.estimatedDays,\n          })),\n        };\n      } catch (e) {\n        // Fallback to flat rate shipping\n        return {\n          rates: [\n            {\n              id: 'flat_standard',\n              carrier: 'Flat Rate',\n              service: 'Standard Shipping',\n              price: 999, // $9.99\n              currency: 'USD',\n              estimatedDays: 5,\n            },\n            {\n              id: 'flat_express',\n              carrier: 'Flat Rate',\n              service: 'Express Shipping',\n              price: 1999, // $19.99\n              currency: 'USD',\n              estimatedDays: 2,\n            },\n          ],\n        };\n      }\n    `,\n  },\n];\n","/**\n * Customer Primitives\n *\n * Primitives for customer portal functionality including profile management,\n * order history, addresses, subscriptions, and digital downloads.\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const CUSTOMER_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // PROFILE PRIMITIVES\n  // ============================================================================\n  {\n    name: 'customer.getProfile',\n    description: 'Get the current authenticated customer\\'s profile information including name, email, and account details.',\n    category: 'customer',\n    tags: ['customer', 'profile', 'account'],\n    icon: 'User',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The user ID to fetch profile for',\n        },\n        include: {\n          type: 'array',\n          description: 'Related data to include: addresses, orders, subscriptions',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const includeOptions = {};\n      if (args.include?.includes('addresses')) includeOptions.addresses = true;\n      if (args.include?.includes('orders')) includeOptions.orders = { take: 5, orderBy: { createdAt: 'desc' } };\n      if (args.include?.includes('subscriptions')) includeOptions.subscriptions = true;\n\n      const user = await prisma.user.findUnique({\n        where: { id: args.userId },\n        include: includeOptions,\n      });\n\n      if (!user) {\n        throw new Error('Customer not found');\n      }\n\n      return {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        avatar: user.avatar,\n        createdAt: user.createdAt,\n        ...user,\n      };\n    `,\n  },\n  {\n    name: 'customer.updateProfile',\n    description: 'Update the customer\\'s profile information such as name, email, or avatar.',\n    category: 'customer',\n    tags: ['customer', 'profile', 'update'],\n    icon: 'UserCog',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The user ID to update',\n        },\n        name: {\n          type: 'string',\n          description: 'New display name',\n        },\n        avatar: {\n          type: 'string',\n          description: 'New avatar URL',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const updateData = {};\n      if (args.name !== undefined) updateData.name = args.name;\n      if (args.avatar !== undefined) updateData.avatar = args.avatar;\n\n      const user = await prisma.user.update({\n        where: { id: args.userId },\n        data: updateData,\n      });\n\n      return {\n        success: true,\n        user: {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          avatar: user.avatar,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // ORDER PRIMITIVES\n  // ============================================================================\n  {\n    name: 'customer.getOrders',\n    description: 'Get a paginated list of orders for the customer with filtering options.',\n    category: 'customer',\n    tags: ['customer', 'orders', 'history'],\n    icon: 'ShoppingBag',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by order status',\n          enum: ['PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'REFUNDED'],\n        },\n        page: {\n          type: 'number',\n          description: 'Page number (1-indexed)',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 10,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const page = args.page || 1;\n      const limit = Math.min(args.limit || 10, 50);\n      const skip = (page - 1) * limit;\n\n      const where = { customerId: args.userId };\n      if (args.status) where.status = args.status;\n\n      const [orders, total] = await Promise.all([\n        prisma.order.findMany({\n          where,\n          include: {\n            items: {\n              include: {\n                product: { select: { title: true, slug: true } },\n              },\n            },\n            shipments: { select: { trackingNumber: true, carrier: true, status: true } },\n          },\n          orderBy: { createdAt: 'desc' },\n          skip,\n          take: limit,\n        }),\n        prisma.order.count({ where }),\n      ]);\n\n      return {\n        orders: orders.map(o => ({\n          id: o.id,\n          orderNumber: o.orderNumber,\n          status: o.status,\n          paymentStatus: o.paymentStatus,\n          total: o.total,\n          itemCount: o.items.length,\n          items: o.items,\n          shipments: o.shipments,\n          createdAt: o.createdAt,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n  {\n    name: 'customer.getOrder',\n    description: 'Get detailed information about a specific order including items, shipping, and payment details.',\n    category: 'customer',\n    tags: ['customer', 'order', 'detail'],\n    icon: 'Receipt',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID (for authorization)',\n        },\n        orderId: {\n          type: 'string',\n          description: 'The order ID or order number',\n        },\n      },\n      required: ['userId', 'orderId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const order = await prisma.order.findFirst({\n        where: {\n          OR: [\n            { id: args.orderId },\n            { orderNumber: args.orderId },\n          ],\n          customerId: args.userId,\n        },\n        include: {\n          items: {\n            include: {\n              product: { select: { id: true, title: true, slug: true } },\n              variant: { select: { id: true, sku: true } },\n            },\n          },\n          shipments: true,\n          payments: true,\n          shippingAddress: true,\n          billingAddress: true,\n          progress: {\n            include: { stage: true },\n            orderBy: { createdAt: 'desc' },\n          },\n        },\n      });\n\n      if (!order) {\n        throw new Error('Order not found');\n      }\n\n      return order;\n    `,\n  },\n\n  // ============================================================================\n  // ADDRESS PRIMITIVES\n  // ============================================================================\n  {\n    name: 'customer.getAddresses',\n    description: 'Get all saved addresses for the customer.',\n    category: 'customer',\n    tags: ['customer', 'addresses', 'shipping'],\n    icon: 'MapPin',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by address type',\n          enum: ['SHIPPING', 'BILLING'],\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const where = { userId: args.userId };\n      if (args.type) where.type = args.type;\n\n      const addresses = await prisma.address.findMany({\n        where,\n        orderBy: [\n          { isDefault: 'desc' },\n          { createdAt: 'desc' },\n        ],\n      });\n\n      return { addresses };\n    `,\n  },\n  {\n    name: 'customer.saveAddress',\n    description: 'Create or update a customer address.',\n    category: 'customer',\n    tags: ['customer', 'address', 'save'],\n    icon: 'MapPinPlus',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        addressId: {\n          type: 'string',\n          description: 'Address ID to update (omit to create new)',\n        },\n        type: {\n          type: 'string',\n          description: 'Address type',\n          enum: ['SHIPPING', 'BILLING'],\n        },\n        firstName: {\n          type: 'string',\n          description: 'First name',\n        },\n        lastName: {\n          type: 'string',\n          description: 'Last name',\n        },\n        company: {\n          type: 'string',\n          description: 'Company name',\n        },\n        street1: {\n          type: 'string',\n          description: 'Street address line 1',\n        },\n        street2: {\n          type: 'string',\n          description: 'Street address line 2',\n        },\n        city: {\n          type: 'string',\n          description: 'City',\n        },\n        state: {\n          type: 'string',\n          description: 'State/Province',\n        },\n        zip: {\n          type: 'string',\n          description: 'ZIP/Postal code',\n        },\n        country: {\n          type: 'string',\n          description: 'Country code',\n          default: 'US',\n        },\n        phone: {\n          type: 'string',\n          description: 'Phone number',\n        },\n        isDefault: {\n          type: 'boolean',\n          description: 'Set as default address',\n        },\n      },\n      required: ['userId', 'firstName', 'lastName', 'street1', 'city', 'state', 'zip'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const addressData = {\n        type: args.type || 'SHIPPING',\n        firstName: args.firstName,\n        lastName: args.lastName,\n        company: args.company,\n        street1: args.street1,\n        street2: args.street2,\n        city: args.city,\n        state: args.state,\n        zip: args.zip,\n        country: args.country || 'US',\n        phone: args.phone,\n        isDefault: args.isDefault || false,\n      };\n\n      // If setting as default, unset other defaults first\n      if (args.isDefault) {\n        await prisma.address.updateMany({\n          where: { userId: args.userId, type: addressData.type },\n          data: { isDefault: false },\n        });\n      }\n\n      let address;\n      if (args.addressId) {\n        // Update existing\n        address = await prisma.address.update({\n          where: { id: args.addressId, userId: args.userId },\n          data: addressData,\n        });\n      } else {\n        // Create new\n        address = await prisma.address.create({\n          data: {\n            ...addressData,\n            userId: args.userId,\n          },\n        });\n      }\n\n      return { success: true, address };\n    `,\n  },\n  {\n    name: 'customer.deleteAddress',\n    description: 'Delete a saved address.',\n    category: 'customer',\n    tags: ['customer', 'address', 'delete'],\n    icon: 'MapPinOff',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        addressId: {\n          type: 'string',\n          description: 'The address ID to delete',\n        },\n      },\n      required: ['userId', 'addressId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      await prisma.address.delete({\n        where: {\n          id: args.addressId,\n          userId: args.userId,\n        },\n      });\n\n      return { success: true };\n    `,\n  },\n\n  // ============================================================================\n  // SUBSCRIPTION PRIMITIVES\n  // ============================================================================\n  {\n    name: 'customer.getSubscriptions',\n    description: 'Get all active and past subscriptions for the customer.',\n    category: 'customer',\n    tags: ['customer', 'subscriptions', 'recurring'],\n    icon: 'RefreshCw',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by status',\n          enum: ['ACTIVE', 'PAUSED', 'CANCELLED', 'EXPIRED'],\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const where = { userId: args.userId };\n      if (args.status) where.status = args.status;\n\n      const subscriptions = await prisma.subscription.findMany({\n        where,\n        include: {\n          product: {\n            select: { id: true, title: true, slug: true },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n      });\n\n      return { subscriptions };\n    `,\n  },\n  {\n    name: 'customer.cancelSubscription',\n    description: 'Cancel an active subscription.',\n    category: 'customer',\n    tags: ['customer', 'subscription', 'cancel'],\n    icon: 'XCircle',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        subscriptionId: {\n          type: 'string',\n          description: 'The subscription ID to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Cancellation reason',\n        },\n        cancelImmediately: {\n          type: 'boolean',\n          description: 'Cancel immediately vs at period end',\n          default: false,\n        },\n      },\n      required: ['userId', 'subscriptionId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      // Verify ownership\n      const subscription = await prisma.subscription.findFirst({\n        where: {\n          id: args.subscriptionId,\n          userId: args.userId,\n          status: 'ACTIVE',\n        },\n      });\n\n      if (!subscription) {\n        throw new Error('Active subscription not found');\n      }\n\n      // Cancel in Stripe if applicable\n      if (subscription.stripeSubscriptionId) {\n        const { stripe } = await import('../../stripe');\n        await stripe.subscriptions.update(subscription.stripeSubscriptionId, {\n          cancel_at_period_end: !args.cancelImmediately,\n        });\n\n        if (args.cancelImmediately) {\n          await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);\n        }\n      }\n\n      // Update local record\n      const updated = await prisma.subscription.update({\n        where: { id: args.subscriptionId },\n        data: {\n          status: args.cancelImmediately ? 'CANCELLED' : 'ACTIVE',\n          cancelledAt: args.cancelImmediately ? new Date() : null,\n          cancelReason: args.reason,\n        },\n      });\n\n      return {\n        success: true,\n        subscription: updated,\n        cancelledImmediately: args.cancelImmediately,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // DIGITAL DOWNLOADS PRIMITIVES\n  // ============================================================================\n  {\n    name: 'customer.getDownloads',\n    description: 'Get all digital products/downloads available to the customer.',\n    category: 'customer',\n    tags: ['customer', 'downloads', 'digital'],\n    icon: 'Download',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      // Get all orders with digital products\n      const downloads = await prisma.digitalDownload.findMany({\n        where: { userId: args.userId },\n        include: {\n          asset: true,\n          order: {\n            select: { id: true, orderNumber: true, createdAt: true },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n      });\n\n      return {\n        downloads: downloads.map(d => ({\n          id: d.id,\n          fileName: d.asset.fileName,\n          fileSize: d.asset.fileSize,\n          downloadCount: d.downloadCount,\n          maxDownloads: d.maxDownloads,\n          expiresAt: d.expiresAt,\n          canDownload: d.downloadCount < (d.maxDownloads || Infinity) &&\n                       (!d.expiresAt || new Date(d.expiresAt) > new Date()),\n          order: d.order,\n          createdAt: d.createdAt,\n        })),\n      };\n    `,\n  },\n  {\n    name: 'customer.downloadAsset',\n    description: 'Generate a secure download link for a digital asset.',\n    category: 'customer',\n    tags: ['customer', 'download', 'asset'],\n    icon: 'FileDown',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'The customer user ID',\n        },\n        downloadId: {\n          type: 'string',\n          description: 'The digital download ID',\n        },\n      },\n      required: ['userId', 'downloadId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const download = await prisma.digitalDownload.findFirst({\n        where: {\n          id: args.downloadId,\n          userId: args.userId,\n        },\n        include: { asset: true },\n      });\n\n      if (!download) {\n        throw new Error('Download not found');\n      }\n\n      // Check limits\n      if (download.maxDownloads && download.downloadCount >= download.maxDownloads) {\n        throw new Error('Download limit reached');\n      }\n\n      if (download.expiresAt && new Date(download.expiresAt) < new Date()) {\n        throw new Error('Download has expired');\n      }\n\n      // Increment download count\n      await prisma.digitalDownload.update({\n        where: { id: args.downloadId },\n        data: { downloadCount: { increment: 1 } },\n      });\n\n      // Generate signed URL (implementation depends on storage provider)\n      // This is a placeholder - actual implementation would use S3/R2/etc.\n      const downloadUrl = download.asset.url;\n\n      return {\n        success: true,\n        downloadUrl,\n        fileName: download.asset.fileName,\n        remainingDownloads: download.maxDownloads\n          ? download.maxDownloads - download.downloadCount - 1\n          : null,\n      };\n    `,\n  },\n];\n","/**\n * Discount Primitives\n *\n * Primitives for discount and coupon management: validation, application, and tracking.\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const DISCOUNT_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // DISCOUNT PRIMITIVES\n  // ============================================================================\n  {\n    name: 'discount.validate',\n    description: 'Validate a discount code and check eligibility for an order.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'validate', 'e-commerce'],\n    icon: 'Percent',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Discount code to validate',\n        },\n        orderTotal: {\n          type: 'number',\n          description: 'Order subtotal in cents (for minimum order validation)',\n        },\n        productIds: {\n          type: 'array',\n          description: 'Product IDs in the order (for product-specific discounts)',\n          items: { type: 'string' },\n        },\n        categoryIds: {\n          type: 'array',\n          description: 'Category IDs of products (for category-specific discounts)',\n          items: { type: 'string' },\n        },\n        customerId: {\n          type: 'string',\n          description: 'Customer ID (for per-customer limits and first-order discounts)',\n        },\n        email: {\n          type: 'string',\n          description: 'Customer email (for tracking usage)',\n        },\n      },\n      required: ['code'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const discount = await prisma.discountCode.findUnique({\n        where: { code: args.code.toUpperCase() },\n        include: {\n          _count: {\n            select: { usages: true },\n          },\n        },\n      });\n\n      if (!discount) {\n        return { valid: false, error: 'Invalid discount code' };\n      }\n\n      // Check if enabled\n      if (!discount.enabled) {\n        return { valid: false, error: 'This discount code is no longer active' };\n      }\n\n      // Check date validity\n      const now = new Date();\n      if (discount.startsAt > now) {\n        return { valid: false, error: 'This discount code is not yet active' };\n      }\n      if (discount.expiresAt && discount.expiresAt < now) {\n        return { valid: false, error: 'This discount code has expired' };\n      }\n\n      // Check usage limits\n      if (discount.usageLimit && discount.usageCount >= discount.usageLimit) {\n        return { valid: false, error: 'This discount code has reached its usage limit' };\n      }\n\n      // Check per-customer limit\n      if (discount.perCustomer && (args.customerId || args.email)) {\n        const customerUsages = await prisma.discountUsage.count({\n          where: {\n            discountCodeId: discount.id,\n            OR: [\n              args.customerId ? { userId: args.customerId } : {},\n              args.email ? { email: args.email } : {},\n            ].filter(o => Object.keys(o).length > 0),\n          },\n        });\n\n        if (customerUsages >= discount.perCustomer) {\n          return { valid: false, error: 'You have already used this discount code the maximum number of times' };\n        }\n      }\n\n      // Check first order only\n      if (discount.firstOrderOnly && (args.customerId || args.email)) {\n        const previousOrders = await prisma.order.count({\n          where: {\n            OR: [\n              args.customerId ? { customerId: args.customerId } : {},\n              args.email ? { email: args.email } : {},\n            ].filter(o => Object.keys(o).length > 0),\n            status: { notIn: ['CANCELLED'] },\n          },\n        });\n\n        if (previousOrders > 0) {\n          return { valid: false, error: 'This discount code is only valid for first orders' };\n        }\n      }\n\n      // Check minimum order value\n      if (discount.minOrderValue && args.orderTotal && args.orderTotal < discount.minOrderValue) {\n        return {\n          valid: false,\n          error: 'Minimum order of $' + (discount.minOrderValue / 100).toFixed(2) + ' required',\n        };\n      }\n\n      // Check product/category applicability\n      if (discount.applyTo === 'PRODUCT' && discount.productIds.length > 0) {\n        const hasApplicableProduct = args.productIds?.some(id => discount.productIds.includes(id));\n        if (!hasApplicableProduct) {\n          return { valid: false, error: 'This discount does not apply to items in your cart' };\n        }\n      }\n\n      if (discount.applyTo === 'CATEGORY' && discount.categoryIds.length > 0) {\n        const hasApplicableCategory = args.categoryIds?.some(id => discount.categoryIds.includes(id));\n        if (!hasApplicableCategory) {\n          return { valid: false, error: 'This discount does not apply to items in your cart' };\n        }\n      }\n\n      // Calculate discount amount if order total provided\n      let discountAmount = 0;\n      if (args.orderTotal) {\n        if (discount.type === 'PERCENTAGE') {\n          discountAmount = Math.floor(args.orderTotal * discount.value / 100);\n          if (discount.maxDiscount) {\n            discountAmount = Math.min(discountAmount, discount.maxDiscount);\n          }\n        } else {\n          discountAmount = Math.min(discount.value, args.orderTotal);\n        }\n      }\n\n      return {\n        valid: true,\n        discount: {\n          id: discount.id,\n          code: discount.code,\n          type: discount.type,\n          value: discount.value,\n          description: discount.description,\n          minOrderValue: discount.minOrderValue,\n          maxDiscount: discount.maxDiscount,\n          expiresAt: discount.expiresAt?.toISOString(),\n        },\n        discountAmount,\n        savings: discountAmount > 0 ? '$' + (discountAmount / 100).toFixed(2) : null,\n      };\n    `,\n  },\n  {\n    name: 'discount.apply',\n    description: 'Apply a validated discount code to an order or cart.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'apply', 'e-commerce'],\n    icon: 'Tag',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Discount code to apply',\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID to apply discount to',\n        },\n        cartId: {\n          type: 'string',\n          description: 'Cart ID to apply discount to (alternative to orderId)',\n        },\n      },\n      required: ['code'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.orderId && !args.cartId) {\n        throw new Error('Either orderId or cartId is required');\n      }\n\n      const discount = await prisma.discountCode.findUnique({\n        where: { code: args.code.toUpperCase(), enabled: true },\n      });\n\n      if (!discount) {\n        throw new Error('Invalid discount code');\n      }\n\n      if (args.orderId) {\n        const order = await prisma.order.findUnique({\n          where: { id: args.orderId },\n        });\n\n        if (!order) {\n          throw new Error('Order not found');\n        }\n\n        // Calculate discount\n        let discountAmount = 0;\n        if (discount.type === 'PERCENTAGE') {\n          discountAmount = Math.floor(order.subtotal * discount.value / 100);\n          if (discount.maxDiscount) {\n            discountAmount = Math.min(discountAmount, discount.maxDiscount);\n          }\n        } else {\n          discountAmount = Math.min(discount.value, order.subtotal);\n        }\n\n        // Update order\n        const updated = await prisma.order.update({\n          where: { id: args.orderId },\n          data: {\n            discountCodeId: discount.id,\n            discountTotal: discountAmount,\n            total: order.subtotal + order.shippingTotal + order.taxTotal - discountAmount,\n          },\n        });\n\n        return {\n          success: true,\n          applied: 'order',\n          orderId: updated.id,\n          discountAmount,\n          newTotal: updated.total,\n        };\n      }\n\n      if (args.cartId) {\n        const cart = await prisma.cart.findUnique({\n          where: { id: args.cartId },\n        });\n\n        if (!cart) {\n          throw new Error('Cart not found');\n        }\n\n        // Calculate discount\n        let discountAmount = 0;\n        if (discount.type === 'PERCENTAGE') {\n          discountAmount = Math.floor(cart.subtotal * discount.value / 100);\n          if (discount.maxDiscount) {\n            discountAmount = Math.min(discountAmount, discount.maxDiscount);\n          }\n        } else {\n          discountAmount = Math.min(discount.value, cart.subtotal);\n        }\n\n        // Update cart\n        const updated = await prisma.cart.update({\n          where: { id: args.cartId },\n          data: {\n            discountCodeId: discount.id,\n            discountTotal: discountAmount,\n            total: cart.subtotal + cart.shippingTotal + cart.taxTotal - discountAmount,\n          },\n        });\n\n        return {\n          success: true,\n          applied: 'cart',\n          cartId: updated.id,\n          discountAmount,\n          newTotal: updated.total,\n        };\n      }\n    `,\n  },\n  {\n    name: 'discount.remove',\n    description: 'Remove a discount code from an order or cart.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'remove', 'e-commerce'],\n    icon: 'X',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID to remove discount from',\n        },\n        cartId: {\n          type: 'string',\n          description: 'Cart ID to remove discount from',\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.orderId && !args.cartId) {\n        throw new Error('Either orderId or cartId is required');\n      }\n\n      if (args.orderId) {\n        const order = await prisma.order.findUnique({\n          where: { id: args.orderId },\n        });\n\n        if (!order) {\n          throw new Error('Order not found');\n        }\n\n        const updated = await prisma.order.update({\n          where: { id: args.orderId },\n          data: {\n            discountCodeId: null,\n            discountTotal: 0,\n            total: order.subtotal + order.shippingTotal + order.taxTotal,\n          },\n        });\n\n        return {\n          success: true,\n          removed: 'order',\n          orderId: updated.id,\n          newTotal: updated.total,\n        };\n      }\n\n      if (args.cartId) {\n        const cart = await prisma.cart.findUnique({\n          where: { id: args.cartId },\n        });\n\n        if (!cart) {\n          throw new Error('Cart not found');\n        }\n\n        const updated = await prisma.cart.update({\n          where: { id: args.cartId },\n          data: {\n            discountCodeId: null,\n            discountTotal: 0,\n            total: cart.subtotal + cart.shippingTotal + cart.taxTotal,\n          },\n        });\n\n        return {\n          success: true,\n          removed: 'cart',\n          cartId: updated.id,\n          newTotal: updated.total,\n        };\n      }\n    `,\n  },\n  {\n    name: 'discount.list',\n    description: 'List discount codes with filtering and pagination.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'list', 'e-commerce'],\n    icon: 'List',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Filter by enabled status',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by discount type',\n          enum: ['PERCENTAGE', 'FIXED'],\n        },\n        active: {\n          type: 'boolean',\n          description: 'Filter active discounts (enabled, within date range, not exhausted)',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number (default: 1)',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page (default: 20)',\n          default: 20,\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const page = Math.max(1, args.page || 1);\n      const limit = Math.min(100, Math.max(1, args.limit || 20));\n      const skip = (page - 1) * limit;\n\n      const where = {};\n      const now = new Date();\n\n      if (typeof args.enabled === 'boolean') {\n        where.enabled = args.enabled;\n      }\n\n      if (args.type) {\n        where.type = args.type;\n      }\n\n      if (args.active) {\n        where.enabled = true;\n        where.startsAt = { lte: now };\n        where.OR = [\n          { expiresAt: null },\n          { expiresAt: { gt: now } },\n        ];\n      }\n\n      const [discounts, total] = await Promise.all([\n        prisma.discountCode.findMany({\n          where,\n          skip,\n          take: limit,\n          orderBy: { createdAt: 'desc' },\n          include: {\n            _count: { select: { usages: true } },\n          },\n        }),\n        prisma.discountCode.count({ where }),\n      ]);\n\n      return {\n        success: true,\n        discounts: discounts.map(d => ({\n          id: d.id,\n          code: d.code,\n          description: d.description,\n          type: d.type,\n          value: d.value,\n          minOrderValue: d.minOrderValue,\n          maxDiscount: d.maxDiscount,\n          enabled: d.enabled,\n          usageCount: d.usageCount,\n          usageLimit: d.usageLimit,\n          startsAt: d.startsAt.toISOString(),\n          expiresAt: d.expiresAt?.toISOString(),\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n  {\n    name: 'discount.get',\n    description: 'Get details of a specific discount code by ID or code.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'get', 'e-commerce'],\n    icon: 'Info',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        id: {\n          type: 'string',\n          description: 'Discount ID',\n        },\n        code: {\n          type: 'string',\n          description: 'Discount code (alternative to id)',\n        },\n        includeUsages: {\n          type: 'boolean',\n          description: 'Include usage history',\n          default: false,\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.id && !args.code) {\n        throw new Error('Either id or code is required');\n      }\n\n      const where = args.id\n        ? { id: args.id }\n        : { code: args.code.toUpperCase() };\n\n      const discount = await prisma.discountCode.findUnique({\n        where,\n        include: {\n          usages: args.includeUsages ? {\n            take: 50,\n            orderBy: { createdAt: 'desc' },\n          } : false,\n          _count: { select: { usages: true } },\n        },\n      });\n\n      if (!discount) {\n        return { success: false, error: 'Discount not found' };\n      }\n\n      const now = new Date();\n      const isActive = discount.enabled &&\n        discount.startsAt <= now &&\n        (!discount.expiresAt || discount.expiresAt > now) &&\n        (!discount.usageLimit || discount.usageCount < discount.usageLimit);\n\n      return {\n        success: true,\n        discount: {\n          id: discount.id,\n          code: discount.code,\n          description: discount.description,\n          type: discount.type,\n          value: discount.value,\n          applyTo: discount.applyTo,\n          productIds: discount.productIds,\n          categoryIds: discount.categoryIds,\n          excludeProductIds: discount.excludeProductIds,\n          excludeSaleItems: discount.excludeSaleItems,\n          minOrderValue: discount.minOrderValue,\n          maxDiscount: discount.maxDiscount,\n          usageLimit: discount.usageLimit,\n          usageCount: discount.usageCount,\n          perCustomer: discount.perCustomer,\n          firstOrderOnly: discount.firstOrderOnly,\n          enabled: discount.enabled,\n          startsAt: discount.startsAt.toISOString(),\n          expiresAt: discount.expiresAt?.toISOString(),\n          isActive,\n          usages: args.includeUsages ? discount.usages.map(u => ({\n            orderId: u.orderId,\n            email: u.email,\n            discountAmount: u.discountAmount,\n            createdAt: u.createdAt.toISOString(),\n          })) : undefined,\n        },\n      };\n    `,\n  },\n  {\n    name: 'discount.create',\n    description: 'Create a new discount code.',\n    category: 'discount',\n    tags: ['discount', 'coupon', 'create', 'e-commerce'],\n    icon: 'Plus',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Unique discount code',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the discount',\n        },\n        type: {\n          type: 'string',\n          description: 'Discount type',\n          enum: ['PERCENTAGE', 'FIXED'],\n        },\n        value: {\n          type: 'number',\n          description: 'Discount value (percentage or cents)',\n        },\n        minOrderValue: {\n          type: 'number',\n          description: 'Minimum order value in cents',\n        },\n        maxDiscount: {\n          type: 'number',\n          description: 'Maximum discount amount in cents (for percentage)',\n        },\n        usageLimit: {\n          type: 'number',\n          description: 'Total usage limit',\n        },\n        perCustomer: {\n          type: 'number',\n          description: 'Uses per customer',\n        },\n        firstOrderOnly: {\n          type: 'boolean',\n          description: 'Only valid for first orders',\n        },\n        startsAt: {\n          type: 'string',\n          description: 'Start date (ISO string)',\n        },\n        expiresAt: {\n          type: 'string',\n          description: 'Expiry date (ISO string)',\n        },\n        enabled: {\n          type: 'boolean',\n          description: 'Enable immediately',\n          default: true,\n        },\n      },\n      required: ['code', 'type', 'value'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      // Check for existing code\n      const existing = await prisma.discountCode.findUnique({\n        where: { code: args.code.toUpperCase() },\n      });\n\n      if (existing) {\n        throw new Error('Discount code already exists');\n      }\n\n      const discount = await prisma.discountCode.create({\n        data: {\n          code: args.code.toUpperCase(),\n          description: args.description,\n          type: args.type,\n          value: args.value,\n          minOrderValue: args.minOrderValue,\n          maxDiscount: args.maxDiscount,\n          usageLimit: args.usageLimit,\n          perCustomer: args.perCustomer,\n          firstOrderOnly: args.firstOrderOnly || false,\n          startsAt: args.startsAt ? new Date(args.startsAt) : new Date(),\n          expiresAt: args.expiresAt ? new Date(args.expiresAt) : null,\n          enabled: args.enabled !== false,\n        },\n      });\n\n      return {\n        success: true,\n        discount: {\n          id: discount.id,\n          code: discount.code,\n          type: discount.type,\n          value: discount.value,\n          enabled: discount.enabled,\n        },\n      };\n    `,\n  },\n];\n","/**\n * Email Primitives\n *\n * Primitives for email sending, subscriptions, and preference management.\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const EMAIL_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // EMAIL SENDING\n  // ============================================================================\n  {\n    name: 'email.send',\n    description: 'Send an email to one or more recipients.',\n    category: 'email',\n    tags: ['email', 'send', 'notification'],\n    icon: 'Mail',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        to: {\n          type: 'array',\n          description: 'Recipient email addresses',\n          items: {\n            type: 'object',\n            properties: {\n              email: { type: 'string' },\n              name: { type: 'string' },\n            },\n            required: ['email'],\n          },\n        },\n        subject: {\n          type: 'string',\n          description: 'Email subject line',\n        },\n        html: {\n          type: 'string',\n          description: 'HTML email body',\n        },\n        text: {\n          type: 'string',\n          description: 'Plain text email body',\n        },\n        from: {\n          type: 'object',\n          description: 'Sender (optional, uses default if not provided)',\n          properties: {\n            email: { type: 'string' },\n            name: { type: 'string' },\n          },\n        },\n        replyTo: {\n          type: 'object',\n          description: 'Reply-to address',\n          properties: {\n            email: { type: 'string' },\n            name: { type: 'string' },\n          },\n        },\n      },\n      required: ['to', 'subject'],\n    },\n    handler: `\n      const { sendEmail } = await import('../../email');\n\n      const toArray = Array.isArray(args.to) ? args.to : [args.to];\n\n      const results = [];\n      for (const recipient of toArray) {\n        const result = await sendEmail({\n          to: recipient,\n          subject: args.subject,\n          html: args.html,\n          text: args.text,\n          from: args.from,\n          replyTo: args.replyTo,\n        });\n        results.push({\n          email: recipient.email,\n          success: result.success,\n          messageId: result.messageId,\n          error: result.error,\n        });\n      }\n\n      return {\n        success: results.every(r => r.success),\n        results,\n      };\n    `,\n  },\n  {\n    name: 'email.sendTemplate',\n    description: 'Send an email using a saved template with merge tags.',\n    category: 'email',\n    tags: ['email', 'template', 'merge-tags'],\n    icon: 'FileText',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        templateId: {\n          type: 'string',\n          description: 'Email template ID',\n        },\n        to: {\n          type: 'object',\n          description: 'Recipient',\n          properties: {\n            email: { type: 'string' },\n            name: { type: 'string' },\n          },\n          required: ['email'],\n        },\n        data: {\n          type: 'object',\n          description: 'Merge tag data (e.g., { firstName: \"John\", orderNumber: \"12345\" })',\n        },\n        from: {\n          type: 'object',\n          description: 'Sender (optional)',\n          properties: {\n            email: { type: 'string' },\n            name: { type: 'string' },\n          },\n        },\n      },\n      required: ['templateId', 'to'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n      const { sendEmailWithMergeTags } = await import('../../email');\n\n      // Get template\n      const template = await prisma.emailTemplate.findUnique({\n        where: { id: args.templateId },\n      });\n\n      if (!template) {\n        throw new Error('Email template not found');\n      }\n\n      if (!template.isActive) {\n        throw new Error('Email template is not active');\n      }\n\n      const result = await sendEmailWithMergeTags(\n        {\n          to: args.to,\n          subjectTemplate: template.subject,\n          htmlTemplate: template.htmlContent || undefined,\n          textTemplate: template.textContent || undefined,\n          from: args.from,\n        },\n        args.data || {}\n      );\n\n      return {\n        success: result.success,\n        messageId: result.messageId,\n        template: template.name,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // SUBSCRIPTIONS\n  // ============================================================================\n  {\n    name: 'email.subscribe',\n    description: 'Subscribe an email address to the mailing list.',\n    category: 'email',\n    tags: ['email', 'subscribe', 'newsletter'],\n    icon: 'UserPlus',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        email: {\n          type: 'string',\n          description: 'Email address to subscribe',\n        },\n        firstName: {\n          type: 'string',\n          description: 'Subscriber first name',\n        },\n        lastName: {\n          type: 'string',\n          description: 'Subscriber last name',\n        },\n        lists: {\n          type: 'array',\n          description: 'List IDs to subscribe to (default: newsletter)',\n          items: { type: 'string' },\n        },\n        source: {\n          type: 'string',\n          description: 'Subscription source (e.g., \"checkout\", \"popup\", \"footer\")',\n        },\n        requireDoubleOptIn: {\n          type: 'boolean',\n          description: 'Require double opt-in confirmation (default: true)',\n          default: true,\n        },\n      },\n      required: ['email'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n      const { createSubscription, sendConfirmationEmail } = await import('../../email/subscriptions');\n\n      const lists = args.lists || ['newsletter'];\n      const requireDoubleOptIn = args.requireDoubleOptIn !== false;\n\n      // Check for existing subscriber\n      let subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: args.email.toLowerCase() },\n      });\n\n      if (subscriber) {\n        if (subscriber.status === 'UNSUBSCRIBED') {\n          // Resubscribe\n          subscriber = await prisma.emailSubscriber.update({\n            where: { id: subscriber.id },\n            data: {\n              status: requireDoubleOptIn ? 'PENDING' : 'SUBSCRIBED',\n              firstName: args.firstName || subscriber.firstName,\n              lastName: args.lastName || subscriber.lastName,\n              unsubscribedAt: null,\n            },\n          });\n        } else if (subscriber.status === 'SUBSCRIBED') {\n          return { success: true, message: 'Already subscribed', subscriber };\n        }\n      } else {\n        // Create new subscriber\n        subscriber = await prisma.emailSubscriber.create({\n          data: {\n            email: args.email.toLowerCase(),\n            firstName: args.firstName,\n            lastName: args.lastName,\n            status: requireDoubleOptIn ? 'PENDING' : 'SUBSCRIBED',\n            source: args.source || 'api',\n            lists,\n          },\n        });\n      }\n\n      // Send confirmation email if double opt-in\n      if (requireDoubleOptIn) {\n        await sendConfirmationEmail(subscriber.id);\n        return {\n          success: true,\n          message: 'Confirmation email sent',\n          requiresConfirmation: true,\n          subscriber\n        };\n      }\n\n      return { success: true, message: 'Subscribed successfully', subscriber };\n    `,\n  },\n  {\n    name: 'email.unsubscribe',\n    description: 'Unsubscribe an email address from the mailing list.',\n    category: 'email',\n    tags: ['email', 'unsubscribe'],\n    icon: 'UserMinus',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        email: {\n          type: 'string',\n          description: 'Email address to unsubscribe',\n        },\n        reason: {\n          type: 'string',\n          description: 'Unsubscribe reason',\n        },\n        lists: {\n          type: 'array',\n          description: 'Specific list IDs to unsubscribe from (empty = all)',\n          items: { type: 'string' },\n        },\n      },\n      required: ['email'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: args.email.toLowerCase() },\n      });\n\n      if (!subscriber) {\n        return { success: true, message: 'Email not found in list' };\n      }\n\n      if (args.lists && args.lists.length > 0) {\n        // Unsubscribe from specific lists\n        const remainingLists = (subscriber.lists || []).filter(\n          l => !args.lists.includes(l)\n        );\n\n        if (remainingLists.length === 0) {\n          // No lists left, fully unsubscribe\n          await prisma.emailSubscriber.update({\n            where: { id: subscriber.id },\n            data: {\n              status: 'UNSUBSCRIBED',\n              unsubscribedAt: new Date(),\n              unsubscribeReason: args.reason,\n              lists: [],\n            },\n          });\n        } else {\n          await prisma.emailSubscriber.update({\n            where: { id: subscriber.id },\n            data: { lists: remainingLists },\n          });\n        }\n      } else {\n        // Unsubscribe from all\n        await prisma.emailSubscriber.update({\n          where: { id: subscriber.id },\n          data: {\n            status: 'UNSUBSCRIBED',\n            unsubscribedAt: new Date(),\n            unsubscribeReason: args.reason,\n            lists: [],\n          },\n        });\n      }\n\n      return { success: true, message: 'Unsubscribed successfully' };\n    `,\n  },\n  {\n    name: 'email.updatePreferences',\n    description: 'Update email subscription preferences for a subscriber.',\n    category: 'email',\n    tags: ['email', 'preferences', 'settings'],\n    icon: 'Settings',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        email: {\n          type: 'string',\n          description: 'Subscriber email address',\n        },\n        lists: {\n          type: 'array',\n          description: 'List IDs to subscribe to',\n          items: { type: 'string' },\n        },\n        frequency: {\n          type: 'string',\n          description: 'Email frequency preference',\n          enum: ['instant', 'daily', 'weekly', 'monthly'],\n        },\n        firstName: {\n          type: 'string',\n          description: 'Update first name',\n        },\n        lastName: {\n          type: 'string',\n          description: 'Update last name',\n        },\n      },\n      required: ['email'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: args.email.toLowerCase() },\n      });\n\n      if (!subscriber) {\n        throw new Error('Subscriber not found');\n      }\n\n      const updateData = {};\n\n      if (args.lists !== undefined) {\n        updateData.lists = args.lists;\n      }\n      if (args.frequency !== undefined) {\n        updateData.preferences = {\n          ...(subscriber.preferences || {}),\n          frequency: args.frequency,\n        };\n      }\n      if (args.firstName !== undefined) {\n        updateData.firstName = args.firstName;\n      }\n      if (args.lastName !== undefined) {\n        updateData.lastName = args.lastName;\n      }\n\n      const updated = await prisma.emailSubscriber.update({\n        where: { id: subscriber.id },\n        data: updateData,\n      });\n\n      return { success: true, subscriber: updated };\n    `,\n  },\n  {\n    name: 'email.getSubscriptionStatus',\n    description: 'Get the subscription status for an email address.',\n    category: 'email',\n    tags: ['email', 'status', 'subscription'],\n    icon: 'Info',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        email: {\n          type: 'string',\n          description: 'Email address to check',\n        },\n      },\n      required: ['email'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: args.email.toLowerCase() },\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n          status: true,\n          lists: true,\n          preferences: true,\n          subscribedAt: true,\n          unsubscribedAt: true,\n          source: true,\n        },\n      });\n\n      if (!subscriber) {\n        return {\n          subscribed: false,\n          status: 'NOT_FOUND',\n        };\n      }\n\n      return {\n        subscribed: subscriber.status === 'SUBSCRIBED',\n        status: subscriber.status,\n        subscriber,\n      };\n    `,\n  },\n];\n","/**\n * Gift Card Primitives\n *\n * AI-callable primitives for gift card functionality.\n * Enables purchasing, sending, and redeeming gift cards.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const GIFTCARD_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // CHECK BALANCE\n  // ============================================================================\n  {\n    name: 'giftcard.check',\n    description: 'Check gift card balance and validity',\n    category: 'giftcard',\n    tags: ['giftcard', 'balance', 'check', 'storefront'],\n    icon: 'CreditCard',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Gift card code',\n        },\n      },\n      required: ['code'],\n    },\n    handler: `\n      const { code } = input;\n\n      const giftCard = await prisma.giftCard.findFirst({\n        where: { code: code.toUpperCase() },\n      });\n\n      if (!giftCard) {\n        return {\n          valid: false,\n          error: 'Gift card not found',\n        };\n      }\n\n      if (giftCard.status !== 'ACTIVE') {\n        return {\n          valid: false,\n          error: 'Gift card is ' + giftCard.status.toLowerCase(),\n          status: giftCard.status,\n        };\n      }\n\n      if (giftCard.expiresAt && giftCard.expiresAt < new Date()) {\n        return {\n          valid: false,\n          error: 'Gift card has expired',\n          expiresAt: giftCard.expiresAt,\n        };\n      }\n\n      if (giftCard.balance <= 0) {\n        return {\n          valid: false,\n          error: 'Gift card has no remaining balance',\n          balance: 0,\n        };\n      }\n\n      return {\n        valid: true,\n        balance: giftCard.balance,\n        originalAmount: giftCard.originalAmount,\n        currency: giftCard.currency,\n        expiresAt: giftCard.expiresAt,\n        status: giftCard.status,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // REDEEM GIFT CARD\n  // ============================================================================\n  {\n    name: 'giftcard.redeem',\n    description: 'Redeem gift card balance towards an order',\n    category: 'giftcard',\n    tags: ['giftcard', 'redeem', 'payment', 'checkout'],\n    icon: 'Gift',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Gift card code',\n        },\n        amount: {\n          type: 'number',\n          description: 'Amount to redeem',\n          minimum: 0.01,\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID to apply to',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID redeeming',\n        },\n      },\n      required: ['code', 'amount', 'orderId'],\n    },\n    handler: `\n      const { code, amount, orderId, userId } = input;\n\n      const giftCard = await prisma.giftCard.findFirst({\n        where: { code: code.toUpperCase() },\n      });\n\n      if (!giftCard) {\n        throw new Error('Gift card not found');\n      }\n\n      if (giftCard.status !== 'ACTIVE') {\n        throw new Error('Gift card is not active');\n      }\n\n      if (giftCard.expiresAt && giftCard.expiresAt < new Date()) {\n        throw new Error('Gift card has expired');\n      }\n\n      if (giftCard.balance < amount) {\n        throw new Error('Insufficient gift card balance. Available: ' + giftCard.balance);\n      }\n\n      // Create transaction and update balance\n      const [transaction, updatedCard] = await prisma.$transaction([\n        prisma.giftCardTransaction.create({\n          data: {\n            giftCardId: giftCard.id,\n            type: 'REDEMPTION',\n            amount: -amount,\n            balance: giftCard.balance - amount,\n            orderId,\n            userId: userId || null,\n            description: 'Redeemed for order ' + orderId,\n          },\n        }),\n        prisma.giftCard.update({\n          where: { id: giftCard.id },\n          data: {\n            balance: { decrement: amount },\n            usedAt: giftCard.usedAt || new Date(),\n            status: giftCard.balance - amount <= 0 ? 'REDEEMED' : 'ACTIVE',\n          },\n        }),\n      ]);\n\n      return {\n        redeemed: true,\n        amountRedeemed: amount,\n        remainingBalance: updatedCard.balance,\n        transactionId: transaction.id,\n        orderId,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET BALANCE\n  // ============================================================================\n  {\n    name: 'giftcard.getBalance',\n    description: 'Get detailed gift card information with transaction history',\n    category: 'giftcard',\n    tags: ['giftcard', 'balance', 'history'],\n    icon: 'Wallet',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Gift card code',\n        },\n        includeHistory: {\n          type: 'boolean',\n          description: 'Include transaction history',\n          default: false,\n        },\n      },\n      required: ['code'],\n    },\n    handler: `\n      const { code, includeHistory = false } = input;\n\n      const giftCard = await prisma.giftCard.findFirst({\n        where: { code: code.toUpperCase() },\n        include: {\n          transactions: includeHistory ? {\n            orderBy: { createdAt: 'desc' },\n            take: 20,\n          } : false,\n        },\n      });\n\n      if (!giftCard) {\n        throw new Error('Gift card not found');\n      }\n\n      return {\n        code: giftCard.code,\n        balance: giftCard.balance,\n        originalAmount: giftCard.originalAmount,\n        currency: giftCard.currency,\n        status: giftCard.status,\n        expiresAt: giftCard.expiresAt,\n        activatedAt: giftCard.activatedAt,\n        usedAt: giftCard.usedAt,\n        transactions: giftCard.transactions?.map(t => ({\n          id: t.id,\n          type: t.type,\n          amount: t.amount,\n          balance: t.balance,\n          description: t.description,\n          orderId: t.orderId,\n          createdAt: t.createdAt,\n        })) || [],\n      };\n    `,\n  },\n\n  // ============================================================================\n  // PURCHASE GIFT CARD\n  // ============================================================================\n  {\n    name: 'giftcard.purchase',\n    description: 'Purchase a new gift card',\n    category: 'giftcard',\n    tags: ['giftcard', 'purchase', 'buy'],\n    icon: 'ShoppingBag',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        amount: {\n          type: 'number',\n          description: 'Gift card amount',\n          minimum: 5,\n          maximum: 1000,\n        },\n        currency: {\n          type: 'string',\n          description: 'Currency code',\n          default: 'USD',\n        },\n        purchaserId: {\n          type: 'string',\n          description: 'Purchaser user ID',\n        },\n        delivery: {\n          type: 'string',\n          description: 'Delivery method',\n          enum: ['EMAIL', 'PRINT', 'PHYSICAL'],\n          default: 'EMAIL',\n        },\n        recipientEmail: {\n          type: 'string',\n          description: 'Recipient email (for EMAIL delivery)',\n        },\n        recipientName: {\n          type: 'string',\n          description: 'Recipient name',\n        },\n        senderName: {\n          type: 'string',\n          description: 'Sender name',\n        },\n        message: {\n          type: 'string',\n          description: 'Gift message',\n          maxLength: 500,\n        },\n        scheduledFor: {\n          type: 'string',\n          description: 'Schedule delivery date (ISO 8601)',\n        },\n      },\n      required: ['amount', 'purchaserId'],\n    },\n    handler: `\n      const { amount, currency = 'USD', purchaserId, delivery = 'EMAIL', recipientEmail, recipientName, senderName, message, scheduledFor } = input;\n\n      // Generate unique code\n      const generateCode = () => {\n        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n        let code = '';\n        for (let i = 0; i < 16; i++) {\n          if (i > 0 && i % 4 === 0) code += '-';\n          code += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return code;\n      };\n\n      let code;\n      let attempts = 0;\n      do {\n        code = generateCode();\n        const existing = await prisma.giftCard.findFirst({ where: { code } });\n        if (!existing) break;\n        attempts++;\n      } while (attempts < 10);\n\n      if (attempts >= 10) {\n        throw new Error('Failed to generate unique code');\n      }\n\n      // Set expiration (1 year from now by default)\n      const expiresAt = new Date();\n      expiresAt.setFullYear(expiresAt.getFullYear() + 1);\n\n      const giftCard = await prisma.giftCard.create({\n        data: {\n          code,\n          originalAmount: amount,\n          balance: amount,\n          currency,\n          status: 'ACTIVE',\n          purchaserId,\n          recipientEmail: recipientEmail || null,\n          recipientName: recipientName || null,\n          senderName: senderName || null,\n          message: message || null,\n          delivery,\n          scheduledFor: scheduledFor ? new Date(scheduledFor) : null,\n          expiresAt,\n          activatedAt: new Date(),\n        },\n      });\n\n      // Create initial transaction\n      await prisma.giftCardTransaction.create({\n        data: {\n          giftCardId: giftCard.id,\n          type: 'PURCHASE',\n          amount: amount,\n          balance: amount,\n          userId: purchaserId,\n          description: 'Gift card purchased',\n        },\n      });\n\n      return {\n        id: giftCard.id,\n        code: giftCard.code,\n        amount: giftCard.originalAmount,\n        currency: giftCard.currency,\n        delivery: giftCard.delivery,\n        recipientEmail: giftCard.recipientEmail,\n        expiresAt: giftCard.expiresAt,\n        message: 'Gift card created successfully',\n      };\n    `,\n  },\n\n  // ============================================================================\n  // SEND GIFT CARD\n  // ============================================================================\n  {\n    name: 'giftcard.send',\n    description: 'Send/resend gift card to recipient',\n    category: 'giftcard',\n    tags: ['giftcard', 'send', 'email'],\n    icon: 'Send',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        giftCardId: {\n          type: 'string',\n          description: 'Gift card ID',\n        },\n        code: {\n          type: 'string',\n          description: 'Gift card code (alternative to ID)',\n        },\n        recipientEmail: {\n          type: 'string',\n          description: 'Email to send to (override)',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { giftCardId, code, recipientEmail } = input;\n\n      if (!giftCardId && !code) {\n        throw new Error('Either giftCardId or code is required');\n      }\n\n      const giftCard = await prisma.giftCard.findFirst({\n        where: giftCardId ? { id: giftCardId } : { code: code.toUpperCase() },\n      });\n\n      if (!giftCard) {\n        throw new Error('Gift card not found');\n      }\n\n      const email = recipientEmail || giftCard.recipientEmail;\n      if (!email) {\n        throw new Error('No recipient email available');\n      }\n\n      // Note: Actual email sending would be done via email service\n      // This just records the send attempt\n      await prisma.giftCard.update({\n        where: { id: giftCard.id },\n        data: {\n          recipientEmail: email,\n          sentAt: new Date(),\n        },\n      });\n\n      return {\n        sent: true,\n        giftCardId: giftCard.id,\n        recipientEmail: email,\n        code: giftCard.code.substring(0, 4) + '-****-****-' + giftCard.code.slice(-4),\n        note: 'Email will be sent via configured email service',\n      };\n    `,\n  },\n\n  // ============================================================================\n  // REFUND TO GIFT CARD\n  // ============================================================================\n  {\n    name: 'giftcard.refund',\n    description: 'Add balance back to a gift card (for refunds)',\n    category: 'giftcard',\n    tags: ['giftcard', 'refund', 'balance'],\n    icon: 'RefreshCw',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        code: {\n          type: 'string',\n          description: 'Gift card code',\n        },\n        amount: {\n          type: 'number',\n          description: 'Amount to refund',\n          minimum: 0.01,\n        },\n        orderId: {\n          type: 'string',\n          description: 'Related order ID',\n        },\n        reason: {\n          type: 'string',\n          description: 'Refund reason',\n        },\n      },\n      required: ['code', 'amount'],\n    },\n    handler: `\n      const { code, amount, orderId, reason } = input;\n\n      const giftCard = await prisma.giftCard.findFirst({\n        where: { code: code.toUpperCase() },\n      });\n\n      if (!giftCard) {\n        throw new Error('Gift card not found');\n      }\n\n      const newBalance = giftCard.balance + amount;\n\n      // Cannot exceed original amount\n      if (newBalance > giftCard.originalAmount) {\n        throw new Error('Refund would exceed original gift card amount');\n      }\n\n      const [transaction, updatedCard] = await prisma.$transaction([\n        prisma.giftCardTransaction.create({\n          data: {\n            giftCardId: giftCard.id,\n            type: 'REFUND',\n            amount: amount,\n            balance: newBalance,\n            orderId: orderId || null,\n            description: reason || 'Refund to gift card',\n          },\n        }),\n        prisma.giftCard.update({\n          where: { id: giftCard.id },\n          data: {\n            balance: newBalance,\n            status: 'ACTIVE',\n          },\n        }),\n      ]);\n\n      return {\n        refunded: true,\n        amountRefunded: amount,\n        newBalance: updatedCard.balance,\n        transactionId: transaction.id,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET USER GIFT CARDS\n  // ============================================================================\n  {\n    name: 'giftcard.getUserCards',\n    description: 'Get gift cards purchased by or sent to a user',\n    category: 'giftcard',\n    tags: ['giftcard', 'user', 'list'],\n    icon: 'CreditCard',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter type',\n          enum: ['purchased', 'received', 'all'],\n          default: 'all',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by status',\n          enum: ['ACTIVE', 'REDEEMED', 'EXPIRED', 'DISABLED'],\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, type = 'all', status } = input;\n\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: { email: true },\n      });\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const where = {};\n\n      if (type === 'purchased') {\n        where.purchaserId = userId;\n      } else if (type === 'received') {\n        where.recipientEmail = user.email;\n      } else {\n        where.OR = [\n          { purchaserId: userId },\n          { recipientEmail: user.email },\n        ];\n      }\n\n      if (status) where.status = status;\n\n      const giftCards = await prisma.giftCard.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n      });\n\n      return {\n        giftCards: giftCards.map(gc => ({\n          id: gc.id,\n          code: gc.code.substring(0, 4) + '-****-****-' + gc.code.slice(-4),\n          fullCode: gc.purchaserId === userId ? gc.code : undefined,\n          balance: gc.balance,\n          originalAmount: gc.originalAmount,\n          currency: gc.currency,\n          status: gc.status,\n          isPurchased: gc.purchaserId === userId,\n          isReceived: gc.recipientEmail === user.email,\n          recipientName: gc.recipientName,\n          senderName: gc.senderName,\n          expiresAt: gc.expiresAt,\n          createdAt: gc.createdAt,\n        })),\n        total: giftCards.length,\n      };\n    `,\n  },\n];\n","/**\n * Media Primitives\n *\n * AI-callable primitives for media/file management.\n * Supports S3, Cloudflare R2, and local storage.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const MEDIA_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // LIST MEDIA\n  // ============================================================================\n  {\n    name: 'media.list',\n    description: 'List media files with filtering and pagination',\n    category: 'media',\n    tags: ['media', 'files', 'images', 'storage'],\n    icon: 'Image',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n          minimum: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n          minimum: 1,\n          maximum: 100,\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by file type',\n          enum: ['image', 'video', 'audio', 'document', 'other'],\n        },\n        folderId: {\n          type: 'string',\n          description: 'Filter by folder ID',\n        },\n        search: {\n          type: 'string',\n          description: 'Search by filename',\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['name', 'size', 'createdAt'],\n          default: 'createdAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { page = 1, limit = 20, type, folderId, search, sortBy = 'createdAt', sortOrder = 'desc' } = input;\n\n      const where = { deletedAt: null };\n\n      if (type) {\n        const mimePatterns = {\n          image: 'image/%',\n          video: 'video/%',\n          audio: 'audio/%',\n          document: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats%', 'text/%'],\n        };\n        if (type !== 'other') {\n          const pattern = mimePatterns[type];\n          if (Array.isArray(pattern)) {\n            where.OR = pattern.map(p => ({ mimeType: { contains: p.replace('%', '') } }));\n          } else {\n            where.mimeType = { startsWith: pattern.replace('%', '') };\n          }\n        }\n      }\n\n      if (folderId) where.folderId = folderId;\n      if (search) where.name = { contains: search, mode: 'insensitive' };\n\n      const [files, total] = await Promise.all([\n        prisma.media.findMany({\n          where,\n          include: {\n            folder: { select: { id: true, name: true } },\n          },\n          orderBy: { [sortBy]: sortOrder },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.media.count({ where }),\n      ]);\n\n      return {\n        files: files.map(f => ({\n          id: f.id,\n          name: f.name,\n          url: f.url,\n          thumbnailUrl: f.thumbnailUrl,\n          mimeType: f.mimeType,\n          size: f.size,\n          width: f.width,\n          height: f.height,\n          alt: f.alt,\n          folder: f.folder,\n          createdAt: f.createdAt,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n          hasNext: page * limit < total,\n          hasPrev: page > 1,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET MEDIA\n  // ============================================================================\n  {\n    name: 'media.get',\n    description: 'Get a single media file by ID',\n    category: 'media',\n    tags: ['media', 'files', 'storage'],\n    icon: 'File',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        mediaId: {\n          type: 'string',\n          description: 'Media ID',\n        },\n      },\n      required: ['mediaId'],\n    },\n    handler: `\n      const { mediaId } = input;\n\n      const media = await prisma.media.findFirst({\n        where: { id: mediaId, deletedAt: null },\n        include: {\n          folder: { select: { id: true, name: true, path: true } },\n        },\n      });\n\n      if (!media) {\n        throw new Error('Media not found');\n      }\n\n      return {\n        id: media.id,\n        name: media.name,\n        url: media.url,\n        thumbnailUrl: media.thumbnailUrl,\n        mimeType: media.mimeType,\n        size: media.size,\n        width: media.width,\n        height: media.height,\n        alt: media.alt,\n        caption: media.caption,\n        folder: media.folder,\n        metadata: media.metadata,\n        createdAt: media.createdAt,\n        updatedAt: media.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET FOLDERS\n  // ============================================================================\n  {\n    name: 'media.getFolders',\n    description: 'Get media folders for organization',\n    category: 'media',\n    tags: ['media', 'folders', 'storage'],\n    icon: 'Folder',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        parentId: {\n          type: 'string',\n          description: 'Parent folder ID (null for root)',\n        },\n        includeFileCount: {\n          type: 'boolean',\n          description: 'Include file count per folder',\n          default: true,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { parentId, includeFileCount = true } = input;\n\n      const where = {};\n      if (parentId === null || parentId === undefined) {\n        where.parentId = null;\n      } else if (parentId) {\n        where.parentId = parentId;\n      }\n\n      const folders = await prisma.mediaFolder.findMany({\n        where,\n        include: {\n          _count: includeFileCount ? {\n            select: { files: { where: { deletedAt: null } } },\n          } : false,\n          children: {\n            select: { id: true, name: true },\n          },\n        },\n        orderBy: { name: 'asc' },\n      });\n\n      return {\n        folders: folders.map(f => ({\n          id: f.id,\n          name: f.name,\n          path: f.path,\n          fileCount: f._count?.files || 0,\n          hasChildren: f.children.length > 0,\n          createdAt: f.createdAt,\n        })),\n        total: folders.length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // UPDATE MEDIA\n  // ============================================================================\n  {\n    name: 'media.update',\n    description: 'Update media file metadata (alt text, caption, folder)',\n    category: 'media',\n    tags: ['media', 'update', 'storage'],\n    icon: 'Edit',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        mediaId: {\n          type: 'string',\n          description: 'Media ID',\n        },\n        name: {\n          type: 'string',\n          description: 'New filename',\n        },\n        alt: {\n          type: 'string',\n          description: 'Alt text for accessibility',\n        },\n        caption: {\n          type: 'string',\n          description: 'Caption/description',\n        },\n        folderId: {\n          type: 'string',\n          description: 'Move to folder',\n        },\n      },\n      required: ['mediaId'],\n    },\n    handler: `\n      const { mediaId, name, alt, caption, folderId } = input;\n\n      const media = await prisma.media.findFirst({\n        where: { id: mediaId, deletedAt: null },\n      });\n\n      if (!media) {\n        throw new Error('Media not found');\n      }\n\n      const updateData = {};\n      if (name !== undefined) updateData.name = name;\n      if (alt !== undefined) updateData.alt = alt;\n      if (caption !== undefined) updateData.caption = caption;\n      if (folderId !== undefined) updateData.folderId = folderId || null;\n\n      const updated = await prisma.media.update({\n        where: { id: mediaId },\n        data: updateData,\n        include: {\n          folder: { select: { id: true, name: true } },\n        },\n      });\n\n      return {\n        id: updated.id,\n        name: updated.name,\n        url: updated.url,\n        alt: updated.alt,\n        caption: updated.caption,\n        folder: updated.folder,\n        updatedAt: updated.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // DELETE MEDIA\n  // ============================================================================\n  {\n    name: 'media.delete',\n    description: 'Soft delete a media file',\n    category: 'media',\n    tags: ['media', 'delete', 'storage'],\n    icon: 'Trash2',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        mediaId: {\n          type: 'string',\n          description: 'Media ID',\n        },\n        permanent: {\n          type: 'boolean',\n          description: 'Permanently delete (cannot be undone)',\n          default: false,\n        },\n      },\n      required: ['mediaId'],\n    },\n    handler: `\n      const { mediaId, permanent = false } = input;\n\n      const media = await prisma.media.findFirst({\n        where: { id: mediaId },\n      });\n\n      if (!media) {\n        throw new Error('Media not found');\n      }\n\n      if (permanent) {\n        // Delete from storage (would need to implement storage adapter)\n        await prisma.media.delete({ where: { id: mediaId } });\n        return { deleted: true, permanent: true, mediaId };\n      } else {\n        await prisma.media.update({\n          where: { id: mediaId },\n          data: { deletedAt: new Date() },\n        });\n        return { deleted: true, permanent: false, mediaId };\n      }\n    `,\n  },\n\n  // ============================================================================\n  // CREATE FOLDER\n  // ============================================================================\n  {\n    name: 'media.createFolder',\n    description: 'Create a new media folder',\n    category: 'media',\n    tags: ['media', 'folders', 'storage'],\n    icon: 'FolderPlus',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Folder name',\n          minLength: 1,\n          maxLength: 100,\n        },\n        parentId: {\n          type: 'string',\n          description: 'Parent folder ID (null for root)',\n        },\n      },\n      required: ['name'],\n    },\n    handler: `\n      const { name, parentId } = input;\n\n      // Build path\n      let path = '/' + name;\n      if (parentId) {\n        const parent = await prisma.mediaFolder.findUnique({ where: { id: parentId } });\n        if (!parent) {\n          throw new Error('Parent folder not found');\n        }\n        path = parent.path + '/' + name;\n      }\n\n      // Check for duplicate\n      const existing = await prisma.mediaFolder.findFirst({\n        where: { name, parentId: parentId || null },\n      });\n\n      if (existing) {\n        throw new Error('Folder with this name already exists');\n      }\n\n      const folder = await prisma.mediaFolder.create({\n        data: {\n          name,\n          path,\n          parentId: parentId || null,\n        },\n      });\n\n      return {\n        id: folder.id,\n        name: folder.name,\n        path: folder.path,\n        parentId: folder.parentId,\n        createdAt: folder.createdAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET UPLOAD URL\n  // ============================================================================\n  {\n    name: 'media.getUploadUrl',\n    description: 'Get a presigned URL for direct upload to storage',\n    category: 'media',\n    tags: ['media', 'upload', 'storage'],\n    icon: 'Upload',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filename: {\n          type: 'string',\n          description: 'Original filename',\n        },\n        mimeType: {\n          type: 'string',\n          description: 'File MIME type',\n        },\n        size: {\n          type: 'number',\n          description: 'File size in bytes',\n        },\n        folderId: {\n          type: 'string',\n          description: 'Target folder ID',\n        },\n      },\n      required: ['filename', 'mimeType'],\n    },\n    handler: `\n      const { filename, mimeType, size, folderId } = input;\n\n      // Validate file type\n      const allowedTypes = [\n        'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml',\n        'video/mp4', 'video/webm',\n        'audio/mpeg', 'audio/wav', 'audio/ogg',\n        'application/pdf',\n        'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      ];\n\n      if (!allowedTypes.some(t => mimeType.startsWith(t.split('/')[0]) || mimeType === t)) {\n        throw new Error('File type not allowed');\n      }\n\n      // Max size check (50MB default)\n      const maxSize = 50 * 1024 * 1024;\n      if (size && size > maxSize) {\n        throw new Error('File size exceeds maximum allowed (50MB)');\n      }\n\n      // Generate unique key\n      const ext = filename.split('.').pop() || '';\n      const key = 'uploads/' + Date.now() + '-' + Math.random().toString(36).substring(2) + '.' + ext;\n\n      // For now, return placeholder - actual implementation would use S3/R2/local storage\n      return {\n        uploadUrl: '/api/media/upload',\n        method: 'POST',\n        key,\n        fields: {\n          filename,\n          mimeType,\n          folderId: folderId || null,\n        },\n        expiresIn: 3600,\n        note: 'Use multipart/form-data with file field',\n      };\n    `,\n  },\n];\n","/**\n * Notification Primitives\n *\n * AI-callable primitives for user notifications.\n * Enables in-app notifications for orders, promotions, etc.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const NOTIFICATION_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // LIST NOTIFICATIONS\n  // ============================================================================\n  {\n    name: 'notification.list',\n    description: 'Get user notifications with filtering',\n    category: 'notification',\n    tags: ['notification', 'user', 'alerts'],\n    icon: 'Bell',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by notification type',\n          enum: ['ORDER', 'SHIPPING', 'PROMOTION', 'REVIEW', 'SYSTEM', 'PRICE_DROP', 'BACK_IN_STOCK'],\n        },\n        unreadOnly: {\n          type: 'boolean',\n          description: 'Only unread notifications',\n          default: false,\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, type, unreadOnly = false, page = 1, limit = 20 } = input;\n\n      const where = { userId };\n      if (type) where.type = type;\n      if (unreadOnly) where.readAt = null;\n\n      const [notifications, total, unreadCount] = await Promise.all([\n        prisma.notification.findMany({\n          where,\n          orderBy: { createdAt: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.notification.count({ where }),\n        prisma.notification.count({ where: { userId, readAt: null } }),\n      ]);\n\n      return {\n        notifications: notifications.map(n => ({\n          id: n.id,\n          type: n.type,\n          title: n.title,\n          message: n.message,\n          data: n.data,\n          actionUrl: n.actionUrl,\n          imageUrl: n.imageUrl,\n          read: !!n.readAt,\n          readAt: n.readAt,\n          createdAt: n.createdAt,\n        })),\n        unreadCount,\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // MARK AS READ\n  // ============================================================================\n  {\n    name: 'notification.markRead',\n    description: 'Mark a notification as read',\n    category: 'notification',\n    tags: ['notification', 'read', 'update'],\n    icon: 'CheckCircle',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        notificationId: {\n          type: 'string',\n          description: 'Notification ID',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (for authorization)',\n        },\n      },\n      required: ['notificationId', 'userId'],\n    },\n    handler: `\n      const { notificationId, userId } = input;\n\n      const notification = await prisma.notification.findFirst({\n        where: { id: notificationId, userId },\n      });\n\n      if (!notification) {\n        throw new Error('Notification not found');\n      }\n\n      if (notification.readAt) {\n        return { id: notificationId, alreadyRead: true };\n      }\n\n      await prisma.notification.update({\n        where: { id: notificationId },\n        data: { readAt: new Date() },\n      });\n\n      return { id: notificationId, markedAsRead: true };\n    `,\n  },\n\n  // ============================================================================\n  // MARK ALL AS READ\n  // ============================================================================\n  {\n    name: 'notification.markAllRead',\n    description: 'Mark all notifications as read for a user',\n    category: 'notification',\n    tags: ['notification', 'read', 'bulk'],\n    icon: 'CheckCheck',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Only mark specific type as read',\n          enum: ['ORDER', 'SHIPPING', 'PROMOTION', 'REVIEW', 'SYSTEM', 'PRICE_DROP', 'BACK_IN_STOCK'],\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, type } = input;\n\n      const where = { userId, readAt: null };\n      if (type) where.type = type;\n\n      const result = await prisma.notification.updateMany({\n        where,\n        data: { readAt: new Date() },\n      });\n\n      return {\n        markedAsRead: result.count,\n        userId,\n        type: type || 'all',\n      };\n    `,\n  },\n\n  // ============================================================================\n  // DELETE NOTIFICATION\n  // ============================================================================\n  {\n    name: 'notification.delete',\n    description: 'Delete a notification',\n    category: 'notification',\n    tags: ['notification', 'delete'],\n    icon: 'Trash2',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        notificationId: {\n          type: 'string',\n          description: 'Notification ID',\n        },\n        userId: {\n          type: 'string',\n          description: 'User ID (for authorization)',\n        },\n      },\n      required: ['notificationId', 'userId'],\n    },\n    handler: `\n      const { notificationId, userId } = input;\n\n      const notification = await prisma.notification.findFirst({\n        where: { id: notificationId, userId },\n      });\n\n      if (!notification) {\n        throw new Error('Notification not found');\n      }\n\n      await prisma.notification.delete({ where: { id: notificationId } });\n\n      return { deleted: true, notificationId };\n    `,\n  },\n\n  // ============================================================================\n  // GET UNREAD COUNT\n  // ============================================================================\n  {\n    name: 'notification.getUnreadCount',\n    description: 'Get count of unread notifications',\n    category: 'notification',\n    tags: ['notification', 'count', 'badge'],\n    icon: 'Hash',\n    timeout: 2000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId } = input;\n\n      const count = await prisma.notification.count({\n        where: { userId, readAt: null },\n      });\n\n      return { userId, unreadCount: count };\n    `,\n  },\n\n  // ============================================================================\n  // CREATE NOTIFICATION (Admin/System)\n  // ============================================================================\n  {\n    name: 'notification.create',\n    description: 'Create a new notification for a user',\n    category: 'notification',\n    tags: ['notification', 'create', 'admin'],\n    icon: 'BellPlus',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'Target user ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Notification type',\n          enum: ['ORDER', 'SHIPPING', 'PROMOTION', 'REVIEW', 'SYSTEM', 'PRICE_DROP', 'BACK_IN_STOCK'],\n        },\n        title: {\n          type: 'string',\n          description: 'Notification title',\n          maxLength: 200,\n        },\n        message: {\n          type: 'string',\n          description: 'Notification message',\n          maxLength: 1000,\n        },\n        actionUrl: {\n          type: 'string',\n          description: 'URL to navigate when clicked',\n        },\n        imageUrl: {\n          type: 'string',\n          description: 'Image URL to display',\n        },\n        data: {\n          type: 'object',\n          description: 'Additional data (orderId, productId, etc.)',\n        },\n      },\n      required: ['userId', 'type', 'title', 'message'],\n    },\n    handler: `\n      const { userId, type, title, message, actionUrl, imageUrl, data } = input;\n\n      // Verify user exists\n      const user = await prisma.user.findUnique({ where: { id: userId } });\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const notification = await prisma.notification.create({\n        data: {\n          userId,\n          type,\n          title,\n          message,\n          actionUrl: actionUrl || null,\n          imageUrl: imageUrl || null,\n          data: data || {},\n        },\n      });\n\n      return {\n        id: notification.id,\n        type: notification.type,\n        title: notification.title,\n        createdAt: notification.createdAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET NOTIFICATION PREFERENCES\n  // ============================================================================\n  {\n    name: 'notification.getPreferences',\n    description: 'Get user notification preferences',\n    category: 'notification',\n    tags: ['notification', 'preferences', 'settings'],\n    icon: 'Settings',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId } = input;\n\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: { notificationPreferences: true },\n      });\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      // Default preferences if not set\n      const defaults = {\n        orderUpdates: true,\n        shippingUpdates: true,\n        promotions: true,\n        priceDrops: true,\n        backInStock: true,\n        reviewReminders: true,\n        emailNotifications: true,\n        pushNotifications: false,\n      };\n\n      return {\n        userId,\n        preferences: { ...defaults, ...(user.notificationPreferences || {}) },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // UPDATE NOTIFICATION PREFERENCES\n  // ============================================================================\n  {\n    name: 'notification.updatePreferences',\n    description: 'Update user notification preferences',\n    category: 'notification',\n    tags: ['notification', 'preferences', 'settings'],\n    icon: 'Settings2',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        preferences: {\n          type: 'object',\n          description: 'Preference settings to update',\n          properties: {\n            orderUpdates: { type: 'boolean' },\n            shippingUpdates: { type: 'boolean' },\n            promotions: { type: 'boolean' },\n            priceDrops: { type: 'boolean' },\n            backInStock: { type: 'boolean' },\n            reviewReminders: { type: 'boolean' },\n            emailNotifications: { type: 'boolean' },\n            pushNotifications: { type: 'boolean' },\n          },\n        },\n      },\n      required: ['userId', 'preferences'],\n    },\n    handler: `\n      const { userId, preferences } = input;\n\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: { notificationPreferences: true },\n      });\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const updated = await prisma.user.update({\n        where: { id: userId },\n        data: {\n          notificationPreferences: {\n            ...(user.notificationPreferences || {}),\n            ...preferences,\n          },\n        },\n        select: { notificationPreferences: true },\n      });\n\n      return {\n        userId,\n        preferences: updated.notificationPreferences,\n        updated: true,\n      };\n    `,\n  },\n];\n","/**\n * Order Primitives\n *\n * Primitives for managing orders: creation, status updates, cancellation, refunds, and tracking.\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const ORDER_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // ORDER MANAGEMENT PRIMITIVES\n  // ============================================================================\n  {\n    name: 'order.create',\n    description: 'Create a new order from cart or direct product purchase. Calculates totals, applies discounts, and initializes order workflow.',\n    category: 'order',\n    tags: ['order', 'create', 'checkout', 'e-commerce'],\n    icon: 'ShoppingBag',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        customerId: {\n          type: 'string',\n          description: 'Optional customer ID for logged-in users',\n        },\n        email: {\n          type: 'string',\n          description: 'Customer email address (required)',\n        },\n        items: {\n          type: 'array',\n          description: 'Array of order items with productId, variantId, quantity',\n          items: {\n            type: 'object',\n            properties: {\n              productId: { type: 'string' },\n              variantId: { type: 'string' },\n              quantity: { type: 'number' },\n            },\n            required: ['productId', 'quantity'],\n          },\n        },\n        shippingAddressId: {\n          type: 'string',\n          description: 'ID of the shipping address',\n        },\n        billingAddressId: {\n          type: 'string',\n          description: 'ID of the billing address',\n        },\n        discountCode: {\n          type: 'string',\n          description: 'Optional discount code to apply',\n        },\n        customerNotes: {\n          type: 'string',\n          description: 'Optional notes from customer',\n        },\n      },\n      required: ['email', 'items'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n      const { generateOrderNumber } = await import('../../orders');\n\n      // Validate items and get product info\n      const orderItems = [];\n      let subtotal = 0;\n\n      for (const item of args.items) {\n        const product = await prisma.product.findUnique({\n          where: { id: item.productId },\n          include: { variants: true },\n        });\n\n        if (!product) {\n          throw new Error('Product not found: ' + item.productId);\n        }\n\n        const variant = item.variantId\n          ? product.variants.find(v => v.id === item.variantId)\n          : null;\n\n        const price = variant?.price ?? product.price;\n        const itemTotal = price * item.quantity;\n        subtotal += itemTotal;\n\n        orderItems.push({\n          productId: product.id,\n          variantId: variant?.id,\n          title: product.title,\n          variantTitle: variant?.title,\n          sku: variant?.sku || product.sku,\n          quantity: item.quantity,\n          price: price,\n          total: itemTotal,\n        });\n      }\n\n      // Apply discount if provided\n      let discountTotal = 0;\n      let discountCodeId = null;\n\n      if (args.discountCode) {\n        const discount = await prisma.discountCode.findUnique({\n          where: { code: args.discountCode, enabled: true },\n        });\n\n        if (discount) {\n          if (discount.type === 'PERCENTAGE') {\n            discountTotal = Math.floor(subtotal * discount.value / 100);\n            if (discount.maxDiscount) {\n              discountTotal = Math.min(discountTotal, discount.maxDiscount);\n            }\n          } else {\n            discountTotal = discount.value;\n          }\n          discountCodeId = discount.id;\n        }\n      }\n\n      const total = subtotal - discountTotal;\n\n      // Create order with items\n      const order = await prisma.order.create({\n        data: {\n          orderNumber: await generateOrderNumber(),\n          customerId: args.customerId,\n          email: args.email,\n          status: 'PENDING',\n          subtotal,\n          discountTotal,\n          total,\n          discountCodeId,\n          shippingAddressId: args.shippingAddressId,\n          billingAddressId: args.billingAddressId,\n          customerNotes: args.customerNotes,\n          items: {\n            create: orderItems,\n          },\n        },\n        include: {\n          items: true,\n        },\n      });\n\n      return {\n        success: true,\n        order: {\n          id: order.id,\n          orderNumber: order.orderNumber,\n          status: order.status,\n          total: order.total,\n          itemCount: order.items.length,\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.get',\n    description: 'Get order details by ID or order number. Includes items, shipments, and workflow progress.',\n    category: 'order',\n    tags: ['order', 'get', 'details', 'e-commerce'],\n    icon: 'FileText',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID',\n        },\n        orderNumber: {\n          type: 'string',\n          description: 'Order number (alternative to orderId)',\n        },\n        includeItems: {\n          type: 'boolean',\n          description: 'Include order items (default: true)',\n          default: true,\n        },\n        includeShipments: {\n          type: 'boolean',\n          description: 'Include shipment info (default: true)',\n          default: true,\n        },\n        includeProgress: {\n          type: 'boolean',\n          description: 'Include workflow progress (default: false)',\n          default: false,\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.orderId && !args.orderNumber) {\n        throw new Error('Either orderId or orderNumber is required');\n      }\n\n      const where = args.orderId\n        ? { id: args.orderId }\n        : { orderNumber: args.orderNumber };\n\n      const order = await prisma.order.findUnique({\n        where,\n        include: {\n          items: args.includeItems !== false ? {\n            include: {\n              product: { select: { id: true, title: true, slug: true } },\n              variant: { select: { id: true, title: true } },\n            },\n          } : false,\n          shipments: args.includeShipments !== false,\n          progress: args.includeProgress ? {\n            include: { stage: true },\n            orderBy: { enteredAt: 'desc' },\n          } : false,\n          customer: { select: { id: true, name: true, email: true } },\n          shippingAddress: true,\n          billingAddress: true,\n          workflow: args.includeProgress ? { include: { stages: true } } : false,\n        },\n      });\n\n      if (!order) {\n        return { success: false, error: 'Order not found' };\n      }\n\n      return { success: true, order };\n    `,\n  },\n  {\n    name: 'order.list',\n    description: 'List orders with filtering, pagination, and sorting options.',\n    category: 'order',\n    tags: ['order', 'list', 'search', 'e-commerce'],\n    icon: 'List',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        customerId: {\n          type: 'string',\n          description: 'Filter by customer ID',\n        },\n        email: {\n          type: 'string',\n          description: 'Filter by customer email',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by order status',\n          enum: ['PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'REFUNDED'],\n        },\n        paymentStatus: {\n          type: 'string',\n          description: 'Filter by payment status',\n          enum: ['UNPAID', 'PAID', 'PARTIALLY_REFUNDED', 'REFUNDED'],\n        },\n        dateFrom: {\n          type: 'string',\n          description: 'Filter orders from this date (ISO string)',\n        },\n        dateTo: {\n          type: 'string',\n          description: 'Filter orders up to this date (ISO string)',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number (default: 1)',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page (default: 20, max: 100)',\n          default: 20,\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['createdAt', 'updatedAt', 'total', 'orderNumber'],\n          default: 'createdAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const page = Math.max(1, args.page || 1);\n      const limit = Math.min(100, Math.max(1, args.limit || 20));\n      const skip = (page - 1) * limit;\n\n      const where = {};\n\n      if (args.customerId) where.customerId = args.customerId;\n      if (args.email) where.email = { contains: args.email, mode: 'insensitive' };\n      if (args.status) where.status = args.status;\n      if (args.paymentStatus) where.paymentStatus = args.paymentStatus;\n\n      if (args.dateFrom || args.dateTo) {\n        where.createdAt = {};\n        if (args.dateFrom) where.createdAt.gte = new Date(args.dateFrom);\n        if (args.dateTo) where.createdAt.lte = new Date(args.dateTo);\n      }\n\n      const [orders, total] = await Promise.all([\n        prisma.order.findMany({\n          where,\n          skip,\n          take: limit,\n          orderBy: { [args.sortBy || 'createdAt']: args.sortOrder || 'desc' },\n          include: {\n            items: { select: { id: true, title: true, quantity: true, total: true } },\n            customer: { select: { id: true, name: true, email: true } },\n          },\n        }),\n        prisma.order.count({ where }),\n      ]);\n\n      return {\n        success: true,\n        orders,\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.updateStatus',\n    description: 'Update order status with optional notes and notification trigger.',\n    category: 'order',\n    tags: ['order', 'status', 'update', 'e-commerce'],\n    icon: 'RefreshCw',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID to update',\n        },\n        status: {\n          type: 'string',\n          description: 'New order status',\n          enum: ['PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'REFUNDED'],\n        },\n        internalNotes: {\n          type: 'string',\n          description: 'Internal notes for this status change',\n        },\n        notifyCustomer: {\n          type: 'boolean',\n          description: 'Send notification to customer (default: true)',\n          default: true,\n        },\n        updatedById: {\n          type: 'string',\n          description: 'User ID who made the change',\n        },\n      },\n      required: ['orderId', 'status'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const order = await prisma.order.findUnique({\n        where: { id: args.orderId },\n      });\n\n      if (!order) {\n        throw new Error('Order not found');\n      }\n\n      const previousStatus = order.status;\n\n      const updated = await prisma.order.update({\n        where: { id: args.orderId },\n        data: {\n          status: args.status,\n          internalNotes: args.internalNotes\n            ? (order.internalNotes ? order.internalNotes + '\\\\n' : '') +\n              '[' + new Date().toISOString() + '] Status: ' + args.status + ' - ' + args.internalNotes\n            : order.internalNotes,\n        },\n      });\n\n      // TODO: Trigger notification if notifyCustomer is true\n\n      return {\n        success: true,\n        order: {\n          id: updated.id,\n          orderNumber: updated.orderNumber,\n          previousStatus,\n          newStatus: updated.status,\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.cancel',\n    description: 'Cancel an order. Restores inventory, voids payment if applicable, and updates status.',\n    category: 'order',\n    tags: ['order', 'cancel', 'void', 'e-commerce'],\n    icon: 'XCircle',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for cancellation',\n        },\n        restoreInventory: {\n          type: 'boolean',\n          description: 'Restore product inventory (default: true)',\n          default: true,\n        },\n        notifyCustomer: {\n          type: 'boolean',\n          description: 'Send cancellation notification (default: true)',\n          default: true,\n        },\n        cancelledById: {\n          type: 'string',\n          description: 'User ID who cancelled',\n        },\n      },\n      required: ['orderId', 'reason'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const order = await prisma.order.findUnique({\n        where: { id: args.orderId },\n        include: { items: true },\n      });\n\n      if (!order) {\n        throw new Error('Order not found');\n      }\n\n      if (order.status === 'CANCELLED') {\n        throw new Error('Order is already cancelled');\n      }\n\n      if (order.status === 'DELIVERED') {\n        throw new Error('Cannot cancel a delivered order. Use refund instead.');\n      }\n\n      // Restore inventory if requested\n      if (args.restoreInventory !== false) {\n        for (const item of order.items) {\n          if (item.variantId) {\n            await prisma.productVariant.update({\n              where: { id: item.variantId },\n              data: { inventory: { increment: item.quantity } },\n            });\n          } else {\n            await prisma.product.update({\n              where: { id: item.productId },\n              data: { inventory: { increment: item.quantity } },\n            });\n          }\n        }\n      }\n\n      const updated = await prisma.order.update({\n        where: { id: args.orderId },\n        data: {\n          status: 'CANCELLED',\n          internalNotes: (order.internalNotes ? order.internalNotes + '\\\\n' : '') +\n            '[' + new Date().toISOString() + '] CANCELLED: ' + args.reason,\n        },\n      });\n\n      return {\n        success: true,\n        order: {\n          id: updated.id,\n          orderNumber: updated.orderNumber,\n          status: updated.status,\n          reason: args.reason,\n          inventoryRestored: args.restoreInventory !== false,\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.refund',\n    description: 'Process a refund for an order. Supports full or partial refunds with optional inventory restoration.',\n    category: 'order',\n    tags: ['order', 'refund', 'payment', 'e-commerce'],\n    icon: 'RotateCcw',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID to refund',\n        },\n        amount: {\n          type: 'number',\n          description: 'Refund amount in cents. If not provided, full refund.',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for refund',\n        },\n        items: {\n          type: 'array',\n          description: 'Specific items to refund (for partial refunds)',\n          items: {\n            type: 'object',\n            properties: {\n              orderItemId: { type: 'string' },\n              quantity: { type: 'number' },\n            },\n            required: ['orderItemId', 'quantity'],\n          },\n        },\n        restoreInventory: {\n          type: 'boolean',\n          description: 'Restore inventory for refunded items',\n          default: true,\n        },\n        processStripeRefund: {\n          type: 'boolean',\n          description: 'Process refund through Stripe (default: true)',\n          default: true,\n        },\n        refundedById: {\n          type: 'string',\n          description: 'User ID who processed refund',\n        },\n      },\n      required: ['orderId', 'reason'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      const order = await prisma.order.findUnique({\n        where: { id: args.orderId },\n        include: { items: true },\n      });\n\n      if (!order) {\n        throw new Error('Order not found');\n      }\n\n      if (order.paymentStatus !== 'PAID' && order.paymentStatus !== 'PARTIALLY_REFUNDED') {\n        throw new Error('Order must be paid to process refund');\n      }\n\n      const refundAmount = args.amount || order.total;\n\n      // Process Stripe refund if applicable\n      let stripeRefundId = null;\n      if (args.processStripeRefund !== false && order.stripePaymentIntentId) {\n        try {\n          const stripe = (await import('../../stripe')).stripe;\n          const refund = await stripe.refunds.create({\n            payment_intent: order.stripePaymentIntentId,\n            amount: refundAmount,\n            reason: 'requested_by_customer',\n          });\n          stripeRefundId = refund.id;\n        } catch (err) {\n          throw new Error('Stripe refund failed: ' + err.message);\n        }\n      }\n\n      // Update order status\n      const isFullRefund = refundAmount >= order.total;\n      const updated = await prisma.order.update({\n        where: { id: args.orderId },\n        data: {\n          status: isFullRefund ? 'REFUNDED' : order.status,\n          paymentStatus: isFullRefund ? 'REFUNDED' : 'PARTIALLY_REFUNDED',\n          internalNotes: (order.internalNotes ? order.internalNotes + '\\\\n' : '') +\n            '[' + new Date().toISOString() + '] REFUND: $' + (refundAmount / 100).toFixed(2) +\n            ' - ' + args.reason + (stripeRefundId ? ' (Stripe: ' + stripeRefundId + ')' : ''),\n        },\n      });\n\n      return {\n        success: true,\n        refund: {\n          orderId: updated.id,\n          orderNumber: updated.orderNumber,\n          amount: refundAmount,\n          isFullRefund,\n          stripeRefundId,\n          newPaymentStatus: updated.paymentStatus,\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.getTracking',\n    description: 'Get tracking information for an order including shipment status and history.',\n    category: 'order',\n    tags: ['order', 'tracking', 'shipment', 'e-commerce'],\n    icon: 'Truck',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Order ID',\n        },\n        orderNumber: {\n          type: 'string',\n          description: 'Order number (alternative to orderId)',\n        },\n      },\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n\n      if (!args.orderId && !args.orderNumber) {\n        throw new Error('Either orderId or orderNumber is required');\n      }\n\n      const where = args.orderId\n        ? { id: args.orderId }\n        : { orderNumber: args.orderNumber };\n\n      const order = await prisma.order.findUnique({\n        where,\n        include: {\n          shipments: true,\n          progress: {\n            include: { stage: true },\n            orderBy: { enteredAt: 'desc' },\n          },\n          workflow: {\n            include: {\n              stages: { orderBy: { position: 'asc' } },\n            },\n          },\n        },\n      });\n\n      if (!order) {\n        return { success: false, error: 'Order not found' };\n      }\n\n      // Get current stage from workflow\n      const currentProgress = order.progress[0];\n      const stages = order.workflow?.stages || [];\n      const currentStageIndex = currentProgress\n        ? stages.findIndex(s => s.id === currentProgress.stageId)\n        : -1;\n\n      return {\n        success: true,\n        tracking: {\n          orderId: order.id,\n          orderNumber: order.orderNumber,\n          orderStatus: order.status,\n          shipments: order.shipments.map(s => ({\n            id: s.id,\n            carrier: s.carrier,\n            service: s.service,\n            trackingNumber: s.trackingNumber,\n            trackingUrl: s.trackingUrl,\n            status: s.status,\n            shippedAt: s.shippedAt,\n            deliveredAt: s.deliveredAt,\n          })),\n          workflow: order.workflow ? {\n            name: order.workflow.name,\n            currentStage: currentProgress?.stage ? {\n              name: currentProgress.stage.displayName,\n              message: currentProgress.stage.customerMessage,\n              icon: currentProgress.stage.icon,\n              color: currentProgress.stage.color,\n              enteredAt: currentProgress.enteredAt,\n            } : null,\n            stages: stages.map((s, i) => ({\n              name: s.displayName,\n              icon: s.icon,\n              color: s.color,\n              isComplete: i < currentStageIndex,\n              isCurrent: i === currentStageIndex,\n              isPending: i > currentStageIndex,\n            })),\n          } : null,\n          history: order.progress.map(p => ({\n            stage: p.stage.displayName,\n            enteredAt: p.enteredAt,\n            exitedAt: p.exitedAt,\n            source: p.source,\n          })),\n        },\n      };\n    `,\n  },\n  {\n    name: 'order.reorder',\n    description: 'Create a new order based on a previous order. Validates product availability and current prices.',\n    category: 'order',\n    tags: ['order', 'reorder', 'repeat', 'e-commerce'],\n    icon: 'Copy',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        orderId: {\n          type: 'string',\n          description: 'Original order ID to reorder from',\n        },\n        customerId: {\n          type: 'string',\n          description: 'Customer ID (uses original if not provided)',\n        },\n        email: {\n          type: 'string',\n          description: 'Email (uses original if not provided)',\n        },\n        shippingAddressId: {\n          type: 'string',\n          description: 'Shipping address (uses original if not provided)',\n        },\n        skipUnavailable: {\n          type: 'boolean',\n          description: 'Skip unavailable items instead of failing (default: false)',\n          default: false,\n        },\n      },\n      required: ['orderId'],\n    },\n    handler: `\n      const { prisma } = await import('../../db');\n      const { generateOrderNumber } = await import('../../orders');\n\n      const originalOrder = await prisma.order.findUnique({\n        where: { id: args.orderId },\n        include: { items: true },\n      });\n\n      if (!originalOrder) {\n        throw new Error('Original order not found');\n      }\n\n      // Validate items are still available\n      const validItems = [];\n      const unavailableItems = [];\n      let subtotal = 0;\n\n      for (const item of originalOrder.items) {\n        const product = await prisma.product.findUnique({\n          where: { id: item.productId },\n          include: { variants: true },\n        });\n\n        if (!product || product.status !== 'ACTIVE') {\n          unavailableItems.push({ title: item.title, reason: 'Product no longer available' });\n          continue;\n        }\n\n        const variant = item.variantId\n          ? product.variants.find(v => v.id === item.variantId)\n          : null;\n\n        if (item.variantId && !variant) {\n          unavailableItems.push({ title: item.title, reason: 'Variant no longer available' });\n          continue;\n        }\n\n        const currentPrice = variant?.price ?? product.price;\n        const itemTotal = currentPrice * item.quantity;\n        subtotal += itemTotal;\n\n        validItems.push({\n          productId: product.id,\n          variantId: variant?.id,\n          title: product.title,\n          variantTitle: variant?.title,\n          sku: variant?.sku || product.sku,\n          quantity: item.quantity,\n          price: currentPrice,\n          total: itemTotal,\n        });\n      }\n\n      if (validItems.length === 0) {\n        throw new Error('No items available for reorder');\n      }\n\n      if (unavailableItems.length > 0 && !args.skipUnavailable) {\n        return {\n          success: false,\n          error: 'Some items are unavailable',\n          unavailableItems,\n        };\n      }\n\n      // Create new order\n      const newOrder = await prisma.order.create({\n        data: {\n          orderNumber: await generateOrderNumber(),\n          customerId: args.customerId || originalOrder.customerId,\n          email: args.email || originalOrder.email,\n          status: 'PENDING',\n          subtotal,\n          total: subtotal,\n          shippingAddressId: args.shippingAddressId || originalOrder.shippingAddressId,\n          billingAddressId: originalOrder.billingAddressId,\n          items: {\n            create: validItems,\n          },\n        },\n        include: { items: true },\n      });\n\n      return {\n        success: true,\n        order: {\n          id: newOrder.id,\n          orderNumber: newOrder.orderNumber,\n          total: newOrder.total,\n          itemCount: newOrder.items.length,\n        },\n        originalOrderId: originalOrder.id,\n        unavailableItems: unavailableItems.length > 0 ? unavailableItems : undefined,\n      };\n    `,\n  },\n];\n","/**\n * Payment Primitives\n *\n * Primitives for payment processing: intents, checkout sessions, refunds, and customer management.\n * Uses Stripe integration from src/lib/stripe/\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const PAYMENT_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // PAYMENT PRIMITIVES\n  // ============================================================================\n  {\n    name: 'payment.createIntent',\n    description: 'Create a Stripe Payment Intent for custom payment flows. Returns client secret for frontend integration.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'intent', 'checkout'],\n    icon: 'CreditCard',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        amount: {\n          type: 'number',\n          description: 'Amount in cents (e.g., 1000 = $10.00)',\n        },\n        currency: {\n          type: 'string',\n          description: 'Currency code (default: USD)',\n          default: 'USD',\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID to associate with payment',\n        },\n        customerId: {\n          type: 'string',\n          description: 'Stripe customer ID (optional)',\n        },\n        captureMethod: {\n          type: 'string',\n          description: 'Capture method',\n          enum: ['automatic', 'manual'],\n          default: 'automatic',\n        },\n        metadata: {\n          type: 'object',\n          description: 'Additional metadata to store with payment',\n        },\n      },\n      required: ['amount'],\n    },\n    handler: `\n      const { createPaymentIntent } = await import('../../stripe');\n\n      const result = await createPaymentIntent({\n        amount: args.amount,\n        currency: args.currency || 'USD',\n        orderId: args.orderId,\n        customerId: args.customerId,\n        captureMethod: args.captureMethod,\n        metadata: args.metadata,\n      });\n\n      return {\n        success: true,\n        paymentIntentId: result.paymentIntentId,\n        clientSecret: result.clientSecret,\n        status: result.status,\n      };\n    `,\n  },\n  {\n    name: 'payment.createCheckout',\n    description: 'Create a Stripe Checkout Session for hosted payment page. Returns URL to redirect customer.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'checkout', 'session'],\n    icon: 'ShoppingCart',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        items: {\n          type: 'array',\n          description: 'Line items for checkout',\n          items: {\n            type: 'object',\n            properties: {\n              name: { type: 'string' },\n              description: { type: 'string' },\n              price: { type: 'number', description: 'Price in cents' },\n              quantity: { type: 'number' },\n              images: { type: 'array', items: { type: 'string' } },\n              productId: { type: 'string' },\n              stripePriceId: { type: 'string' },\n            },\n            required: ['name', 'price', 'quantity'],\n          },\n        },\n        successUrl: {\n          type: 'string',\n          description: 'URL to redirect on success',\n        },\n        cancelUrl: {\n          type: 'string',\n          description: 'URL to redirect on cancel',\n        },\n        customerEmail: {\n          type: 'string',\n          description: 'Pre-fill customer email',\n        },\n        customerId: {\n          type: 'string',\n          description: 'Existing Stripe customer ID',\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID to associate',\n        },\n        mode: {\n          type: 'string',\n          description: 'Checkout mode',\n          enum: ['payment', 'subscription', 'setup'],\n          default: 'payment',\n        },\n        allowPromotionCodes: {\n          type: 'boolean',\n          description: 'Allow promotion codes',\n          default: false,\n        },\n        shippingAddressCollection: {\n          type: 'boolean',\n          description: 'Collect shipping address',\n        },\n        shippingOptions: {\n          type: 'array',\n          description: 'Shipping rate options',\n          items: {\n            type: 'object',\n            properties: {\n              displayName: { type: 'string' },\n              amount: { type: 'number' },\n              deliveryEstimate: { type: 'object' },\n            },\n          },\n        },\n        metadata: {\n          type: 'object',\n          description: 'Additional metadata',\n        },\n      },\n      required: ['items', 'successUrl', 'cancelUrl'],\n    },\n    handler: `\n      const { createCheckoutSession } = await import('../../stripe');\n\n      const result = await createCheckoutSession({\n        items: args.items,\n        successUrl: args.successUrl,\n        cancelUrl: args.cancelUrl,\n        customerEmail: args.customerEmail,\n        customerId: args.customerId,\n        orderId: args.orderId,\n        mode: args.mode,\n        allowPromotionCodes: args.allowPromotionCodes,\n        shippingAddressCollection: args.shippingAddressCollection,\n        shippingOptions: args.shippingOptions,\n        metadata: args.metadata,\n      });\n\n      return {\n        success: true,\n        sessionId: result.sessionId,\n        url: result.url,\n      };\n    `,\n  },\n  {\n    name: 'payment.confirm',\n    description: 'Confirm and capture a payment intent (for manual capture mode).',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'capture', 'confirm'],\n    icon: 'CheckCircle',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        paymentIntentId: {\n          type: 'string',\n          description: 'Payment Intent ID to capture',\n        },\n        amount: {\n          type: 'number',\n          description: 'Amount to capture in cents (optional, captures full amount if not provided)',\n        },\n      },\n      required: ['paymentIntentId'],\n    },\n    handler: `\n      const { capturePaymentIntent } = await import('../../stripe');\n\n      const result = await capturePaymentIntent(args.paymentIntentId, args.amount);\n\n      return {\n        success: true,\n        paymentIntentId: result.paymentIntentId,\n        status: result.status,\n      };\n    `,\n  },\n  {\n    name: 'payment.refund',\n    description: 'Create a refund for a payment. Supports full or partial refunds.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'refund'],\n    icon: 'RotateCcw',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        paymentIntentId: {\n          type: 'string',\n          description: 'Payment Intent ID to refund',\n        },\n        amount: {\n          type: 'number',\n          description: 'Refund amount in cents (optional, full refund if not provided)',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for refund',\n          enum: ['duplicate', 'fraudulent', 'requested_by_customer'],\n        },\n        metadata: {\n          type: 'object',\n          description: 'Additional metadata',\n        },\n      },\n      required: ['paymentIntentId'],\n    },\n    handler: `\n      const { createRefund } = await import('../../stripe');\n\n      const result = await createRefund({\n        paymentIntentId: args.paymentIntentId,\n        amount: args.amount,\n        reason: args.reason,\n        metadata: args.metadata,\n      });\n\n      return {\n        success: true,\n        refundId: result.refundId,\n        status: result.status,\n        amount: result.amount,\n        isFullRefund: !args.amount,\n      };\n    `,\n  },\n  {\n    name: 'payment.getPaymentMethods',\n    description: 'List saved payment methods for a Stripe customer.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'methods', 'customer'],\n    icon: 'Wallet',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        customerId: {\n          type: 'string',\n          description: 'Stripe customer ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Payment method type',\n          enum: ['card', 'us_bank_account'],\n          default: 'card',\n        },\n      },\n      required: ['customerId'],\n    },\n    handler: `\n      const { listPaymentMethods } = await import('../../stripe');\n\n      const methods = await listPaymentMethods(args.customerId, args.type || 'card');\n\n      return {\n        success: true,\n        paymentMethods: methods.map(pm => ({\n          id: pm.id,\n          type: pm.type,\n          card: pm.card ? {\n            brand: pm.card.brand,\n            last4: pm.card.last4,\n            expMonth: pm.card.exp_month,\n            expYear: pm.card.exp_year,\n          } : null,\n          billingDetails: {\n            name: pm.billing_details?.name,\n            email: pm.billing_details?.email,\n          },\n        })),\n        count: methods.length,\n      };\n    `,\n  },\n  {\n    name: 'payment.createCustomer',\n    description: 'Create or get a Stripe customer. Returns customer ID for future payments.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'customer', 'create'],\n    icon: 'UserPlus',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        email: {\n          type: 'string',\n          description: 'Customer email address',\n        },\n        name: {\n          type: 'string',\n          description: 'Customer name',\n        },\n        phone: {\n          type: 'string',\n          description: 'Customer phone number',\n        },\n        address: {\n          type: 'object',\n          description: 'Customer address',\n          properties: {\n            line1: { type: 'string' },\n            line2: { type: 'string' },\n            city: { type: 'string' },\n            state: { type: 'string' },\n            postalCode: { type: 'string' },\n            country: { type: 'string' },\n          },\n        },\n        metadata: {\n          type: 'object',\n          description: 'Additional metadata',\n        },\n        getExisting: {\n          type: 'boolean',\n          description: 'Return existing customer if email matches (default: true)',\n          default: true,\n        },\n      },\n      required: ['email'],\n    },\n    handler: `\n      const { createCustomer, getOrCreateCustomer } = await import('../../stripe');\n\n      let customerId;\n\n      if (args.getExisting !== false) {\n        customerId = await getOrCreateCustomer(args.email, args.name);\n      } else {\n        customerId = await createCustomer({\n          email: args.email,\n          name: args.name,\n          phone: args.phone,\n          address: args.address,\n          metadata: args.metadata,\n        });\n      }\n\n      return {\n        success: true,\n        customerId,\n      };\n    `,\n  },\n  {\n    name: 'payment.getInvoices',\n    description: 'List invoices for a Stripe customer.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'invoices', 'billing'],\n    icon: 'FileText',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        customerId: {\n          type: 'string',\n          description: 'Stripe customer ID',\n        },\n        limit: {\n          type: 'number',\n          description: 'Max invoices to return (default: 10)',\n          default: 10,\n        },\n      },\n      required: ['customerId'],\n    },\n    handler: `\n      const { listInvoices } = await import('../../stripe');\n\n      const invoices = await listInvoices(args.customerId, args.limit || 10);\n\n      return {\n        success: true,\n        invoices: invoices.map(inv => ({\n          id: inv.id,\n          number: inv.number,\n          status: inv.status,\n          amountDue: inv.amount_due,\n          amountPaid: inv.amount_paid,\n          currency: inv.currency,\n          created: new Date(inv.created * 1000).toISOString(),\n          dueDate: inv.due_date ? new Date(inv.due_date * 1000).toISOString() : null,\n          pdfUrl: inv.invoice_pdf,\n          hostedUrl: inv.hosted_invoice_url,\n        })),\n        count: invoices.length,\n      };\n    `,\n  },\n  {\n    name: 'payment.createBillingPortal',\n    description: 'Create a Stripe Billing Portal session for customer self-service.',\n    category: 'payment',\n    tags: ['payment', 'stripe', 'portal', 'subscription'],\n    icon: 'Settings',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        customerId: {\n          type: 'string',\n          description: 'Stripe customer ID',\n        },\n        returnUrl: {\n          type: 'string',\n          description: 'URL to return to after portal session',\n        },\n      },\n      required: ['customerId', 'returnUrl'],\n    },\n    handler: `\n      const { createBillingPortalSession } = await import('../../stripe');\n\n      const url = await createBillingPortalSession(args.customerId, args.returnUrl);\n\n      return {\n        success: true,\n        url,\n      };\n    `,\n  },\n];\n","/**\n * Product Primitives\n *\n * AI-callable primitives for product catalog operations.\n * These enable store owners to build custom product displays via Puck.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const PRODUCT_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // PRODUCT LISTING\n  // ============================================================================\n  {\n    name: 'product.list',\n    description: 'List products with pagination, filtering, and sorting options',\n    category: 'product',\n    tags: ['product', 'catalog', 'list', 'storefront'],\n    icon: 'Package',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        page: {\n          type: 'number',\n          description: 'Page number (1-based)',\n          default: 1,\n          minimum: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n          minimum: 1,\n          maximum: 100,\n        },\n        categoryId: {\n          type: 'string',\n          description: 'Filter by category ID',\n        },\n        status: {\n          type: 'string',\n          description: 'Filter by status',\n          enum: ['ACTIVE', 'DRAFT', 'ARCHIVED'],\n        },\n        featured: {\n          type: 'boolean',\n          description: 'Filter to featured products only',\n        },\n        minPrice: {\n          type: 'number',\n          description: 'Minimum price filter',\n          minimum: 0,\n        },\n        maxPrice: {\n          type: 'number',\n          description: 'Maximum price filter',\n          minimum: 0,\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['name', 'price', 'createdAt', 'updatedAt'],\n          default: 'createdAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n        includeVariants: {\n          type: 'boolean',\n          description: 'Include product variants in response',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { page = 1, limit = 20, categoryId, status, featured, minPrice, maxPrice, sortBy = 'createdAt', sortOrder = 'desc', includeVariants = false } = input;\n\n      const where = { deletedAt: null };\n      if (categoryId) where.categoryId = categoryId;\n      if (status) where.status = status;\n      if (featured !== undefined) where.featured = featured;\n      if (minPrice !== undefined || maxPrice !== undefined) {\n        where.basePrice = {};\n        if (minPrice !== undefined) where.basePrice.gte = minPrice;\n        if (maxPrice !== undefined) where.basePrice.lte = maxPrice;\n      }\n\n      const [products, total] = await Promise.all([\n        prisma.product.findMany({\n          where,\n          include: {\n            category: { select: { id: true, name: true, slug: true } },\n            variants: includeVariants ? {\n              where: { deletedAt: null },\n              select: { id: true, name: true, sku: true, price: true, stock: true, options: true }\n            } : false,\n            images: { select: { id: true, url: true, alt: true }, orderBy: { order: 'asc' }, take: 1 },\n          },\n          orderBy: { [sortBy]: sortOrder },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.product.count({ where }),\n      ]);\n\n      return {\n        products: products.map(p => ({\n          id: p.id,\n          name: p.name,\n          slug: p.slug,\n          description: p.shortDescription || p.description?.substring(0, 200),\n          price: p.basePrice,\n          compareAtPrice: p.compareAtPrice,\n          featured: p.featured,\n          status: p.status,\n          category: p.category,\n          image: p.images[0] || null,\n          variants: p.variants || [],\n          variantCount: includeVariants ? p.variants?.length : undefined,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n          hasNext: page * limit < total,\n          hasPrev: page > 1,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET SINGLE PRODUCT\n  // ============================================================================\n  {\n    name: 'product.get',\n    description: 'Get detailed product information by ID or slug',\n    category: 'product',\n    tags: ['product', 'catalog', 'detail', 'storefront'],\n    icon: 'PackageSearch',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        slug: {\n          type: 'string',\n          description: 'Product slug (alternative to ID)',\n        },\n        includeRelated: {\n          type: 'boolean',\n          description: 'Include related products',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { productId, slug, includeRelated = false } = input;\n\n      if (!productId && !slug) {\n        throw new Error('Either productId or slug is required');\n      }\n\n      const where = productId ? { id: productId } : { slug };\n      where.deletedAt = null;\n\n      const product = await prisma.product.findFirst({\n        where,\n        include: {\n          category: true,\n          variants: {\n            where: { deletedAt: null },\n            include: {\n              images: { orderBy: { order: 'asc' } },\n            },\n            orderBy: { order: 'asc' },\n          },\n          images: { orderBy: { order: 'asc' } },\n          reviews: {\n            where: { status: 'APPROVED' },\n            take: 5,\n            orderBy: { createdAt: 'desc' },\n            include: { user: { select: { id: true, name: true } } },\n          },\n        },\n      });\n\n      if (!product) {\n        throw new Error('Product not found');\n      }\n\n      // Calculate average rating\n      const reviewStats = await prisma.productReview.aggregate({\n        where: { productId: product.id, status: 'APPROVED' },\n        _avg: { rating: true },\n        _count: { rating: true },\n      });\n\n      let related = [];\n      if (includeRelated && product.categoryId) {\n        related = await prisma.product.findMany({\n          where: {\n            categoryId: product.categoryId,\n            id: { not: product.id },\n            status: 'ACTIVE',\n            deletedAt: null,\n          },\n          select: {\n            id: true,\n            name: true,\n            slug: true,\n            basePrice: true,\n            images: { take: 1, orderBy: { order: 'asc' } },\n          },\n          take: 4,\n        });\n      }\n\n      return {\n        id: product.id,\n        name: product.name,\n        slug: product.slug,\n        description: product.description,\n        shortDescription: product.shortDescription,\n        price: product.basePrice,\n        compareAtPrice: product.compareAtPrice,\n        sku: product.sku,\n        featured: product.featured,\n        status: product.status,\n        category: product.category,\n        variants: product.variants.map(v => ({\n          id: v.id,\n          name: v.name,\n          sku: v.sku,\n          price: v.price,\n          compareAtPrice: v.compareAtPrice,\n          stock: v.stock,\n          options: v.options,\n          images: v.images,\n        })),\n        images: product.images,\n        reviews: product.reviews.map(r => ({\n          id: r.id,\n          rating: r.rating,\n          title: r.title,\n          content: r.content,\n          author: r.user?.name || 'Anonymous',\n          createdAt: r.createdAt,\n        })),\n        rating: {\n          average: reviewStats._avg.rating || 0,\n          count: reviewStats._count.rating || 0,\n        },\n        related,\n        metadata: product.metadata,\n        seo: {\n          title: product.seoTitle || product.name,\n          description: product.seoDescription || product.shortDescription,\n        },\n        createdAt: product.createdAt,\n        updatedAt: product.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // SEARCH PRODUCTS\n  // ============================================================================\n  {\n    name: 'product.search',\n    description: 'Full-text search across products',\n    category: 'product',\n    tags: ['product', 'search', 'catalog', 'storefront'],\n    icon: 'Search',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        query: {\n          type: 'string',\n          description: 'Search query',\n          minLength: 2,\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n          minimum: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n          minimum: 1,\n          maximum: 50,\n        },\n        categoryId: {\n          type: 'string',\n          description: 'Filter by category',\n        },\n        minPrice: {\n          type: 'number',\n          description: 'Minimum price',\n        },\n        maxPrice: {\n          type: 'number',\n          description: 'Maximum price',\n        },\n      },\n      required: ['query'],\n    },\n    handler: `\n      const { query, page = 1, limit = 20, categoryId, minPrice, maxPrice } = input;\n\n      const searchTerms = query.toLowerCase().split(/\\\\s+/).filter(t => t.length >= 2);\n\n      const where = {\n        status: 'ACTIVE',\n        deletedAt: null,\n        OR: [\n          { name: { contains: query, mode: 'insensitive' } },\n          { description: { contains: query, mode: 'insensitive' } },\n          { sku: { contains: query, mode: 'insensitive' } },\n          { tags: { hasSome: searchTerms } },\n        ],\n      };\n\n      if (categoryId) where.categoryId = categoryId;\n      if (minPrice !== undefined) where.basePrice = { ...where.basePrice, gte: minPrice };\n      if (maxPrice !== undefined) where.basePrice = { ...where.basePrice, lte: maxPrice };\n\n      const [products, total] = await Promise.all([\n        prisma.product.findMany({\n          where,\n          include: {\n            category: { select: { id: true, name: true, slug: true } },\n            images: { take: 1, orderBy: { order: 'asc' } },\n          },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.product.count({ where }),\n      ]);\n\n      return {\n        query,\n        results: products.map(p => ({\n          id: p.id,\n          name: p.name,\n          slug: p.slug,\n          description: p.shortDescription || p.description?.substring(0, 150),\n          price: p.basePrice,\n          compareAtPrice: p.compareAtPrice,\n          category: p.category,\n          image: p.images[0] || null,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n          hasNext: page * limit < total,\n          hasPrev: page > 1,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET BY CATEGORY\n  // ============================================================================\n  {\n    name: 'product.getByCategory',\n    description: 'Get products by category with optional subcategory traversal',\n    category: 'product',\n    tags: ['product', 'category', 'catalog', 'storefront'],\n    icon: 'FolderTree',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        categoryId: {\n          type: 'string',\n          description: 'Category ID',\n        },\n        categorySlug: {\n          type: 'string',\n          description: 'Category slug (alternative to ID)',\n        },\n        includeSubcategories: {\n          type: 'boolean',\n          description: 'Include products from subcategories',\n          default: true,\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['name', 'price', 'createdAt', 'featured'],\n          default: 'createdAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { categoryId, categorySlug, includeSubcategories = true, page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc' } = input;\n\n      if (!categoryId && !categorySlug) {\n        throw new Error('Either categoryId or categorySlug is required');\n      }\n\n      // Find category\n      const category = await prisma.productCategory.findFirst({\n        where: categoryId ? { id: categoryId } : { slug: categorySlug },\n        include: {\n          children: includeSubcategories ? { select: { id: true } } : false,\n        },\n      });\n\n      if (!category) {\n        throw new Error('Category not found');\n      }\n\n      // Build category IDs list\n      const categoryIds = [category.id];\n      if (includeSubcategories && category.children) {\n        categoryIds.push(...category.children.map(c => c.id));\n      }\n\n      const where = {\n        categoryId: { in: categoryIds },\n        status: 'ACTIVE',\n        deletedAt: null,\n      };\n\n      const [products, total] = await Promise.all([\n        prisma.product.findMany({\n          where,\n          include: {\n            category: { select: { id: true, name: true, slug: true } },\n            images: { take: 1, orderBy: { order: 'asc' } },\n          },\n          orderBy: sortBy === 'featured'\n            ? [{ featured: 'desc' }, { createdAt: 'desc' }]\n            : { [sortBy]: sortOrder },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.product.count({ where }),\n      ]);\n\n      return {\n        category: {\n          id: category.id,\n          name: category.name,\n          slug: category.slug,\n          description: category.description,\n        },\n        products: products.map(p => ({\n          id: p.id,\n          name: p.name,\n          slug: p.slug,\n          description: p.shortDescription,\n          price: p.basePrice,\n          compareAtPrice: p.compareAtPrice,\n          featured: p.featured,\n          category: p.category,\n          image: p.images[0] || null,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n          hasNext: page * limit < total,\n          hasPrev: page > 1,\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET VARIANTS\n  // ============================================================================\n  {\n    name: 'product.getVariants',\n    description: 'Get all variants for a product with pricing and stock info',\n    category: 'product',\n    tags: ['product', 'variants', 'catalog', 'storefront'],\n    icon: 'Layers',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        productSlug: {\n          type: 'string',\n          description: 'Product slug (alternative to ID)',\n        },\n        inStockOnly: {\n          type: 'boolean',\n          description: 'Only return variants in stock',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { productId, productSlug, inStockOnly = false } = input;\n\n      if (!productId && !productSlug) {\n        throw new Error('Either productId or productSlug is required');\n      }\n\n      // Find product\n      const product = await prisma.product.findFirst({\n        where: productId\n          ? { id: productId, deletedAt: null }\n          : { slug: productSlug, deletedAt: null },\n        select: { id: true, name: true, slug: true, basePrice: true },\n      });\n\n      if (!product) {\n        throw new Error('Product not found');\n      }\n\n      const where = {\n        productId: product.id,\n        deletedAt: null,\n      };\n\n      if (inStockOnly) {\n        where.stock = { gt: 0 };\n      }\n\n      const variants = await prisma.productVariant.findMany({\n        where,\n        include: {\n          images: { orderBy: { order: 'asc' } },\n        },\n        orderBy: { order: 'asc' },\n      });\n\n      // Extract unique option types\n      const optionTypes = new Set();\n      variants.forEach(v => {\n        if (v.options && typeof v.options === 'object') {\n          Object.keys(v.options).forEach(k => optionTypes.add(k));\n        }\n      });\n\n      return {\n        product: {\n          id: product.id,\n          name: product.name,\n          slug: product.slug,\n          basePrice: product.basePrice,\n        },\n        variants: variants.map(v => ({\n          id: v.id,\n          name: v.name,\n          sku: v.sku,\n          price: v.price,\n          compareAtPrice: v.compareAtPrice,\n          stock: v.stock,\n          lowStockThreshold: v.lowStockThreshold,\n          inStock: v.stock > 0,\n          lowStock: v.stock > 0 && v.stock <= (v.lowStockThreshold || 5),\n          options: v.options,\n          images: v.images,\n          weight: v.weight,\n          dimensions: v.dimensions,\n        })),\n        optionTypes: Array.from(optionTypes),\n        totalVariants: variants.length,\n        inStockCount: variants.filter(v => v.stock > 0).length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // CHECK STOCK\n  // ============================================================================\n  {\n    name: 'product.checkStock',\n    description: 'Check stock availability for a product or variant',\n    category: 'product',\n    tags: ['product', 'stock', 'inventory', 'storefront'],\n    icon: 'Package2',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Specific variant ID (optional)',\n        },\n        quantity: {\n          type: 'number',\n          description: 'Quantity to check availability for',\n          default: 1,\n          minimum: 1,\n        },\n      },\n      required: ['productId'],\n    },\n    handler: `\n      const { productId, variantId, quantity = 1 } = input;\n\n      if (variantId) {\n        // Check specific variant\n        const variant = await prisma.productVariant.findFirst({\n          where: { id: variantId, productId, deletedAt: null },\n          include: {\n            product: { select: { id: true, name: true, status: true } },\n          },\n        });\n\n        if (!variant) {\n          throw new Error('Variant not found');\n        }\n\n        if (variant.product.status !== 'ACTIVE') {\n          return {\n            available: false,\n            reason: 'Product is not available',\n            productId,\n            variantId,\n            requestedQuantity: quantity,\n          };\n        }\n\n        const available = variant.stock >= quantity;\n\n        return {\n          available,\n          reason: available ? null : 'Insufficient stock',\n          productId,\n          variantId,\n          variantName: variant.name,\n          sku: variant.sku,\n          requestedQuantity: quantity,\n          currentStock: variant.stock,\n          lowStock: variant.stock > 0 && variant.stock <= (variant.lowStockThreshold || 5),\n        };\n      } else {\n        // Check all variants for product\n        const product = await prisma.product.findFirst({\n          where: { id: productId, deletedAt: null },\n          include: {\n            variants: {\n              where: { deletedAt: null, stock: { gte: quantity } },\n              select: { id: true, name: true, sku: true, stock: true, price: true },\n            },\n          },\n        });\n\n        if (!product) {\n          throw new Error('Product not found');\n        }\n\n        if (product.status !== 'ACTIVE') {\n          return {\n            available: false,\n            reason: 'Product is not available',\n            productId,\n            requestedQuantity: quantity,\n            availableVariants: [],\n          };\n        }\n\n        return {\n          available: product.variants.length > 0,\n          reason: product.variants.length > 0 ? null : 'No variants with sufficient stock',\n          productId,\n          productName: product.name,\n          requestedQuantity: quantity,\n          availableVariants: product.variants.map(v => ({\n            id: v.id,\n            name: v.name,\n            sku: v.sku,\n            stock: v.stock,\n            price: v.price,\n          })),\n          totalAvailableVariants: product.variants.length,\n        };\n      }\n    `,\n  },\n\n  // ============================================================================\n  // GET CATEGORIES\n  // ============================================================================\n  {\n    name: 'product.getCategories',\n    description: 'Get product categories with optional hierarchy',\n    category: 'product',\n    tags: ['product', 'category', 'catalog', 'navigation'],\n    icon: 'FolderOpen',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        parentId: {\n          type: 'string',\n          description: 'Parent category ID (null for root categories)',\n        },\n        includeProductCount: {\n          type: 'boolean',\n          description: 'Include product count per category',\n          default: true,\n        },\n        includeChildren: {\n          type: 'boolean',\n          description: 'Include child categories',\n          default: true,\n        },\n        activeOnly: {\n          type: 'boolean',\n          description: 'Only return categories with active products',\n          default: false,\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { parentId, includeProductCount = true, includeChildren = true, activeOnly = false } = input;\n\n      const where = {};\n      if (parentId === null || parentId === undefined) {\n        where.parentId = null;\n      } else if (parentId) {\n        where.parentId = parentId;\n      }\n\n      const categories = await prisma.productCategory.findMany({\n        where,\n        include: {\n          children: includeChildren ? {\n            select: {\n              id: true,\n              name: true,\n              slug: true,\n              description: true,\n              image: true,\n              _count: includeProductCount ? {\n                select: { products: { where: { status: 'ACTIVE', deletedAt: null } } }\n              } : false,\n            },\n            orderBy: { order: 'asc' },\n          } : false,\n          _count: includeProductCount ? {\n            select: { products: { where: { status: 'ACTIVE', deletedAt: null } } }\n          } : false,\n        },\n        orderBy: { order: 'asc' },\n      });\n\n      let result = categories.map(c => ({\n        id: c.id,\n        name: c.name,\n        slug: c.slug,\n        description: c.description,\n        image: c.image,\n        productCount: c._count?.products || 0,\n        children: c.children?.map(child => ({\n          id: child.id,\n          name: child.name,\n          slug: child.slug,\n          description: child.description,\n          image: child.image,\n          productCount: child._count?.products || 0,\n        })) || [],\n      }));\n\n      if (activeOnly) {\n        result = result.filter(c => c.productCount > 0 || c.children.some(ch => ch.productCount > 0));\n      }\n\n      return {\n        categories: result,\n        total: result.length,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET FEATURED PRODUCTS\n  // ============================================================================\n  {\n    name: 'product.getFeatured',\n    description: 'Get featured products for homepage or promotional displays',\n    category: 'product',\n    tags: ['product', 'featured', 'homepage', 'storefront'],\n    icon: 'Star',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        limit: {\n          type: 'number',\n          description: 'Maximum number of products to return',\n          default: 8,\n          minimum: 1,\n          maximum: 24,\n        },\n        categoryId: {\n          type: 'string',\n          description: 'Filter by category',\n        },\n      },\n      required: [],\n    },\n    handler: `\n      const { limit = 8, categoryId } = input;\n\n      const where = {\n        featured: true,\n        status: 'ACTIVE',\n        deletedAt: null,\n      };\n\n      if (categoryId) {\n        where.categoryId = categoryId;\n      }\n\n      const products = await prisma.product.findMany({\n        where,\n        include: {\n          category: { select: { id: true, name: true, slug: true } },\n          images: { take: 1, orderBy: { order: 'asc' } },\n        },\n        orderBy: [{ updatedAt: 'desc' }],\n        take: limit,\n      });\n\n      return {\n        products: products.map(p => ({\n          id: p.id,\n          name: p.name,\n          slug: p.slug,\n          description: p.shortDescription,\n          price: p.basePrice,\n          compareAtPrice: p.compareAtPrice,\n          category: p.category,\n          image: p.images[0] || null,\n        })),\n        total: products.length,\n      };\n    `,\n  },\n];\n","/**\n * Review Primitives\n *\n * AI-callable primitives for product reviews and ratings.\n * Enables customers to leave reviews and store owners to manage them.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const REVIEW_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // CREATE REVIEW\n  // ============================================================================\n  {\n    name: 'review.create',\n    description: 'Create a new product review',\n    category: 'review',\n    tags: ['review', 'rating', 'feedback', 'storefront'],\n    icon: 'Star',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID (for verified purchases)',\n        },\n        rating: {\n          type: 'number',\n          description: 'Rating (1-5)',\n          minimum: 1,\n          maximum: 5,\n        },\n        title: {\n          type: 'string',\n          description: 'Review title',\n          maxLength: 200,\n        },\n        content: {\n          type: 'string',\n          description: 'Review content',\n          maxLength: 5000,\n        },\n        pros: {\n          type: 'array',\n          description: 'List of pros',\n          items: { type: 'string' },\n        },\n        cons: {\n          type: 'array',\n          description: 'List of cons',\n          items: { type: 'string' },\n        },\n        images: {\n          type: 'array',\n          description: 'Image URLs',\n          items: { type: 'string' },\n        },\n      },\n      required: ['userId', 'productId', 'rating'],\n    },\n    handler: `\n      const { userId, productId, orderId, rating, title, content, pros, cons, images } = input;\n\n      // Verify product exists\n      const product = await prisma.product.findFirst({\n        where: { id: productId, deletedAt: null },\n      });\n\n      if (!product) {\n        throw new Error('Product not found');\n      }\n\n      // Check if user already reviewed this product\n      const existing = await prisma.productReview.findFirst({\n        where: { userId, productId },\n      });\n\n      if (existing) {\n        throw new Error('You have already reviewed this product');\n      }\n\n      // Check if verified purchase\n      let verifiedPurchase = false;\n      if (orderId) {\n        const order = await prisma.order.findFirst({\n          where: {\n            id: orderId,\n            userId,\n            items: { some: { productId } },\n            status: { in: ['DELIVERED', 'COMPLETED'] },\n          },\n        });\n        verifiedPurchase = !!order;\n      }\n\n      const review = await prisma.productReview.create({\n        data: {\n          userId,\n          productId,\n          orderId: orderId || null,\n          rating,\n          title: title || null,\n          content: content || null,\n          pros: pros || [],\n          cons: cons || [],\n          images: images || [],\n          verifiedPurchase,\n          status: 'PENDING', // Requires moderation\n        },\n      });\n\n      return {\n        id: review.id,\n        rating: review.rating,\n        title: review.title,\n        verifiedPurchase: review.verifiedPurchase,\n        status: review.status,\n        message: 'Review submitted for moderation',\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET PRODUCT REVIEWS\n  // ============================================================================\n  {\n    name: 'review.list',\n    description: 'Get reviews for a product',\n    category: 'review',\n    tags: ['review', 'rating', 'list', 'storefront'],\n    icon: 'MessageSquare',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 10,\n        },\n        sortBy: {\n          type: 'string',\n          description: 'Sort field',\n          enum: ['createdAt', 'rating', 'helpful'],\n          default: 'createdAt',\n        },\n        sortOrder: {\n          type: 'string',\n          description: 'Sort direction',\n          enum: ['asc', 'desc'],\n          default: 'desc',\n        },\n        rating: {\n          type: 'number',\n          description: 'Filter by specific rating',\n        },\n        verifiedOnly: {\n          type: 'boolean',\n          description: 'Only verified purchases',\n          default: false,\n        },\n      },\n      required: ['productId'],\n    },\n    handler: `\n      const { productId, page = 1, limit = 10, sortBy = 'createdAt', sortOrder = 'desc', rating, verifiedOnly = false } = input;\n\n      const where = {\n        productId,\n        status: 'APPROVED',\n      };\n\n      if (rating) where.rating = rating;\n      if (verifiedOnly) where.verifiedPurchase = true;\n\n      const orderBy = sortBy === 'helpful'\n        ? { helpfulCount: sortOrder }\n        : { [sortBy]: sortOrder };\n\n      const [reviews, total, stats] = await Promise.all([\n        prisma.productReview.findMany({\n          where,\n          include: {\n            user: { select: { id: true, name: true } },\n            _count: { select: { votes: true } },\n          },\n          orderBy,\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.productReview.count({ where }),\n        prisma.productReview.aggregate({\n          where: { productId, status: 'APPROVED' },\n          _avg: { rating: true },\n          _count: { rating: true },\n        }),\n      ]);\n\n      // Get rating distribution\n      const distribution = await prisma.productReview.groupBy({\n        by: ['rating'],\n        where: { productId, status: 'APPROVED' },\n        _count: { rating: true },\n      });\n\n      const ratingDist = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n      distribution.forEach(d => { ratingDist[d.rating] = d._count.rating; });\n\n      return {\n        reviews: reviews.map(r => ({\n          id: r.id,\n          rating: r.rating,\n          title: r.title,\n          content: r.content,\n          pros: r.pros,\n          cons: r.cons,\n          images: r.images,\n          author: r.user?.name || 'Anonymous',\n          verifiedPurchase: r.verifiedPurchase,\n          helpfulCount: r.helpfulCount,\n          response: r.response,\n          createdAt: r.createdAt,\n        })),\n        summary: {\n          averageRating: stats._avg.rating || 0,\n          totalReviews: stats._count.rating || 0,\n          distribution: ratingDist,\n        },\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET SINGLE REVIEW\n  // ============================================================================\n  {\n    name: 'review.get',\n    description: 'Get a single review by ID',\n    category: 'review',\n    tags: ['review', 'rating', 'detail'],\n    icon: 'FileText',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        reviewId: {\n          type: 'string',\n          description: 'Review ID',\n        },\n      },\n      required: ['reviewId'],\n    },\n    handler: `\n      const { reviewId } = input;\n\n      const review = await prisma.productReview.findFirst({\n        where: { id: reviewId },\n        include: {\n          user: { select: { id: true, name: true } },\n          product: { select: { id: true, name: true, slug: true } },\n        },\n      });\n\n      if (!review) {\n        throw new Error('Review not found');\n      }\n\n      return {\n        id: review.id,\n        rating: review.rating,\n        title: review.title,\n        content: review.content,\n        pros: review.pros,\n        cons: review.cons,\n        images: review.images,\n        author: review.user?.name || 'Anonymous',\n        authorId: review.userId,\n        product: review.product,\n        verifiedPurchase: review.verifiedPurchase,\n        helpfulCount: review.helpfulCount,\n        response: review.response,\n        respondedAt: review.respondedAt,\n        status: review.status,\n        createdAt: review.createdAt,\n        updatedAt: review.updatedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // VOTE REVIEW\n  // ============================================================================\n  {\n    name: 'review.vote',\n    description: 'Mark a review as helpful or not helpful',\n    category: 'review',\n    tags: ['review', 'vote', 'helpful', 'feedback'],\n    icon: 'ThumbsUp',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        reviewId: {\n          type: 'string',\n          description: 'Review ID',\n        },\n        userId: {\n          type: 'string',\n          description: 'Voter user ID',\n        },\n        helpful: {\n          type: 'boolean',\n          description: 'Is this review helpful?',\n        },\n      },\n      required: ['reviewId', 'userId', 'helpful'],\n    },\n    handler: `\n      const { reviewId, userId, helpful } = input;\n\n      const review = await prisma.productReview.findFirst({\n        where: { id: reviewId, status: 'APPROVED' },\n      });\n\n      if (!review) {\n        throw new Error('Review not found');\n      }\n\n      // Upsert vote\n      const existingVote = await prisma.reviewVote.findUnique({\n        where: { reviewId_oderId: { reviewId, oderId: oderId } },\n      });\n\n      if (existingVote) {\n        if (existingVote.helpful === helpful) {\n          // Remove vote if same\n          await prisma.reviewVote.delete({\n            where: { id: existingVote.id },\n          });\n\n          // Update helpful count\n          await prisma.productReview.update({\n            where: { id: reviewId },\n            data: { helpfulCount: { decrement: helpful ? 1 : 0 } },\n          });\n\n          return { voted: false, removed: true, reviewId };\n        } else {\n          // Change vote\n          await prisma.reviewVote.update({\n            where: { id: existingVote.id },\n            data: { helpful },\n          });\n\n          await prisma.productReview.update({\n            where: { id: reviewId },\n            data: { helpfulCount: { increment: helpful ? 1 : -1 } },\n          });\n\n          return { voted: true, helpful, changed: true, reviewId };\n        }\n      } else {\n        await prisma.reviewVote.create({\n          data: { reviewId, oderId: oderId, helpful },\n        });\n\n        if (helpful) {\n          await prisma.productReview.update({\n            where: { id: reviewId },\n            data: { helpfulCount: { increment: 1 } },\n          });\n        }\n\n        return { voted: true, helpful, reviewId };\n      }\n    `,\n  },\n\n  // ============================================================================\n  // RESPOND TO REVIEW\n  // ============================================================================\n  {\n    name: 'review.respond',\n    description: 'Store owner response to a review',\n    category: 'review',\n    tags: ['review', 'response', 'admin'],\n    icon: 'Reply',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        reviewId: {\n          type: 'string',\n          description: 'Review ID',\n        },\n        response: {\n          type: 'string',\n          description: 'Response text',\n          maxLength: 2000,\n        },\n      },\n      required: ['reviewId', 'response'],\n    },\n    handler: `\n      const { reviewId, response } = input;\n\n      const review = await prisma.productReview.findFirst({\n        where: { id: reviewId },\n      });\n\n      if (!review) {\n        throw new Error('Review not found');\n      }\n\n      const updated = await prisma.productReview.update({\n        where: { id: reviewId },\n        data: {\n          response,\n          respondedAt: new Date(),\n        },\n      });\n\n      return {\n        id: updated.id,\n        response: updated.response,\n        respondedAt: updated.respondedAt,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET PRODUCT RATING\n  // ============================================================================\n  {\n    name: 'review.getProductRating',\n    description: 'Get aggregate rating for a product',\n    category: 'review',\n    tags: ['review', 'rating', 'aggregate', 'storefront'],\n    icon: 'BarChart',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n      },\n      required: ['productId'],\n    },\n    handler: `\n      const { productId } = input;\n\n      const stats = await prisma.productReview.aggregate({\n        where: { productId, status: 'APPROVED' },\n        _avg: { rating: true },\n        _count: { rating: true },\n      });\n\n      const distribution = await prisma.productReview.groupBy({\n        by: ['rating'],\n        where: { productId, status: 'APPROVED' },\n        _count: { rating: true },\n      });\n\n      const ratingDist = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n      distribution.forEach(d => { ratingDist[d.rating] = d._count.rating; });\n\n      return {\n        productId,\n        averageRating: Math.round((stats._avg.rating || 0) * 10) / 10,\n        totalReviews: stats._count.rating || 0,\n        distribution: ratingDist,\n        hasReviews: stats._count.rating > 0,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET USER REVIEWS\n  // ============================================================================\n  {\n    name: 'review.getUserReviews',\n    description: 'Get all reviews by a user',\n    category: 'review',\n    tags: ['review', 'user', 'history'],\n    icon: 'User',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 10,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, page = 1, limit = 10 } = input;\n\n      const [reviews, total] = await Promise.all([\n        prisma.productReview.findMany({\n          where: { userId },\n          include: {\n            product: {\n              select: {\n                id: true,\n                name: true,\n                slug: true,\n                images: { take: 1, orderBy: { order: 'asc' } },\n              },\n            },\n          },\n          orderBy: { createdAt: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.productReview.count({ where: { userId } }),\n      ]);\n\n      return {\n        reviews: reviews.map(r => ({\n          id: r.id,\n          rating: r.rating,\n          title: r.title,\n          content: r.content,\n          status: r.status,\n          helpfulCount: r.helpfulCount,\n          product: {\n            id: r.product.id,\n            name: r.product.name,\n            slug: r.product.slug,\n            image: r.product.images[0] || null,\n          },\n          createdAt: r.createdAt,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n];\n","/**\n * Shipping Primitives\n *\n * Primitives for shipping operations: rates, labels, tracking, and address validation.\n * Uses Shippo integration from src/lib/shippo/\n */\n\nimport type { CreatePrimitiveRequest } from '../types';\n\nexport const SHIPPING_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // SHIPPING PRIMITIVES\n  // ============================================================================\n  {\n    name: 'shipping.getRates',\n    description: 'Get shipping rates from multiple carriers (USPS, UPS, FedEx) for a shipment. Compares prices and delivery times.',\n    category: 'shipping',\n    tags: ['shipping', 'rates', 'carriers', 'shippo'],\n    icon: 'Truck',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        addressFrom: {\n          type: 'object',\n          description: 'Ship-from address (optional, uses default if not provided)',\n          properties: {\n            name: { type: 'string' },\n            company: { type: 'string' },\n            street1: { type: 'string' },\n            street2: { type: 'string' },\n            city: { type: 'string' },\n            state: { type: 'string' },\n            zip: { type: 'string' },\n            country: { type: 'string' },\n            phone: { type: 'string' },\n            email: { type: 'string' },\n          },\n        },\n        addressTo: {\n          type: 'object',\n          description: 'Ship-to address (required)',\n          properties: {\n            name: { type: 'string' },\n            company: { type: 'string' },\n            street1: { type: 'string' },\n            street2: { type: 'string' },\n            city: { type: 'string' },\n            state: { type: 'string' },\n            zip: { type: 'string' },\n            country: { type: 'string' },\n            phone: { type: 'string' },\n            email: { type: 'string' },\n          },\n          required: ['name', 'street1', 'city', 'state', 'zip', 'country'],\n        },\n        parcels: {\n          type: 'array',\n          description: 'Package dimensions and weight',\n          items: {\n            type: 'object',\n            properties: {\n              length: { type: 'number', description: 'Length in inches' },\n              width: { type: 'number', description: 'Width in inches' },\n              height: { type: 'number', description: 'Height in inches' },\n              weight: { type: 'number', description: 'Weight in ounces' },\n              massUnit: { type: 'string', default: 'oz' },\n              distanceUnit: { type: 'string', default: 'in' },\n            },\n            required: ['length', 'width', 'height', 'weight'],\n          },\n        },\n        signature: {\n          type: 'boolean',\n          description: 'Require signature confirmation',\n        },\n        insurance: {\n          type: 'object',\n          description: 'Insurance options',\n          properties: {\n            amount: { type: 'string' },\n            currency: { type: 'string', default: 'USD' },\n            content: { type: 'string' },\n          },\n        },\n      },\n      required: ['addressTo', 'parcels'],\n    },\n    handler: `\n      const { createShipment, getDefaultFromAddress } = await import('../../shippo');\n\n      // Use default from address if not provided\n      const addressFrom = args.addressFrom || await getDefaultFromAddress();\n\n      const shipment = await createShipment({\n        addressFrom,\n        addressTo: args.addressTo,\n        parcels: args.parcels,\n        extra: {\n          signature: args.signature,\n          insurance: args.insurance,\n        },\n      });\n\n      return {\n        success: true,\n        shipmentId: shipment.shipmentId,\n        rates: shipment.rates.map(rate => ({\n          rateId: rate.rateId,\n          carrier: rate.carrier,\n          service: rate.servicelevel.name,\n          price: parseFloat(rate.amount),\n          currency: rate.currency,\n          estimatedDays: rate.estimatedDays,\n          deliveryTerms: rate.durationTerms,\n        })),\n        cheapest: shipment.rates[0] ? {\n          carrier: shipment.rates[0].carrier,\n          service: shipment.rates[0].servicelevel.name,\n          price: parseFloat(shipment.rates[0].amount),\n        } : null,\n      };\n    `,\n  },\n  {\n    name: 'shipping.createLabel',\n    description: 'Purchase a shipping label for a selected rate. Returns label URL, tracking number, and tracking URL.',\n    category: 'shipping',\n    tags: ['shipping', 'label', 'purchase', 'shippo'],\n    icon: 'Tag',\n    timeout: 30000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        rateId: {\n          type: 'string',\n          description: 'Rate ID from shipping.getRates',\n        },\n        labelFormat: {\n          type: 'string',\n          description: 'Label format',\n          enum: ['PDF', 'PDF_4x6', 'PNG', 'ZPLII'],\n          default: 'PDF',\n        },\n        orderId: {\n          type: 'string',\n          description: 'Order ID to associate with this shipment',\n        },\n      },\n      required: ['rateId'],\n    },\n    handler: `\n      const { purchaseLabel } = await import('../../shippo');\n      const { prisma } = await import('../../db');\n\n      const label = await purchaseLabel({\n        rateId: args.rateId,\n        labelFormat: args.labelFormat || 'PDF',\n      });\n\n      // Create shipment record if order ID provided\n      if (args.orderId && label.status === 'SUCCESS') {\n        await prisma.shipment.create({\n          data: {\n            orderId: args.orderId,\n            carrier: label.rate.carrier,\n            service: label.rate.servicelevel.name,\n            trackingNumber: label.trackingNumber,\n            trackingUrl: label.trackingUrl,\n            labelUrl: label.labelUrl,\n            status: 'LABEL_CREATED',\n          },\n        });\n      }\n\n      return {\n        success: label.status === 'SUCCESS',\n        transactionId: label.transactionId,\n        trackingNumber: label.trackingNumber,\n        trackingUrl: label.trackingUrl,\n        labelUrl: label.labelUrl,\n        carrier: label.rate.carrier,\n        service: label.rate.servicelevel.name,\n        eta: label.eta,\n        messages: label.messages,\n      };\n    `,\n  },\n  {\n    name: 'shipping.getTracking',\n    description: 'Get tracking status and history for a shipment by tracking number.',\n    category: 'shipping',\n    tags: ['shipping', 'tracking', 'status', 'shippo'],\n    icon: 'MapPin',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        carrier: {\n          type: 'string',\n          description: 'Carrier name',\n          enum: ['usps', 'ups', 'fedex', 'dhl_express'],\n        },\n        trackingNumber: {\n          type: 'string',\n          description: 'Tracking number',\n        },\n      },\n      required: ['carrier', 'trackingNumber'],\n    },\n    handler: `\n      const { getTracking } = await import('../../shippo');\n\n      const tracking = await getTracking(args.carrier, args.trackingNumber);\n\n      return {\n        success: true,\n        carrier: tracking.carrier,\n        trackingNumber: tracking.trackingNumber,\n        eta: tracking.eta,\n        currentStatus: {\n          status: tracking.trackingStatus.status,\n          details: tracking.trackingStatus.statusDetails,\n          date: tracking.trackingStatus.statusDate,\n          location: tracking.trackingStatus.location,\n        },\n        isDelivered: tracking.trackingStatus.status === 'DELIVERED',\n        history: tracking.trackingHistory.map(event => ({\n          status: event.status,\n          details: event.statusDetails,\n          date: event.statusDate,\n          location: event.location,\n        })),\n      };\n    `,\n  },\n  {\n    name: 'shipping.validateAddress',\n    description: 'Validate and standardize a shipping address. Returns corrected address and validation messages.',\n    category: 'shipping',\n    tags: ['shipping', 'address', 'validation', 'shippo'],\n    icon: 'CheckCircle',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Recipient name',\n        },\n        company: {\n          type: 'string',\n          description: 'Company name (optional)',\n        },\n        street1: {\n          type: 'string',\n          description: 'Street address line 1',\n        },\n        street2: {\n          type: 'string',\n          description: 'Street address line 2 (optional)',\n        },\n        city: {\n          type: 'string',\n          description: 'City',\n        },\n        state: {\n          type: 'string',\n          description: 'State/Province code',\n        },\n        zip: {\n          type: 'string',\n          description: 'Postal/ZIP code',\n        },\n        country: {\n          type: 'string',\n          description: 'Country code (e.g., US, CA)',\n          default: 'US',\n        },\n        phone: {\n          type: 'string',\n          description: 'Phone number',\n        },\n        email: {\n          type: 'string',\n          description: 'Email address',\n        },\n      },\n      required: ['name', 'street1', 'city', 'state', 'zip'],\n    },\n    handler: `\n      const { validateAddress } = await import('../../shippo');\n\n      const result = await validateAddress({\n        name: args.name,\n        company: args.company,\n        street1: args.street1,\n        street2: args.street2,\n        city: args.city,\n        state: args.state,\n        zip: args.zip,\n        country: args.country || 'US',\n        phone: args.phone,\n        email: args.email,\n      });\n\n      return {\n        success: true,\n        isValid: result.isValid,\n        address: {\n          name: result.name,\n          company: result.company,\n          street1: result.street1,\n          street2: result.street2,\n          city: result.city,\n          state: result.state,\n          zip: result.zip,\n          country: result.country,\n        },\n        messages: result.messages,\n        hasWarnings: result.messages?.some(m => m.type === 'warning') || false,\n        hasErrors: result.messages?.some(m => m.type === 'error') || false,\n      };\n    `,\n  },\n  {\n    name: 'shipping.refundLabel',\n    description: 'Request a refund for a purchased shipping label.',\n    category: 'shipping',\n    tags: ['shipping', 'refund', 'label', 'shippo'],\n    icon: 'RotateCcw',\n    timeout: 15000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        transactionId: {\n          type: 'string',\n          description: 'Transaction ID from label purchase',\n        },\n        shipmentId: {\n          type: 'string',\n          description: 'Optional: Database shipment ID to update',\n        },\n      },\n      required: ['transactionId'],\n    },\n    handler: `\n      const { refundLabel } = await import('../../shippo');\n      const { prisma } = await import('../../db');\n\n      const refund = await refundLabel(args.transactionId);\n\n      // Update shipment record if ID provided\n      if (args.shipmentId && refund.status !== 'ERROR') {\n        await prisma.shipment.update({\n          where: { id: args.shipmentId },\n          data: { status: 'REFUND_PENDING' },\n        });\n      }\n\n      return {\n        success: refund.status !== 'ERROR',\n        transactionId: refund.transactionId,\n        status: refund.status,\n      };\n    `,\n  },\n];\n","/**\n * Wishlist Primitives\n *\n * AI-callable primitives for wishlist/favorites functionality.\n * Enables customers to save products for later.\n */\n\nimport { CreatePrimitiveRequest } from '../types';\n\nexport const WISHLIST_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // GET WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.get',\n    description: 'Get user wishlist with products',\n    category: 'wishlist',\n    tags: ['wishlist', 'favorites', 'customer', 'storefront'],\n    icon: 'Heart',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        wishlistId: {\n          type: 'string',\n          description: 'Specific wishlist ID (users can have multiple)',\n        },\n        page: {\n          type: 'number',\n          description: 'Page number',\n          default: 1,\n        },\n        limit: {\n          type: 'number',\n          description: 'Items per page',\n          default: 20,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, wishlistId, page = 1, limit = 20 } = input;\n\n      // Get or create default wishlist\n      let wishlist;\n      if (wishlistId) {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { id: wishlistId, userId },\n        });\n      } else {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { userId, isDefault: true },\n        });\n\n        if (!wishlist) {\n          wishlist = await prisma.wishlist.create({\n            data: {\n              userId,\n              name: 'My Wishlist',\n              isDefault: true,\n            },\n          });\n        }\n      }\n\n      if (!wishlist) {\n        throw new Error('Wishlist not found');\n      }\n\n      const [items, total] = await Promise.all([\n        prisma.wishlistItem.findMany({\n          where: { wishlistId: wishlist.id },\n          include: {\n            product: {\n              include: {\n                images: { take: 1, orderBy: { order: 'asc' } },\n                variants: {\n                  where: { deletedAt: null },\n                  select: { id: true, price: true, stock: true },\n                  take: 1,\n                },\n              },\n            },\n            variant: {\n              select: { id: true, name: true, price: true, stock: true, options: true },\n            },\n          },\n          orderBy: { createdAt: 'desc' },\n          skip: (page - 1) * limit,\n          take: limit,\n        }),\n        prisma.wishlistItem.count({ where: { wishlistId: wishlist.id } }),\n      ]);\n\n      return {\n        id: wishlist.id,\n        name: wishlist.name,\n        isDefault: wishlist.isDefault,\n        isPublic: wishlist.isPublic,\n        shareToken: wishlist.isPublic ? wishlist.shareToken : null,\n        items: items.map(i => ({\n          id: i.id,\n          addedAt: i.createdAt,\n          note: i.note,\n          product: {\n            id: i.product.id,\n            name: i.product.name,\n            slug: i.product.slug,\n            price: i.variant?.price || i.product.basePrice,\n            compareAtPrice: i.product.compareAtPrice,\n            image: i.product.images[0] || null,\n            inStock: i.variant ? i.variant.stock > 0 : i.product.variants[0]?.stock > 0,\n            status: i.product.status,\n          },\n          variant: i.variant,\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit),\n        },\n      };\n    `,\n  },\n\n  // ============================================================================\n  // ADD TO WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.add',\n    description: 'Add a product to wishlist',\n    category: 'wishlist',\n    tags: ['wishlist', 'favorites', 'add', 'storefront'],\n    icon: 'HeartPlus',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Specific variant ID (optional)',\n        },\n        wishlistId: {\n          type: 'string',\n          description: 'Target wishlist ID (uses default if not specified)',\n        },\n        note: {\n          type: 'string',\n          description: 'Optional note',\n        },\n      },\n      required: ['userId', 'productId'],\n    },\n    handler: `\n      const { userId, productId, variantId, wishlistId, note } = input;\n\n      // Verify product exists\n      const product = await prisma.product.findFirst({\n        where: { id: productId, deletedAt: null },\n      });\n\n      if (!product) {\n        throw new Error('Product not found');\n      }\n\n      // Get or create wishlist\n      let wishlist;\n      if (wishlistId) {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { id: wishlistId, userId },\n        });\n      } else {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { userId, isDefault: true },\n        });\n\n        if (!wishlist) {\n          wishlist = await prisma.wishlist.create({\n            data: { userId, name: 'My Wishlist', isDefault: true },\n          });\n        }\n      }\n\n      if (!wishlist) {\n        throw new Error('Wishlist not found');\n      }\n\n      // Check if already in wishlist\n      const existing = await prisma.wishlistItem.findFirst({\n        where: {\n          wishlistId: wishlist.id,\n          productId,\n          variantId: variantId || null,\n        },\n      });\n\n      if (existing) {\n        return {\n          added: false,\n          alreadyExists: true,\n          itemId: existing.id,\n          wishlistId: wishlist.id,\n        };\n      }\n\n      const item = await prisma.wishlistItem.create({\n        data: {\n          wishlistId: wishlist.id,\n          productId,\n          variantId: variantId || null,\n          note: note || null,\n        },\n      });\n\n      return {\n        added: true,\n        itemId: item.id,\n        wishlistId: wishlist.id,\n        productId,\n        variantId,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // REMOVE FROM WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.remove',\n    description: 'Remove a product from wishlist',\n    category: 'wishlist',\n    tags: ['wishlist', 'favorites', 'remove', 'storefront'],\n    icon: 'HeartOff',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        itemId: {\n          type: 'string',\n          description: 'Wishlist item ID',\n        },\n        productId: {\n          type: 'string',\n          description: 'Product ID (alternative to itemId)',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Variant ID (when using productId)',\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, itemId, productId, variantId } = input;\n\n      if (!itemId && !productId) {\n        throw new Error('Either itemId or productId is required');\n      }\n\n      let item;\n\n      if (itemId) {\n        item = await prisma.wishlistItem.findFirst({\n          where: { id: itemId },\n          include: { wishlist: true },\n        });\n\n        if (!item || item.wishlist.userId !== userId) {\n          throw new Error('Item not found');\n        }\n      } else {\n        // Find by product in user's default wishlist\n        const wishlist = await prisma.wishlist.findFirst({\n          where: { userId, isDefault: true },\n        });\n\n        if (wishlist) {\n          item = await prisma.wishlistItem.findFirst({\n            where: {\n              wishlistId: wishlist.id,\n              productId,\n              variantId: variantId || null,\n            },\n          });\n        }\n\n        if (!item) {\n          return { removed: false, notFound: true };\n        }\n      }\n\n      await prisma.wishlistItem.delete({ where: { id: item.id } });\n\n      return {\n        removed: true,\n        itemId: item.id,\n        productId: item.productId,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // TOGGLE WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.toggle',\n    description: 'Toggle product in wishlist (add if not present, remove if present)',\n    category: 'wishlist',\n    tags: ['wishlist', 'favorites', 'toggle', 'storefront'],\n    icon: 'Heart',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        productId: {\n          type: 'string',\n          description: 'Product ID',\n        },\n        variantId: {\n          type: 'string',\n          description: 'Variant ID (optional)',\n        },\n      },\n      required: ['userId', 'productId'],\n    },\n    handler: `\n      const { userId, productId, variantId } = input;\n\n      // Get or create default wishlist\n      let wishlist = await prisma.wishlist.findFirst({\n        where: { userId, isDefault: true },\n      });\n\n      if (!wishlist) {\n        wishlist = await prisma.wishlist.create({\n          data: { userId, name: 'My Wishlist', isDefault: true },\n        });\n      }\n\n      // Check if exists\n      const existing = await prisma.wishlistItem.findFirst({\n        where: {\n          wishlistId: wishlist.id,\n          productId,\n          variantId: variantId || null,\n        },\n      });\n\n      if (existing) {\n        await prisma.wishlistItem.delete({ where: { id: existing.id } });\n        return {\n          action: 'removed',\n          inWishlist: false,\n          productId,\n          variantId,\n        };\n      } else {\n        const item = await prisma.wishlistItem.create({\n          data: {\n            wishlistId: wishlist.id,\n            productId,\n            variantId: variantId || null,\n          },\n        });\n        return {\n          action: 'added',\n          inWishlist: true,\n          itemId: item.id,\n          productId,\n          variantId,\n        };\n      }\n    `,\n  },\n\n  // ============================================================================\n  // CHECK WISHLIST STATUS\n  // ============================================================================\n  {\n    name: 'wishlist.check',\n    description: 'Check if product(s) are in wishlist',\n    category: 'wishlist',\n    tags: ['wishlist', 'favorites', 'check', 'storefront'],\n    icon: 'HeartPulse',\n    timeout: 3000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        productIds: {\n          type: 'array',\n          description: 'Product IDs to check',\n          items: { type: 'string' },\n        },\n      },\n      required: ['userId', 'productIds'],\n    },\n    handler: `\n      const { userId, productIds } = input;\n\n      const wishlist = await prisma.wishlist.findFirst({\n        where: { userId, isDefault: true },\n      });\n\n      if (!wishlist) {\n        return {\n          items: productIds.map(id => ({ productId: id, inWishlist: false })),\n        };\n      }\n\n      const items = await prisma.wishlistItem.findMany({\n        where: {\n          wishlistId: wishlist.id,\n          productId: { in: productIds },\n        },\n        select: { productId: true, variantId: true, id: true },\n      });\n\n      const itemMap = new Map(items.map(i => [i.productId, i]));\n\n      return {\n        items: productIds.map(id => ({\n          productId: id,\n          inWishlist: itemMap.has(id),\n          itemId: itemMap.get(id)?.id,\n          variantId: itemMap.get(id)?.variantId,\n        })),\n      };\n    `,\n  },\n\n  // ============================================================================\n  // SHARE WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.share',\n    description: 'Generate a shareable link for wishlist',\n    category: 'wishlist',\n    tags: ['wishlist', 'share', 'social'],\n    icon: 'Share2',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        userId: {\n          type: 'string',\n          description: 'User ID',\n        },\n        wishlistId: {\n          type: 'string',\n          description: 'Wishlist ID',\n        },\n        makePublic: {\n          type: 'boolean',\n          description: 'Make wishlist public',\n          default: true,\n        },\n      },\n      required: ['userId'],\n    },\n    handler: `\n      const { userId, wishlistId, makePublic = true } = input;\n\n      let wishlist;\n      if (wishlistId) {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { id: wishlistId, userId },\n        });\n      } else {\n        wishlist = await prisma.wishlist.findFirst({\n          where: { userId, isDefault: true },\n        });\n      }\n\n      if (!wishlist) {\n        throw new Error('Wishlist not found');\n      }\n\n      // Generate share token if needed\n      let shareToken = wishlist.shareToken;\n      if (!shareToken && makePublic) {\n        shareToken = Math.random().toString(36).substring(2) + Date.now().toString(36);\n      }\n\n      const updated = await prisma.wishlist.update({\n        where: { id: wishlist.id },\n        data: {\n          isPublic: makePublic,\n          shareToken: makePublic ? shareToken : null,\n        },\n      });\n\n      return {\n        wishlistId: updated.id,\n        isPublic: updated.isPublic,\n        shareToken: updated.shareToken,\n        shareUrl: updated.isPublic ? '/wishlist/shared/' + updated.shareToken : null,\n      };\n    `,\n  },\n\n  // ============================================================================\n  // GET SHARED WISHLIST\n  // ============================================================================\n  {\n    name: 'wishlist.getShared',\n    description: 'Get a publicly shared wishlist',\n    category: 'wishlist',\n    tags: ['wishlist', 'share', 'public'],\n    icon: 'ExternalLink',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        shareToken: {\n          type: 'string',\n          description: 'Share token from URL',\n        },\n      },\n      required: ['shareToken'],\n    },\n    handler: `\n      const { shareToken } = input;\n\n      const wishlist = await prisma.wishlist.findFirst({\n        where: { shareToken, isPublic: true },\n        include: {\n          user: { select: { name: true } },\n          items: {\n            include: {\n              product: {\n                include: {\n                  images: { take: 1, orderBy: { order: 'asc' } },\n                },\n              },\n              variant: { select: { name: true, price: true } },\n            },\n            orderBy: { createdAt: 'desc' },\n          },\n        },\n      });\n\n      if (!wishlist) {\n        throw new Error('Wishlist not found or not public');\n      }\n\n      return {\n        id: wishlist.id,\n        name: wishlist.name,\n        ownerName: wishlist.user?.name || 'Anonymous',\n        items: wishlist.items.map(i => ({\n          product: {\n            id: i.product.id,\n            name: i.product.name,\n            slug: i.product.slug,\n            price: i.variant?.price || i.product.basePrice,\n            image: i.product.images[0] || null,\n          },\n          variant: i.variant,\n          note: i.note,\n        })),\n        itemCount: wishlist.items.length,\n      };\n    `,\n  },\n];\n","/**\n * Domain Primitives Index\n *\n * Aggregates all domain-specific primitive definitions.\n * Each domain file exports a *_PRIMITIVES array.\n */\n\n// Core e-commerce primitives\nexport { AI_PRIMITIVES } from './ai';\nexport { ANALYTICS_PRIMITIVES } from './analytics';\nexport { BLOG_PRIMITIVES } from './blog';\nexport { CART_PRIMITIVES } from './cart';\nexport { CUSTOMER_PRIMITIVES } from './customer';\nexport { DISCOUNT_PRIMITIVES } from './discount';\nexport { EMAIL_PRIMITIVES } from './email';\nexport { GIFTCARD_PRIMITIVES } from './giftcard';\nexport { MEDIA_PRIMITIVES } from './media';\nexport { NOTIFICATION_PRIMITIVES } from './notification';\nexport { ORDER_PRIMITIVES } from './order';\nexport { PAYMENT_PRIMITIVES } from './payment';\nexport { PRODUCT_PRIMITIVES } from './product';\nexport { REVIEW_PRIMITIVES } from './review';\nexport { SHIPPING_PRIMITIVES } from './shipping';\nexport { WISHLIST_PRIMITIVES } from './wishlist';\n\n// Import all for aggregation\nimport { AI_PRIMITIVES } from './ai';\nimport { ANALYTICS_PRIMITIVES } from './analytics';\nimport { BLOG_PRIMITIVES } from './blog';\nimport { CART_PRIMITIVES } from './cart';\nimport { CUSTOMER_PRIMITIVES } from './customer';\nimport { DISCOUNT_PRIMITIVES } from './discount';\nimport { EMAIL_PRIMITIVES } from './email';\nimport { GIFTCARD_PRIMITIVES } from './giftcard';\nimport { MEDIA_PRIMITIVES } from './media';\nimport { NOTIFICATION_PRIMITIVES } from './notification';\nimport { ORDER_PRIMITIVES } from './order';\nimport { PAYMENT_PRIMITIVES } from './payment';\nimport { PRODUCT_PRIMITIVES } from './product';\nimport { REVIEW_PRIMITIVES } from './review';\nimport { SHIPPING_PRIMITIVES } from './shipping';\nimport { WISHLIST_PRIMITIVES } from './wishlist';\n\nimport type { CreatePrimitiveRequest } from '../types';\n\n/**\n * All domain primitives combined\n */\nexport const DOMAIN_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  ...AI_PRIMITIVES,\n  ...ANALYTICS_PRIMITIVES,\n  ...BLOG_PRIMITIVES,\n  ...CART_PRIMITIVES,\n  ...CUSTOMER_PRIMITIVES,\n  ...DISCOUNT_PRIMITIVES,\n  ...EMAIL_PRIMITIVES,\n  ...GIFTCARD_PRIMITIVES,\n  ...MEDIA_PRIMITIVES,\n  ...NOTIFICATION_PRIMITIVES,\n  ...ORDER_PRIMITIVES,\n  ...PAYMENT_PRIMITIVES,\n  ...PRODUCT_PRIMITIVES,\n  ...REVIEW_PRIMITIVES,\n  ...SHIPPING_PRIMITIVES,\n  ...WISHLIST_PRIMITIVES,\n];\n\n/**\n * Get primitives by category/domain\n */\nexport function getPrimitivesByDomain(domain: string): Array<CreatePrimitiveRequest & { builtIn: true }> {\n  switch (domain) {\n    case 'ai':\n      return AI_PRIMITIVES;\n    case 'analytics':\n      return ANALYTICS_PRIMITIVES;\n    case 'blog':\n      return BLOG_PRIMITIVES;\n    case 'cart':\n      return CART_PRIMITIVES;\n    case 'customer':\n      return CUSTOMER_PRIMITIVES;\n    case 'discount':\n      return DISCOUNT_PRIMITIVES;\n    case 'email':\n      return EMAIL_PRIMITIVES;\n    case 'giftcard':\n      return GIFTCARD_PRIMITIVES;\n    case 'media':\n      return MEDIA_PRIMITIVES;\n    case 'notification':\n      return NOTIFICATION_PRIMITIVES;\n    case 'order':\n      return ORDER_PRIMITIVES;\n    case 'payment':\n      return PAYMENT_PRIMITIVES;\n    case 'product':\n      return PRODUCT_PRIMITIVES;\n    case 'review':\n      return REVIEW_PRIMITIVES;\n    case 'shipping':\n      return SHIPPING_PRIMITIVES;\n    case 'wishlist':\n      return WISHLIST_PRIMITIVES;\n    default:\n      return [];\n  }\n}\n\n/**\n * List available domains\n */\nexport const AVAILABLE_DOMAINS = [\n  'ai',\n  'analytics',\n  'blog',\n  'cart',\n  'customer',\n  'discount',\n  'email',\n  'giftcard',\n  'media',\n  'notification',\n  'order',\n  'payment',\n  'product',\n  'review',\n  'shipping',\n  'wishlist',\n] as const;\n\nexport type PrimitiveDomain = typeof AVAILABLE_DOMAINS[number];\n","/**\n * Built-in Primitives\n *\n * System primitives that come pre-installed with the CMS.\n * These provide essential functionality and serve as examples.\n */\n\nimport { prisma } from '../db';\nimport type { CreatePrimitiveRequest, JSONSchema } from './types';\nimport { getPluginRegistry } from './registry';\nimport { DOMAIN_PRIMITIVES } from './primitives';\n\n/**\n * Core utility primitives (data, text, math, logic, datetime)\n */\nconst CORE_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  // ============================================================================\n  // DATA PRIMITIVES\n  // ============================================================================\n  {\n    name: 'transform_json',\n    description: 'Transform JSON data using a JavaScript expression. Useful for mapping, filtering, and reshaping data.',\n    category: 'data',\n    tags: ['data', 'transform', 'json'],\n    icon: 'Braces',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        data: {\n          type: 'object',\n          description: 'The input data to transform',\n        },\n        expression: {\n          type: 'string',\n          description: 'JavaScript expression to transform the data. Use `data` to reference input.',\n        },\n      },\n      required: ['data', 'expression'],\n    },\n    handler: `\n      // Transform JSON data using expression\n      const result = eval(args.expression);\n      return result;\n    `,\n  },\n  {\n    name: 'validate_data',\n    description: 'Validate data against a JSON Schema and return validation results.',\n    category: 'data',\n    tags: ['data', 'validation', 'schema'],\n    icon: 'CheckCircle',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        data: {\n          type: 'object',\n          description: 'The data to validate',\n        },\n        schema: {\n          type: 'object',\n          description: 'JSON Schema to validate against',\n        },\n      },\n      required: ['data', 'schema'],\n    },\n    handler: `\n      const errors = [];\n      const schema = args.schema;\n      const data = args.data;\n\n      // Check required fields\n      if (schema.required) {\n        for (const field of schema.required) {\n          if (!(field in data)) {\n            errors.push({ field, message: 'Required field missing' });\n          }\n        }\n      }\n\n      // Check types\n      if (schema.properties) {\n        for (const [key, prop] of Object.entries(schema.properties)) {\n          if (key in data) {\n            const value = data[key];\n            const expectedType = prop.type;\n            const actualType = Array.isArray(value) ? 'array' : typeof value;\n\n            if (expectedType !== actualType && !(expectedType === 'null' && value === null)) {\n              errors.push({ field: key, message: 'Type mismatch: expected ' + expectedType + ', got ' + actualType });\n            }\n          }\n        }\n      }\n\n      return {\n        valid: errors.length === 0,\n        errors,\n        data: errors.length === 0 ? data : undefined\n      };\n    `,\n  },\n\n  // ============================================================================\n  // TEXT PRIMITIVES\n  // ============================================================================\n  {\n    name: 'format_text',\n    description: 'Format text using template literals. Supports variable interpolation.',\n    category: 'text',\n    tags: ['text', 'template', 'format'],\n    icon: 'FileText',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        template: {\n          type: 'string',\n          description: 'Template string with {{variable}} placeholders',\n        },\n        variables: {\n          type: 'object',\n          description: 'Variables to interpolate into the template',\n        },\n      },\n      required: ['template', 'variables'],\n    },\n    handler: `\n      let result = args.template;\n      for (const [key, value] of Object.entries(args.variables)) {\n        result = result.replace(new RegExp('{{' + key + '}}', 'g'), String(value));\n      }\n      return result;\n    `,\n  },\n  {\n    name: 'parse_csv',\n    description: 'Parse CSV text into an array of objects.',\n    category: 'text',\n    tags: ['text', 'csv', 'parse'],\n    icon: 'Table',\n    timeout: 10000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        csv: {\n          type: 'string',\n          description: 'CSV text to parse',\n        },\n        delimiter: {\n          type: 'string',\n          description: 'Column delimiter (default: comma)',\n          default: ',',\n        },\n        hasHeader: {\n          type: 'boolean',\n          description: 'First row is header (default: true)',\n          default: true,\n        },\n      },\n      required: ['csv'],\n    },\n    handler: `\n      const delimiter = args.delimiter || ',';\n      const hasHeader = args.hasHeader !== false;\n      const lines = args.csv.trim().split('\\\\n');\n\n      if (lines.length === 0) return [];\n\n      const headers = hasHeader\n        ? lines[0].split(delimiter).map(h => h.trim())\n        : lines[0].split(delimiter).map((_, i) => 'column' + i);\n\n      const dataLines = hasHeader ? lines.slice(1) : lines;\n\n      return dataLines.map(line => {\n        const values = line.split(delimiter);\n        const obj = {};\n        headers.forEach((header, i) => {\n          obj[header] = values[i]?.trim() || '';\n        });\n        return obj;\n      });\n    `,\n  },\n\n  // ============================================================================\n  // MATH PRIMITIVES\n  // ============================================================================\n  {\n    name: 'calculate',\n    description: 'Evaluate a mathematical expression safely.',\n    category: 'math',\n    tags: ['math', 'calculate', 'expression'],\n    icon: 'Calculator',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        expression: {\n          type: 'string',\n          description: 'Mathematical expression to evaluate (e.g., \"2 + 2 * 3\")',\n        },\n        variables: {\n          type: 'object',\n          description: 'Variables to use in the expression',\n        },\n      },\n      required: ['expression'],\n    },\n    handler: `\n      // Safe math evaluation - only allows numbers and math operators\n      let expr = args.expression;\n\n      // Replace variables\n      if (args.variables) {\n        for (const [key, value] of Object.entries(args.variables)) {\n          expr = expr.replace(new RegExp('\\\\\\\\b' + key + '\\\\\\\\b', 'g'), String(value));\n        }\n      }\n\n      // Validate expression contains only safe characters\n      if (!/^[\\\\d\\\\s+\\\\-*/().]+$/.test(expr)) {\n        throw new Error('Invalid expression: only numbers and math operators allowed');\n      }\n\n      return eval(expr);\n    `,\n  },\n  {\n    name: 'aggregate',\n    description: 'Aggregate an array of numbers (sum, avg, min, max, count).',\n    category: 'math',\n    tags: ['math', 'aggregate', 'statistics'],\n    icon: 'BarChart',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        values: {\n          type: 'array',\n          description: 'Array of numbers to aggregate',\n        },\n        operations: {\n          type: 'array',\n          description: 'Operations to perform: sum, avg, min, max, count',\n          default: ['sum', 'avg', 'min', 'max', 'count'],\n        },\n      },\n      required: ['values'],\n    },\n    handler: `\n      const nums = args.values.filter(v => typeof v === 'number');\n      const ops = args.operations || ['sum', 'avg', 'min', 'max', 'count'];\n      const result = {};\n\n      if (ops.includes('sum')) result.sum = nums.reduce((a, b) => a + b, 0);\n      if (ops.includes('avg')) result.avg = nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : 0;\n      if (ops.includes('min')) result.min = nums.length ? Math.min(...nums) : null;\n      if (ops.includes('max')) result.max = nums.length ? Math.max(...nums) : null;\n      if (ops.includes('count')) result.count = nums.length;\n\n      return result;\n    `,\n  },\n\n  // ============================================================================\n  // LOGIC PRIMITIVES\n  // ============================================================================\n  {\n    name: 'conditional',\n    description: 'Evaluate a condition and return different values based on result.',\n    category: 'logic',\n    tags: ['logic', 'condition', 'if-else'],\n    icon: 'GitBranch',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        condition: {\n          type: 'string',\n          description: 'JavaScript expression that evaluates to boolean',\n        },\n        context: {\n          type: 'object',\n          description: 'Variables available in the condition',\n        },\n        thenValue: {\n          description: 'Value to return if condition is true',\n        },\n        elseValue: {\n          description: 'Value to return if condition is false',\n        },\n      },\n      required: ['condition'],\n    },\n    handler: `\n      // Build context for eval\n      const ctx = args.context || {};\n      const contextKeys = Object.keys(ctx);\n      const contextValues = Object.values(ctx);\n\n      // Create function with context variables\n      const evalFn = new Function(...contextKeys, 'return ' + args.condition);\n      const result = evalFn(...contextValues);\n\n      return result ? args.thenValue : args.elseValue;\n    `,\n  },\n  {\n    name: 'switch_case',\n    description: 'Match a value against multiple cases and return the corresponding result.',\n    category: 'logic',\n    tags: ['logic', 'switch', 'match'],\n    icon: 'Route',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        value: {\n          description: 'Value to match against cases',\n        },\n        cases: {\n          type: 'object',\n          description: 'Object mapping case values to results',\n        },\n        default: {\n          description: 'Default value if no case matches',\n        },\n      },\n      required: ['value', 'cases'],\n    },\n    handler: `\n      const value = String(args.value);\n      if (value in args.cases) {\n        return args.cases[value];\n      }\n      return args.default;\n    `,\n  },\n\n  // ============================================================================\n  // DATE/TIME PRIMITIVES\n  // ============================================================================\n  {\n    name: 'format_date',\n    description: 'Format a date using a format string.',\n    category: 'datetime',\n    tags: ['date', 'time', 'format'],\n    icon: 'Calendar',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        date: {\n          type: 'string',\n          description: 'Date string or timestamp to format',\n        },\n        format: {\n          type: 'string',\n          description: 'Format string (YYYY, MM, DD, HH, mm, ss)',\n          default: 'YYYY-MM-DD',\n        },\n        timezone: {\n          type: 'string',\n          description: 'Timezone (e.g., \"America/New_York\")',\n        },\n      },\n      required: ['date'],\n    },\n    handler: `\n      const d = new Date(args.date);\n      const format = args.format || 'YYYY-MM-DD';\n\n      const pad = (n) => String(n).padStart(2, '0');\n\n      return format\n        .replace('YYYY', d.getFullYear())\n        .replace('MM', pad(d.getMonth() + 1))\n        .replace('DD', pad(d.getDate()))\n        .replace('HH', pad(d.getHours()))\n        .replace('mm', pad(d.getMinutes()))\n        .replace('ss', pad(d.getSeconds()));\n    `,\n  },\n  {\n    name: 'date_diff',\n    description: 'Calculate the difference between two dates.',\n    category: 'datetime',\n    tags: ['date', 'time', 'difference'],\n    icon: 'Clock',\n    timeout: 5000,\n    builtIn: true,\n    inputSchema: {\n      type: 'object',\n      properties: {\n        startDate: {\n          type: 'string',\n          description: 'Start date',\n        },\n        endDate: {\n          type: 'string',\n          description: 'End date',\n        },\n        unit: {\n          type: 'string',\n          description: 'Unit: days, hours, minutes, seconds',\n          enum: ['days', 'hours', 'minutes', 'seconds'],\n          default: 'days',\n        },\n      },\n      required: ['startDate', 'endDate'],\n    },\n    handler: `\n      const start = new Date(args.startDate);\n      const end = new Date(args.endDate);\n      const diffMs = end - start;\n\n      const unit = args.unit || 'days';\n      const divisors = {\n        days: 86400000,\n        hours: 3600000,\n        minutes: 60000,\n        seconds: 1000,\n      };\n\n      return Math.floor(diffMs / divisors[unit]);\n    `,\n  },\n];\n\n/**\n * All built-in primitives (core utilities + domain-specific)\n */\nconst BUILT_IN_PRIMITIVES: Array<CreatePrimitiveRequest & { builtIn: true }> = [\n  ...CORE_PRIMITIVES,\n  ...DOMAIN_PRIMITIVES,\n];\n\n// Export for external use\nexport { BUILT_IN_PRIMITIVES, CORE_PRIMITIVES, DOMAIN_PRIMITIVES };\n\n/**\n * Load built-in primitives into the database\n */\nexport async function loadBuiltInPrimitives(): Promise<{\n  loaded: number;\n  skipped: number;\n  errors: string[];\n}> {\n  let loaded = 0;\n  let skipped = 0;\n  const errors: string[] = [];\n\n  for (const primitive of BUILT_IN_PRIMITIVES) {\n    try {\n      // Check if already exists\n      const existing = await prisma.primitive.findUnique({\n        where: { name: primitive.name },\n      });\n\n      if (existing) {\n        // Update if version changed\n        if (existing.builtIn) {\n          skipped++;\n          continue;\n        }\n      }\n\n      // Create or update\n      await prisma.primitive.upsert({\n        where: { name: primitive.name },\n        create: {\n          name: primitive.name,\n          description: primitive.description,\n          inputSchema: primitive.inputSchema as object,\n          handler: primitive.handler,\n          category: primitive.category,\n          tags: primitive.tags || [],\n          icon: primitive.icon,\n          timeout: primitive.timeout || 30000,\n          enabled: true,\n          builtIn: true,\n        },\n        update: {\n          description: primitive.description,\n          inputSchema: primitive.inputSchema as object,\n          handler: primitive.handler,\n          category: primitive.category,\n          tags: primitive.tags || [],\n          icon: primitive.icon,\n          timeout: primitive.timeout || 30000,\n        },\n      });\n\n      loaded++;\n    } catch (e) {\n      errors.push(`Failed to load ${primitive.name}: ${e instanceof Error ? e.message : String(e)}`);\n    }\n  }\n\n  // Initialize registry after loading\n  const registry = getPluginRegistry();\n  await registry.initialize();\n\n  return { loaded, skipped, errors };\n}\n\n/**\n * Get list of built-in primitive names\n */\nexport function getBuiltInPrimitiveNames(): string[] {\n  return BUILT_IN_PRIMITIVES.map(p => p.name);\n}\n","/**\n * Product Reviews Service\n *\n * Handles review submission, moderation, voting, and statistics\n */\n\nimport { prisma } from '../db';\nimport { sendEmail } from '../email';\nimport { getEmailSettings } from '../settings';\nimport type { ReviewStatus, Prisma } from '@prisma/client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface ReviewSubmission {\n  productId: string;\n  customerId?: string;\n  orderId?: string;\n  reviewerName: string;\n  reviewerEmail: string;\n  rating: number; // 1-5\n  title?: string;\n  content: string;\n  pros?: string;\n  cons?: string;\n  images?: string[];\n  ipAddress?: string;\n  userAgent?: string;\n}\n\nexport interface ReviewFilters {\n  productId?: string;\n  status?: ReviewStatus;\n  rating?: number;\n  minRating?: number;\n  maxRating?: number;\n  isVerifiedPurchase?: boolean;\n  search?: string;\n}\n\nexport interface ReviewSort {\n  field: 'createdAt' | 'rating' | 'helpfulCount';\n  direction: 'asc' | 'desc';\n}\n\nexport interface ReviewStats {\n  averageRating: number;\n  totalReviews: number;\n  ratingDistribution: {\n    1: number;\n    2: number;\n    3: number;\n    4: number;\n    5: number;\n  };\n  verifiedPurchaseCount: number;\n  withImagesCount: number;\n}\n\nexport interface PaginatedReviews {\n  reviews: Array<Awaited<ReturnType<typeof getReviewWithVotes>>>;\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nasync function getReviewWithVotes(reviewId: string) {\n  return prisma.productReview.findUnique({\n    where: { id: reviewId },\n    include: {\n      product: {\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n          images: {\n            take: 1,\n            include: {\n              media: {\n                select: { url: true },\n              },\n            },\n          },\n        },\n      },\n      customer: {\n        select: {\n          id: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// Review CRUD\n// ============================================================================\n\n/**\n * Get reviews with pagination and filtering\n */\nexport async function getReviews(\n  filters: ReviewFilters = {},\n  sort: ReviewSort = { field: 'createdAt', direction: 'desc' },\n  page: number = 1,\n  pageSize: number = 10\n): Promise<PaginatedReviews> {\n  const where: Prisma.ProductReviewWhereInput = {};\n\n  if (filters.productId) {\n    where.productId = filters.productId;\n  }\n\n  if (filters.status) {\n    where.status = filters.status;\n  }\n\n  if (filters.rating) {\n    where.rating = filters.rating;\n  }\n\n  if (filters.minRating) {\n    where.rating = { ...where.rating as object, gte: filters.minRating };\n  }\n\n  if (filters.maxRating) {\n    where.rating = { ...where.rating as object, lte: filters.maxRating };\n  }\n\n  if (filters.isVerifiedPurchase !== undefined) {\n    where.isVerifiedPurchase = filters.isVerifiedPurchase;\n  }\n\n  if (filters.search) {\n    where.OR = [\n      { title: { contains: filters.search, mode: 'insensitive' } },\n      { content: { contains: filters.search, mode: 'insensitive' } },\n      { reviewerName: { contains: filters.search, mode: 'insensitive' } },\n    ];\n  }\n\n  const [reviews, total] = await Promise.all([\n    prisma.productReview.findMany({\n      where,\n      orderBy: { [sort.field]: sort.direction },\n      skip: (page - 1) * pageSize,\n      take: pageSize,\n      include: {\n        product: {\n          select: {\n            id: true,\n            title: true,\n            slug: true,\n            images: {\n              take: 1,\n              include: {\n                media: {\n                  select: { url: true },\n                },\n              },\n            },\n          },\n        },\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n          },\n        },\n      },\n    }),\n    prisma.productReview.count({ where }),\n  ]);\n\n  return {\n    reviews,\n    total,\n    page,\n    pageSize,\n    totalPages: Math.ceil(total / pageSize),\n  };\n}\n\n/**\n * Get reviews for a specific product (public-facing)\n */\nexport async function getProductReviews(\n  productId: string,\n  page: number = 1,\n  pageSize: number = 10,\n  sort: ReviewSort = { field: 'helpfulCount', direction: 'desc' }\n): Promise<PaginatedReviews> {\n  return getReviews(\n    { productId, status: 'APPROVED' },\n    sort,\n    page,\n    pageSize\n  );\n}\n\n/**\n * Get a single review by ID\n */\nexport async function getReviewById(reviewId: string) {\n  return getReviewWithVotes(reviewId);\n}\n\n/**\n * Submit a new review\n */\nexport async function submitReview(data: ReviewSubmission) {\n  // Validate rating\n  if (data.rating < 1 || data.rating > 5) {\n    throw new Error('Rating must be between 1 and 5');\n  }\n\n  // Check if product exists\n  const product = await prisma.product.findUnique({\n    where: { id: data.productId },\n  });\n\n  if (!product) {\n    throw new Error('Product not found');\n  }\n\n  // Check for verified purchase\n  let isVerifiedPurchase = false;\n  if (data.orderId) {\n    const orderItem = await prisma.orderItem.findFirst({\n      where: {\n        order: {\n          id: data.orderId,\n          paymentStatus: 'PAID',\n        },\n        productId: data.productId,\n      },\n    });\n    isVerifiedPurchase = !!orderItem;\n  } else if (data.customerId) {\n    // Check if user has purchased this product\n    const orderItem = await prisma.orderItem.findFirst({\n      where: {\n        order: {\n          customerId: data.customerId,\n          paymentStatus: 'PAID',\n        },\n        productId: data.productId,\n      },\n    });\n    isVerifiedPurchase = !!orderItem;\n  }\n\n  // Check for duplicate review (same customer/email + product)\n  const existingReview = await prisma.productReview.findFirst({\n    where: {\n      productId: data.productId,\n      OR: [\n        ...(data.customerId ? [{ customerId: data.customerId }] : []),\n        { reviewerEmail: data.reviewerEmail },\n      ],\n    },\n  });\n\n  if (existingReview) {\n    throw new Error('You have already reviewed this product');\n  }\n\n  // Create the review\n  const review = await prisma.productReview.create({\n    data: {\n      productId: data.productId,\n      customerId: data.customerId,\n      orderId: data.orderId,\n      reviewerName: data.reviewerName,\n      reviewerEmail: data.reviewerEmail,\n      rating: data.rating,\n      title: data.title,\n      content: data.content,\n      pros: data.pros,\n      cons: data.cons,\n      images: data.images || [],\n      isVerifiedPurchase,\n      status: 'PENDING', // Requires moderation\n      ipAddress: data.ipAddress,\n      userAgent: data.userAgent,\n    },\n    include: {\n      product: {\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n        },\n      },\n    },\n  });\n\n  return review;\n}\n\n/**\n * Update a review (admin moderation)\n */\nexport async function updateReview(\n  reviewId: string,\n  data: {\n    status?: ReviewStatus;\n    responseContent?: string;\n    respondedById?: string;\n  }\n) {\n  const updateData: Prisma.ProductReviewUpdateInput = {};\n\n  if (data.status) {\n    updateData.status = data.status;\n    if (data.status === 'APPROVED') {\n      updateData.publishedAt = new Date();\n    }\n  }\n\n  if (data.responseContent !== undefined) {\n    updateData.responseContent = data.responseContent;\n    updateData.responseAt = new Date();\n    updateData.respondedById = data.respondedById;\n  }\n\n  return prisma.productReview.update({\n    where: { id: reviewId },\n    data: updateData,\n    include: {\n      product: {\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Delete a review\n */\nexport async function deleteReview(reviewId: string) {\n  return prisma.productReview.delete({\n    where: { id: reviewId },\n  });\n}\n\n/**\n * Approve a pending review\n */\nexport async function approveReview(reviewId: string) {\n  return updateReview(reviewId, { status: 'APPROVED' });\n}\n\n/**\n * Reject a review\n */\nexport async function rejectReview(reviewId: string) {\n  return updateReview(reviewId, { status: 'REJECTED' });\n}\n\n/**\n * Flag a review for further review\n */\nexport async function flagReview(reviewId: string) {\n  return updateReview(reviewId, { status: 'FLAGGED' });\n}\n\n/**\n * Add store response to a review\n */\nexport async function respondToReview(\n  reviewId: string,\n  responseContent: string,\n  respondedById: string\n) {\n  return updateReview(reviewId, {\n    responseContent,\n    respondedById,\n  });\n}\n\n// ============================================================================\n// Voting\n// ============================================================================\n\n/**\n * Vote on a review (helpful/unhelpful)\n */\nexport async function voteReview(\n  reviewId: string,\n  helpful: boolean,\n  userId?: string,\n  email?: string\n) {\n  if (!userId && !email) {\n    throw new Error('User ID or email is required to vote');\n  }\n\n  // Check if already voted\n  const existingVote = await prisma.reviewVote.findFirst({\n    where: {\n      reviewId,\n      OR: [\n        ...(userId ? [{ userId }] : []),\n        ...(email ? [{ email }] : []),\n      ],\n    },\n  });\n\n  if (existingVote) {\n    // Update existing vote if different\n    if (existingVote.helpful !== helpful) {\n      await prisma.$transaction([\n        prisma.reviewVote.update({\n          where: { id: existingVote.id },\n          data: { helpful },\n        }),\n        prisma.productReview.update({\n          where: { id: reviewId },\n          data: {\n            helpfulCount: helpful ? { increment: 1 } : { decrement: 1 },\n            unhelpfulCount: helpful ? { decrement: 1 } : { increment: 1 },\n          },\n        }),\n      ]);\n    }\n    return { updated: true };\n  }\n\n  // Create new vote\n  await prisma.$transaction([\n    prisma.reviewVote.create({\n      data: {\n        reviewId,\n        userId,\n        email,\n        helpful,\n      },\n    }),\n    prisma.productReview.update({\n      where: { id: reviewId },\n      data: {\n        helpfulCount: helpful ? { increment: 1 } : undefined,\n        unhelpfulCount: helpful ? undefined : { increment: 1 },\n      },\n    }),\n  ]);\n\n  return { created: true };\n}\n\n// ============================================================================\n// Statistics\n// ============================================================================\n\n/**\n * Get review statistics for a product\n */\nexport async function getProductReviewStats(productId: string): Promise<ReviewStats> {\n  const reviews = await prisma.productReview.findMany({\n    where: {\n      productId,\n      status: 'APPROVED',\n    },\n    select: {\n      rating: true,\n      isVerifiedPurchase: true,\n      images: true,\n    },\n  });\n\n  const totalReviews = reviews.length;\n\n  if (totalReviews === 0) {\n    return {\n      averageRating: 0,\n      totalReviews: 0,\n      ratingDistribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 },\n      verifiedPurchaseCount: 0,\n      withImagesCount: 0,\n    };\n  }\n\n  const ratingDistribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n  let ratingSum = 0;\n  let verifiedPurchaseCount = 0;\n  let withImagesCount = 0;\n\n  for (const review of reviews) {\n    ratingDistribution[review.rating as keyof typeof ratingDistribution]++;\n    ratingSum += review.rating;\n    if (review.isVerifiedPurchase) verifiedPurchaseCount++;\n    if (review.images && Array.isArray(review.images) && review.images.length > 0) {\n      withImagesCount++;\n    }\n  }\n\n  return {\n    averageRating: Math.round((ratingSum / totalReviews) * 10) / 10,\n    totalReviews,\n    ratingDistribution,\n    verifiedPurchaseCount,\n    withImagesCount,\n  };\n}\n\n/**\n * Get overall review statistics (admin dashboard)\n */\nexport async function getReviewDashboardStats() {\n  const [total, pending, approved, rejected, flagged, avgRating] = await Promise.all([\n    prisma.productReview.count(),\n    prisma.productReview.count({ where: { status: 'PENDING' } }),\n    prisma.productReview.count({ where: { status: 'APPROVED' } }),\n    prisma.productReview.count({ where: { status: 'REJECTED' } }),\n    prisma.productReview.count({ where: { status: 'FLAGGED' } }),\n    prisma.productReview.aggregate({\n      where: { status: 'APPROVED' },\n      _avg: { rating: true },\n    }),\n  ]);\n\n  return {\n    total,\n    pending,\n    approved,\n    rejected,\n    flagged,\n    averageRating: Math.round((avgRating._avg.rating || 0) * 10) / 10,\n  };\n}\n\n// ============================================================================\n// Eligibility\n// ============================================================================\n\n/**\n * Check if a customer can review a product\n */\nexport async function canCustomerReviewProduct(\n  productId: string,\n  customerId?: string,\n  email?: string\n): Promise<{\n  canReview: boolean;\n  reason?: string;\n  isVerifiedPurchaser: boolean;\n}> {\n  if (!customerId && !email) {\n    return {\n      canReview: true,\n      isVerifiedPurchaser: false,\n    };\n  }\n\n  // Check for existing review\n  const existingReview = await prisma.productReview.findFirst({\n    where: {\n      productId,\n      OR: [\n        ...(customerId ? [{ customerId }] : []),\n        ...(email ? [{ reviewerEmail: email }] : []),\n      ],\n    },\n  });\n\n  if (existingReview) {\n    return {\n      canReview: false,\n      reason: 'You have already reviewed this product',\n      isVerifiedPurchaser: existingReview.isVerifiedPurchase,\n    };\n  }\n\n  // Check if customer has purchased\n  let isVerifiedPurchaser = false;\n  if (customerId) {\n    const purchase = await prisma.orderItem.findFirst({\n      where: {\n        order: {\n          customerId,\n          paymentStatus: 'PAID',\n        },\n        productId,\n      },\n    });\n    isVerifiedPurchaser = !!purchase;\n  }\n\n  return {\n    canReview: true,\n    isVerifiedPurchaser,\n  };\n}\n\n// ============================================================================\n// Review Request Emails\n// ============================================================================\n\n/**\n * Get orders eligible for review requests\n * (delivered orders without review requests sent)\n */\nexport async function getOrdersForReviewRequest(\n  daysAfterDelivery: number = 7,\n  limit: number = 50\n) {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - daysAfterDelivery);\n\n  // Find delivered orders within the timeframe\n  // We'll filter out already-sent review requests by checking internalNotes\n  const orders = await prisma.order.findMany({\n    where: {\n      status: 'DELIVERED',\n      paymentStatus: 'PAID',\n      // Filter out orders that already have review request sent (stored in internalNotes)\n      NOT: {\n        internalNotes: { contains: '[REVIEW_REQUEST_SENT]' },\n      },\n      // Find orders with shipments delivered around the cutoff\n      shipments: {\n        some: {\n          deliveredAt: {\n            lte: cutoffDate,\n            gte: new Date(cutoffDate.getTime() - 24 * 60 * 60 * 1000), // Within 1 day window\n          },\n        },\n      },\n    },\n    include: {\n      items: {\n        include: {\n          product: {\n            select: {\n              id: true,\n              title: true,\n              slug: true,\n              images: {\n                take: 1,\n                include: {\n                  media: {\n                    select: { url: true },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      customer: {\n        select: {\n          firstName: true,\n          lastName: true,\n        },\n      },\n      shippingAddress: true,\n    },\n    take: limit,\n  });\n\n  return orders;\n}\n\n/**\n * Send review request email for an order\n */\nexport async function sendReviewRequestEmail(orderId: string): Promise<{\n  success: boolean;\n  messageId?: string;\n  error?: string;\n}> {\n  try {\n    const order = await prisma.order.findUnique({\n      where: { id: orderId },\n      include: {\n        items: {\n          include: {\n            product: {\n              select: {\n                id: true,\n                title: true,\n                slug: true,\n                images: {\n                  take: 1,\n                  include: {\n                    media: {\n                      select: { url: true },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        customer: {\n          select: {\n            firstName: true,\n            lastName: true,\n          },\n        },\n        shippingAddress: true,\n      },\n    });\n\n    if (!order || !order.email) {\n      return { success: false, error: 'Order not found or no email' };\n    }\n\n    const settings = await getEmailSettings();\n    const storeUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';\n    const storeName = settings.fromName || 'Our Store';\n\n    // Filter products that haven't been reviewed yet by this customer\n    const productsToReview = [];\n    for (const item of order.items) {\n      const existingReview = await prisma.productReview.findFirst({\n        where: {\n          productId: item.productId,\n          reviewerEmail: order.email,\n        },\n      });\n      if (!existingReview && item.product) {\n        productsToReview.push(item);\n      }\n    }\n\n    if (productsToReview.length === 0) {\n      // All products already reviewed\n      await markReviewRequestSent(orderId);\n      return { success: true, messageId: 'skipped-already-reviewed' };\n    }\n\n    const customerName = order.shippingAddress\n      ? `${order.shippingAddress.firstName} ${order.shippingAddress.lastName}`.trim()\n      : order.customer ? [order.customer.firstName, order.customer.lastName].filter(Boolean).join(' ') || 'Valued Customer' : 'Valued Customer';\n\n    // Generate email HTML\n    const emailHtml = generateReviewRequestEmail({\n      storeName,\n      storeUrl,\n      customerName,\n      orderNumber: order.orderNumber,\n      products: productsToReview.map((item) => ({\n        id: item.product!.id,\n        name: item.product!.title,\n        slug: item.product!.slug,\n        imageUrl: item.product!.images[0]?.media?.url,\n      })),\n    });\n\n    // Send email\n    const result = await sendEmail({\n      to: { email: order.email, name: customerName },\n      subject: `How was your purchase? Leave a review!`,\n      html: emailHtml,\n    });\n\n    if (result.success) {\n      await markReviewRequestSent(orderId);\n    }\n\n    return result;\n  } catch (error) {\n    console.error('Send review request email error:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to send email',\n    };\n  }\n}\n\n/**\n * Mark order as having review request sent\n * Uses internalNotes to track this since Order doesn't have metadata\n */\nasync function markReviewRequestSent(orderId: string) {\n  const order = await prisma.order.findUnique({\n    where: { id: orderId },\n    select: { internalNotes: true },\n  });\n\n  const currentNotes = order?.internalNotes || '';\n  const timestamp = new Date().toISOString();\n  const marker = `[REVIEW_REQUEST_SENT:${timestamp}]`;\n\n  await prisma.order.update({\n    where: { id: orderId },\n    data: {\n      internalNotes: currentNotes ? `${currentNotes}\\n${marker}` : marker,\n    },\n  });\n}\n\n/**\n * Generate review request email HTML\n */\nfunction generateReviewRequestEmail(data: {\n  storeName: string;\n  storeUrl: string;\n  customerName: string;\n  orderNumber: string;\n  products: Array<{\n    id: string;\n    name: string;\n    slug: string;\n    imageUrl?: string;\n  }>;\n}): string {\n  const productBlocks = data.products\n    .map(\n      (product) => `\n    <tr>\n      <td style=\"padding: 16px 0; border-bottom: 1px solid #e4e4e7;\">\n        <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\">\n          <tr>\n            ${\n              product.imageUrl\n                ? `\n            <td width=\"80\" valign=\"middle\" style=\"padding-right: 16px;\">\n              <img src=\"${product.imageUrl}\" alt=\"${product.name}\" width=\"80\" height=\"80\" style=\"border-radius: 8px; object-fit: cover;\">\n            </td>\n            `\n                : ''\n            }\n            <td valign=\"middle\">\n              <p style=\"margin: 0 0 8px 0; font-size: 16px; font-weight: 600; color: #18181b;\">${product.name}</p>\n              <a href=\"${data.storeUrl}/products/${product.slug}?review=true#reviews\" style=\"display: inline-block; padding: 8px 16px; background-color: #18181b; color: #ffffff; text-decoration: none; border-radius: 6px; font-size: 14px; font-weight: 500;\">Write a Review</a>\n            </td>\n          </tr>\n        </table>\n      </td>\n    </tr>\n  `\n    )\n    .join('');\n\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Review Your Purchase</title>\n</head>\n<body style=\"margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f4f4f5;\">\n  <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"background-color: #f4f4f5;\">\n    <tr>\n      <td style=\"padding: 40px 20px;\">\n        <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"600\" style=\"margin: 0 auto; background-color: #ffffff; border-radius: 12px; overflow: hidden;\">\n          <!-- Header -->\n          <tr>\n            <td style=\"padding: 32px 40px; background-color: #18181b; text-align: center;\">\n              <h1 style=\"margin: 0; color: #ffffff; font-size: 24px; font-weight: 700;\">${data.storeName}</h1>\n            </td>\n          </tr>\n\n          <!-- Content -->\n          <tr>\n            <td style=\"padding: 40px;\">\n              <!-- Star Rating Icon -->\n              <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin-bottom: 24px;\">\n                <tr>\n                  <td align=\"center\">\n                    <div style=\"font-size: 48px;\">\n                      <span style=\"color: #fbbf24;\">&#9733;</span>\n                      <span style=\"color: #fbbf24;\">&#9733;</span>\n                      <span style=\"color: #fbbf24;\">&#9733;</span>\n                      <span style=\"color: #fbbf24;\">&#9733;</span>\n                      <span style=\"color: #fbbf24;\">&#9733;</span>\n                    </div>\n                  </td>\n                </tr>\n              </table>\n\n              <h2 style=\"margin: 0 0 16px 0; font-size: 24px; font-weight: 700; color: #18181b; text-align: center;\">How was your purchase?</h2>\n\n              <p style=\"margin: 0 0 24px 0; font-size: 16px; color: #52525b; line-height: 1.6; text-align: center;\">\n                Hi ${data.customerName},<br><br>\n                We hope you're enjoying your recent purchase from order #${data.orderNumber}! Your feedback helps other shoppers make informed decisions and helps us improve.\n              </p>\n\n              <p style=\"margin: 0 0 24px 0; font-size: 16px; color: #52525b; line-height: 1.6; text-align: center;\">\n                <strong>Would you take a moment to share your experience?</strong>\n              </p>\n\n              <!-- Products to Review -->\n              <table role=\"presentation\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" width=\"100%\" style=\"margin: 24px 0;\">\n                ${productBlocks}\n              </table>\n\n              <p style=\"margin: 24px 0 0 0; font-size: 14px; color: #71717a; line-height: 1.6; text-align: center;\">\n                Your honest review, whether positive or constructive, is valuable to us and our community.\n              </p>\n            </td>\n          </tr>\n\n          <!-- Footer -->\n          <tr>\n            <td style=\"padding: 24px 40px; background-color: #f4f4f5; text-align: center;\">\n              <p style=\"margin: 0 0 8px 0; font-size: 14px; color: #71717a;\">\n                Thank you for shopping with ${data.storeName}\n              </p>\n              <p style=\"margin: 0; font-size: 12px; color: #a1a1aa;\">\n                <a href=\"${data.storeUrl}\" style=\"color: #71717a; text-decoration: underline;\">Visit our store</a>\n              </p>\n            </td>\n          </tr>\n        </table>\n      </td>\n    </tr>\n  </table>\n</body>\n</html>\n  `.trim();\n}\n\n// ============================================================================\n// Bulk Operations (Admin)\n// ============================================================================\n\n/**\n * Bulk approve reviews\n */\nexport async function bulkApproveReviews(reviewIds: string[]) {\n  return prisma.productReview.updateMany({\n    where: { id: { in: reviewIds } },\n    data: {\n      status: 'APPROVED',\n      publishedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Bulk reject reviews\n */\nexport async function bulkRejectReviews(reviewIds: string[]) {\n  return prisma.productReview.updateMany({\n    where: { id: { in: reviewIds } },\n    data: { status: 'REJECTED' },\n  });\n}\n\n/**\n * Bulk delete reviews\n */\nexport async function bulkDeleteReviews(reviewIds: string[]) {\n  return prisma.productReview.deleteMany({\n    where: { id: { in: reviewIds } },\n  });\n}\n","/**\n * SEO Types and Configurations\n */\n\nimport type { Metadata } from 'next'\n\n// Base SEO configuration\nexport interface SeoConfig {\n  siteName: string\n  siteUrl: string\n  defaultTitle: string\n  titleTemplate: string // e.g., \"%s | Site Name\"\n  defaultDescription: string\n  defaultImage?: string\n  twitterHandle?: string\n  locale: string\n  themeColor?: string\n  keywords?: string[]\n}\n\n// Page-specific SEO data\nexport interface PageSeo {\n  title?: string\n  description?: string\n  keywords?: string[]\n  image?: string\n  noIndex?: boolean\n  noFollow?: boolean\n  canonical?: string\n  publishedTime?: string\n  modifiedTime?: string\n  author?: string\n  section?: string\n  tags?: string[]\n}\n\n// Product SEO data\nexport interface ProductSeo extends PageSeo {\n  price?: number\n  currency?: string\n  availability?: 'InStock' | 'OutOfStock' | 'PreOrder'\n  sku?: string\n  brand?: string\n  category?: string\n  reviewCount?: number\n  ratingValue?: number\n}\n\n// Article SEO data\nexport interface ArticleSeo extends PageSeo {\n  type?: 'article' | 'blog' | 'news'\n}\n\n// Open Graph types\nexport type OgType =\n  | 'website'\n  | 'article'\n  | 'product'\n  | 'profile'\n  | 'book'\n  | 'video.movie'\n  | 'video.episode'\n  | 'video.tv_show'\n  | 'video.other'\n  | 'music.song'\n  | 'music.album'\n\n// Structured data types\nexport type StructuredDataType =\n  | 'Organization'\n  | 'WebSite'\n  | 'WebPage'\n  | 'Product'\n  | 'Article'\n  | 'BlogPosting'\n  | 'BreadcrumbList'\n  | 'FAQPage'\n  | 'LocalBusiness'\n  | 'Person'\n  | 'Event'\n  | 'Review'\n  | 'HowTo'\n  | 'Recipe'\n  | 'VideoObject'\n\n// Breadcrumb item\nexport interface BreadcrumbItem {\n  name: string\n  url: string\n}\n\n// Organization data for structured data\nexport interface OrganizationData {\n  name: string\n  url: string\n  logo?: string\n  description?: string\n  sameAs?: string[] // Social profiles\n  contactPoint?: {\n    type: string\n    telephone?: string\n    email?: string\n    areaServed?: string\n    availableLanguage?: string[]\n  }\n}\n\n// Local business data\nexport interface LocalBusinessData extends OrganizationData {\n  address?: {\n    streetAddress: string\n    addressLocality: string\n    addressRegion: string\n    postalCode: string\n    addressCountry: string\n  }\n  geo?: {\n    latitude: number\n    longitude: number\n  }\n  openingHours?: string[]\n  priceRange?: string\n}\n\n// FAQ item\nexport interface FaqItem {\n  question: string\n  answer: string\n}\n\n// Default SEO config\nexport const DEFAULT_SEO_CONFIG: SeoConfig = {\n  siteName: 'My Store',\n  siteUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n  defaultTitle: 'My Store',\n  titleTemplate: '%s | My Store',\n  defaultDescription: 'Welcome to our store',\n  locale: 'en_US',\n  themeColor: '#000000',\n}\n\n// Robots configurations\nexport const ROBOTS_CONFIGS = {\n  default: {\n    index: true,\n    follow: true,\n    googleBot: {\n      index: true,\n      follow: true,\n      'max-video-preview': -1,\n      'max-image-preview': 'large' as const,\n      'max-snippet': -1,\n    },\n  },\n  noIndex: {\n    index: false,\n    follow: true,\n  },\n  noFollow: {\n    index: true,\n    follow: false,\n  },\n  none: {\n    index: false,\n    follow: false,\n  },\n}\n","/**\n * SEO Utilities Library\n *\n * Provides metadata generation, structured data, and SEO helpers\n */\n\nimport type { Metadata, Viewport } from 'next'\nimport { prisma } from '../db'\nimport type {\n  SeoConfig,\n  PageSeo,\n  ProductSeo,\n  ArticleSeo,\n  BreadcrumbItem,\n  OrganizationData,\n  LocalBusinessData,\n  FaqItem,\n  OgType,\n} from './types'\nimport { DEFAULT_SEO_CONFIG } from './types'\n\n// Cache for SEO settings\nlet seoConfigCache: SeoConfig | null = null\nlet seoConfigCacheTime = 0\nconst SEO_CACHE_TTL = 60 * 1000 // 1 minute\n\n/**\n * Get SEO configuration from database\n */\nexport async function getSeoConfig(): Promise<SeoConfig> {\n  const now = Date.now()\n  if (seoConfigCache && now - seoConfigCacheTime < SEO_CACHE_TTL) {\n    return seoConfigCache\n  }\n\n  const settings = await prisma.setting.findMany({\n    where: { key: { startsWith: 'seo.' } },\n  })\n\n  const config: SeoConfig = { ...DEFAULT_SEO_CONFIG }\n\n  for (const setting of settings) {\n    const key = setting.key.replace('seo.', '')\n    switch (key) {\n      case 'siteName':\n        config.siteName = setting.value\n        break\n      case 'siteUrl':\n        config.siteUrl = setting.value\n        break\n      case 'defaultTitle':\n        config.defaultTitle = setting.value\n        break\n      case 'titleTemplate':\n        config.titleTemplate = setting.value\n        break\n      case 'defaultDescription':\n        config.defaultDescription = setting.value\n        break\n      case 'defaultImage':\n        config.defaultImage = setting.value\n        break\n      case 'twitterHandle':\n        config.twitterHandle = setting.value\n        break\n      case 'locale':\n        config.locale = setting.value\n        break\n      case 'themeColor':\n        config.themeColor = setting.value\n        break\n      case 'keywords':\n        config.keywords = JSON.parse(setting.value)\n        break\n    }\n  }\n\n  seoConfigCache = config\n  seoConfigCacheTime = now\n\n  return config\n}\n\n/**\n * Clear SEO config cache\n */\nexport function clearSeoConfigCache(): void {\n  seoConfigCache = null\n  seoConfigCacheTime = 0\n}\n\n/**\n * Generate Next.js Metadata for a page\n */\nexport async function generateMetadata(\n  pageSeo: PageSeo = {},\n  type: OgType = 'website'\n): Promise<Metadata> {\n  const config = await getSeoConfig()\n\n  const title = pageSeo.title || config.defaultTitle\n  const description = pageSeo.description || config.defaultDescription\n  const image = pageSeo.image || config.defaultImage\n  const url = pageSeo.canonical || config.siteUrl\n\n  const metadata: Metadata = {\n    title: pageSeo.title\n      ? config.titleTemplate.replace('%s', pageSeo.title)\n      : config.defaultTitle,\n    description,\n    keywords: pageSeo.keywords || config.keywords,\n    authors: pageSeo.author ? [{ name: pageSeo.author }] : undefined,\n    metadataBase: new URL(config.siteUrl),\n    alternates: {\n      canonical: pageSeo.canonical,\n    },\n    openGraph: {\n      title,\n      description,\n      url,\n      siteName: config.siteName,\n      locale: config.locale,\n      type: type as 'website' | 'article',\n      images: image\n        ? [\n            {\n              url: image,\n              width: 1200,\n              height: 630,\n              alt: title,\n            },\n          ]\n        : undefined,\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title,\n      description,\n      images: image ? [image] : undefined,\n      creator: config.twitterHandle,\n      site: config.twitterHandle,\n    },\n    robots: {\n      index: !pageSeo.noIndex,\n      follow: !pageSeo.noFollow,\n      googleBot: {\n        index: !pageSeo.noIndex,\n        follow: !pageSeo.noFollow,\n        'max-video-preview': -1,\n        'max-image-preview': 'large',\n        'max-snippet': -1,\n      },\n    },\n  }\n\n  return metadata\n}\n\n/**\n * Generate metadata for a product page\n */\nexport async function generateProductMetadata(product: ProductSeo): Promise<Metadata> {\n  const baseMetadata = await generateMetadata(product, 'product')\n\n  // Add product-specific Open Graph data\n  if (baseMetadata.openGraph && product.price) {\n    (baseMetadata.openGraph as any).price = {\n      amount: product.price.toString(),\n      currency: product.currency || 'USD',\n    }\n  }\n\n  return baseMetadata\n}\n\n/**\n * Generate metadata for an article/blog post\n */\nexport async function generateArticleMetadata(article: ArticleSeo): Promise<Metadata> {\n  const metadata = await generateMetadata(article, 'article')\n\n  if (metadata.openGraph) {\n    const og = metadata.openGraph as any\n    og.type = 'article'\n    if (article.publishedTime) {\n      og.publishedTime = article.publishedTime\n    }\n    if (article.modifiedTime) {\n      og.modifiedTime = article.modifiedTime\n    }\n    if (article.author) {\n      og.authors = [article.author]\n    }\n    if (article.section) {\n      og.section = article.section\n    }\n    if (article.tags) {\n      og.tags = article.tags\n    }\n  }\n\n  return metadata\n}\n\n/**\n * Generate viewport configuration\n */\nexport function generateViewport(): Viewport {\n  return {\n    width: 'device-width',\n    initialScale: 1,\n    maximumScale: 5,\n    themeColor: [\n      { media: '(prefers-color-scheme: light)', color: '#ffffff' },\n      { media: '(prefers-color-scheme: dark)', color: '#000000' },\n    ],\n  }\n}\n\n// ============================================================================\n// STRUCTURED DATA (JSON-LD)\n// ============================================================================\n\n/**\n * Generate Organization structured data\n */\nexport function generateOrganizationSchema(org: OrganizationData): object {\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'Organization',\n    name: org.name,\n    url: org.url,\n    logo: org.logo,\n    description: org.description,\n    sameAs: org.sameAs,\n    contactPoint: org.contactPoint\n      ? {\n          '@type': 'ContactPoint',\n          contactType: org.contactPoint.type,\n          telephone: org.contactPoint.telephone,\n          email: org.contactPoint.email,\n          areaServed: org.contactPoint.areaServed,\n          availableLanguage: org.contactPoint.availableLanguage,\n        }\n      : undefined,\n  }\n}\n\n/**\n * Generate LocalBusiness structured data\n */\nexport function generateLocalBusinessSchema(business: LocalBusinessData): object {\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'LocalBusiness',\n    name: business.name,\n    url: business.url,\n    logo: business.logo,\n    description: business.description,\n    sameAs: business.sameAs,\n    address: business.address\n      ? {\n          '@type': 'PostalAddress',\n          streetAddress: business.address.streetAddress,\n          addressLocality: business.address.addressLocality,\n          addressRegion: business.address.addressRegion,\n          postalCode: business.address.postalCode,\n          addressCountry: business.address.addressCountry,\n        }\n      : undefined,\n    geo: business.geo\n      ? {\n          '@type': 'GeoCoordinates',\n          latitude: business.geo.latitude,\n          longitude: business.geo.longitude,\n        }\n      : undefined,\n    openingHoursSpecification: business.openingHours,\n    priceRange: business.priceRange,\n  }\n}\n\n/**\n * Generate WebSite structured data with search action\n */\nexport async function generateWebsiteSchema(searchPath = '/search'): Promise<object> {\n  const config = await getSeoConfig()\n\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'WebSite',\n    name: config.siteName,\n    url: config.siteUrl,\n    potentialAction: {\n      '@type': 'SearchAction',\n      target: {\n        '@type': 'EntryPoint',\n        urlTemplate: `${config.siteUrl}${searchPath}?q={search_term_string}`,\n      },\n      'query-input': 'required name=search_term_string',\n    },\n  }\n}\n\n/**\n * Generate BreadcrumbList structured data\n */\nexport async function generateBreadcrumbSchema(items: BreadcrumbItem[]): Promise<object> {\n  const config = await getSeoConfig()\n\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'BreadcrumbList',\n    itemListElement: items.map((item, index) => ({\n      '@type': 'ListItem',\n      position: index + 1,\n      name: item.name,\n      item: item.url.startsWith('http') ? item.url : `${config.siteUrl}${item.url}`,\n    })),\n  }\n}\n\n/**\n * Generate Product structured data\n */\nexport async function generateProductSchema(product: {\n  name: string\n  description?: string\n  image?: string | string[]\n  sku?: string\n  brand?: string\n  price: number\n  currency?: string\n  availability?: 'InStock' | 'OutOfStock' | 'PreOrder'\n  url?: string\n  reviewCount?: number\n  ratingValue?: number\n}): Promise<object> {\n  const config = await getSeoConfig()\n\n  const schema: any = {\n    '@context': 'https://schema.org',\n    '@type': 'Product',\n    name: product.name,\n    description: product.description,\n    image: product.image,\n    sku: product.sku,\n    brand: product.brand\n      ? {\n          '@type': 'Brand',\n          name: product.brand,\n        }\n      : undefined,\n    offers: {\n      '@type': 'Offer',\n      price: product.price,\n      priceCurrency: product.currency || 'USD',\n      availability: `https://schema.org/${product.availability || 'InStock'}`,\n      url: product.url || config.siteUrl,\n    },\n  }\n\n  if (product.reviewCount && product.ratingValue) {\n    schema.aggregateRating = {\n      '@type': 'AggregateRating',\n      ratingValue: product.ratingValue,\n      reviewCount: product.reviewCount,\n    }\n  }\n\n  return schema\n}\n\n/**\n * Generate Article/BlogPosting structured data\n */\nexport async function generateArticleSchema(article: {\n  headline: string\n  description?: string\n  image?: string\n  datePublished: string\n  dateModified?: string\n  author?: string\n  url?: string\n}): Promise<object> {\n  const config = await getSeoConfig()\n\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'Article',\n    headline: article.headline,\n    description: article.description,\n    image: article.image,\n    datePublished: article.datePublished,\n    dateModified: article.dateModified || article.datePublished,\n    author: article.author\n      ? {\n          '@type': 'Person',\n          name: article.author,\n        }\n      : undefined,\n    publisher: {\n      '@type': 'Organization',\n      name: config.siteName,\n      logo: config.defaultImage\n        ? {\n            '@type': 'ImageObject',\n            url: config.defaultImage,\n          }\n        : undefined,\n    },\n    mainEntityOfPage: {\n      '@type': 'WebPage',\n      '@id': article.url || config.siteUrl,\n    },\n  }\n}\n\n/**\n * Generate FAQ structured data\n */\nexport function generateFaqSchema(faqs: FaqItem[]): object {\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'FAQPage',\n    mainEntity: faqs.map((faq) => ({\n      '@type': 'Question',\n      name: faq.question,\n      acceptedAnswer: {\n        '@type': 'Answer',\n        text: faq.answer,\n      },\n    })),\n  }\n}\n\n/**\n * Render JSON-LD script tag\n */\nexport function renderJsonLd(data: object | object[]): string {\n  const jsonLd = Array.isArray(data) ? data : [data]\n  return `<script type=\"application/ld+json\">${JSON.stringify(jsonLd)}</script>`\n}\n\nexport * from './types'\n","/**\n * Site Settings Service\n *\n * Provides functions to fetch and manage global site settings\n * including header, footer, and announcement bar configurations.\n */\n\nimport { prisma } from '../db';\nimport { cache } from 'react';\n\nconst DEFAULT_SITE_SETTINGS_ID = 'default';\n\nexport interface SiteSettingsData {\n  id: string;\n  header: Record<string, unknown> | null;\n  footer: Record<string, unknown> | null;\n  announcementBar: Record<string, unknown> | null;\n  showAnnouncementBar: boolean;\n  siteName: string | null;\n  siteTagline: string | null;\n  logoUrl: string | null;\n  logoAlt: string | null;\n  faviconUrl: string | null;\n  socialLinks: Record<string, unknown>[] | null;\n  defaultMetaTitle: string | null;\n  defaultMetaDescription: string | null;\n  defaultOgImage: string | null;\n  contactEmail: string | null;\n  contactPhone: string | null;\n  businessAddress: Record<string, unknown> | null;\n  googleAnalyticsId: string | null;\n  facebookPixelId: string | null;\n}\n\n/**\n * Get site settings (cached per request)\n */\nexport const getSiteSettings = cache(async (): Promise<SiteSettingsData | null> => {\n  try {\n    const settings = await prisma.siteSettings.findUnique({\n      where: { id: DEFAULT_SITE_SETTINGS_ID },\n    });\n\n    if (!settings) {\n      return null;\n    }\n\n    return {\n      id: settings.id,\n      header: settings.header as Record<string, unknown> | null,\n      footer: settings.footer as Record<string, unknown> | null,\n      announcementBar: settings.announcementBar as Record<string, unknown> | null,\n      showAnnouncementBar: settings.showAnnouncementBar,\n      siteName: settings.siteName,\n      siteTagline: settings.siteTagline,\n      logoUrl: settings.logoUrl,\n      logoAlt: settings.logoAlt,\n      faviconUrl: settings.faviconUrl,\n      socialLinks: settings.socialLinks as Record<string, unknown>[] | null,\n      defaultMetaTitle: settings.defaultMetaTitle,\n      defaultMetaDescription: settings.defaultMetaDescription,\n      defaultOgImage: settings.defaultOgImage,\n      contactEmail: settings.contactEmail,\n      contactPhone: settings.contactPhone,\n      businessAddress: settings.businessAddress as Record<string, unknown> | null,\n      googleAnalyticsId: settings.googleAnalyticsId,\n      facebookPixelId: settings.facebookPixelId,\n    };\n  } catch (error) {\n    console.error('Error fetching site settings:', error);\n    return null;\n  }\n});\n\n/**\n * Get or create default site settings\n */\nexport async function getOrCreateSiteSettings(): Promise<SiteSettingsData> {\n  let settings = await getSiteSettings();\n\n  if (!settings) {\n    // Create default settings\n    const created = await prisma.siteSettings.create({\n      data: {\n        id: DEFAULT_SITE_SETTINGS_ID,\n        showAnnouncementBar: false,\n      },\n    });\n\n    settings = {\n      id: created.id,\n      header: null,\n      footer: null,\n      announcementBar: null,\n      showAnnouncementBar: created.showAnnouncementBar,\n      siteName: null,\n      siteTagline: null,\n      logoUrl: null,\n      logoAlt: null,\n      faviconUrl: null,\n      socialLinks: null,\n      defaultMetaTitle: null,\n      defaultMetaDescription: null,\n      defaultOgImage: null,\n      contactEmail: null,\n      contactPhone: null,\n      businessAddress: null,\n      googleAnalyticsId: null,\n      facebookPixelId: null,\n    };\n  }\n\n  return settings;\n}\n\n/**\n * Update site settings\n */\nexport async function updateSiteSettings(\n  data: Partial<Omit<SiteSettingsData, 'id'>>\n): Promise<SiteSettingsData> {\n  // Convert data to Prisma-compatible format\n  const prismaData = {\n    ...(data.header !== undefined && { header: data.header as object }),\n    ...(data.footer !== undefined && { footer: data.footer as object }),\n    ...(data.announcementBar !== undefined && { announcementBar: data.announcementBar as object }),\n    ...(data.showAnnouncementBar !== undefined && { showAnnouncementBar: data.showAnnouncementBar }),\n    ...(data.siteName !== undefined && { siteName: data.siteName }),\n    ...(data.siteTagline !== undefined && { siteTagline: data.siteTagline }),\n    ...(data.logoUrl !== undefined && { logoUrl: data.logoUrl }),\n    ...(data.logoAlt !== undefined && { logoAlt: data.logoAlt }),\n    ...(data.faviconUrl !== undefined && { faviconUrl: data.faviconUrl }),\n    ...(data.socialLinks !== undefined && { socialLinks: data.socialLinks as object }),\n    ...(data.defaultMetaTitle !== undefined && { defaultMetaTitle: data.defaultMetaTitle }),\n    ...(data.defaultMetaDescription !== undefined && { defaultMetaDescription: data.defaultMetaDescription }),\n    ...(data.defaultOgImage !== undefined && { defaultOgImage: data.defaultOgImage }),\n    ...(data.contactEmail !== undefined && { contactEmail: data.contactEmail }),\n    ...(data.contactPhone !== undefined && { contactPhone: data.contactPhone }),\n    ...(data.businessAddress !== undefined && { businessAddress: data.businessAddress as object }),\n    ...(data.googleAnalyticsId !== undefined && { googleAnalyticsId: data.googleAnalyticsId }),\n    ...(data.facebookPixelId !== undefined && { facebookPixelId: data.facebookPixelId }),\n  };\n\n  const updated = await prisma.siteSettings.upsert({\n    where: { id: DEFAULT_SITE_SETTINGS_ID },\n    create: {\n      id: DEFAULT_SITE_SETTINGS_ID,\n      ...prismaData,\n    },\n    update: prismaData,\n  });\n\n  return {\n    id: updated.id,\n    header: updated.header as Record<string, unknown> | null,\n    footer: updated.footer as Record<string, unknown> | null,\n    announcementBar: updated.announcementBar as Record<string, unknown> | null,\n    showAnnouncementBar: updated.showAnnouncementBar,\n    siteName: updated.siteName,\n    siteTagline: updated.siteTagline,\n    logoUrl: updated.logoUrl,\n    logoAlt: updated.logoAlt,\n    faviconUrl: updated.faviconUrl,\n    socialLinks: updated.socialLinks as Record<string, unknown>[] | null,\n    defaultMetaTitle: updated.defaultMetaTitle,\n    defaultMetaDescription: updated.defaultMetaDescription,\n    defaultOgImage: updated.defaultOgImage,\n    contactEmail: updated.contactEmail,\n    contactPhone: updated.contactPhone,\n    businessAddress: updated.businessAddress as Record<string, unknown> | null,\n    googleAnalyticsId: updated.googleAnalyticsId,\n    facebookPixelId: updated.facebookPixelId,\n  };\n}\n\n/**\n * Update header configuration\n */\nexport async function updateHeaderConfig(\n  headerData: Record<string, unknown>\n): Promise<SiteSettingsData> {\n  return updateSiteSettings({ header: headerData });\n}\n\n/**\n * Update footer configuration\n */\nexport async function updateFooterConfig(\n  footerData: Record<string, unknown>\n): Promise<SiteSettingsData> {\n  return updateSiteSettings({ footer: footerData });\n}\n\n/**\n * Update announcement bar configuration\n */\nexport async function updateAnnouncementBarConfig(\n  announcementData: Record<string, unknown>,\n  showAnnouncementBar: boolean\n): Promise<SiteSettingsData> {\n  return updateSiteSettings({\n    announcementBar: announcementData,\n    showAnnouncementBar,\n  });\n}\n","/**\n * Event Bus System\n *\n * Pub/sub event system for triggering workflows based on system events.\n * Supports event filtering, priority-based handlers, and async execution.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { prisma } from '../db';\nimport type {\n  WorkflowEvent,\n  WorkflowEventType,\n  EventSubscription,\n} from './types';\n\n// =============================================================================\n// EVENT BUS SINGLETON\n// =============================================================================\n\nclass EventBus {\n  private subscriptions: Map<string, EventSubscription[]> = new Map();\n  private eventHistory: WorkflowEvent[] = [];\n  private maxHistorySize = 1000;\n\n  /**\n   * Subscribe to events\n   */\n  subscribe(subscription: Omit<EventSubscription, 'id'>): string {\n    const id = uuidv4();\n    const fullSubscription: EventSubscription = { ...subscription, id };\n\n    const eventTypes = Array.isArray(subscription.eventType)\n      ? subscription.eventType\n      : [subscription.eventType];\n\n    for (const eventType of eventTypes) {\n      const existing = this.subscriptions.get(eventType) || [];\n      existing.push(fullSubscription);\n      // Sort by priority (higher first)\n      existing.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n      this.subscriptions.set(eventType, existing);\n    }\n\n    return id;\n  }\n\n  /**\n   * Unsubscribe from events\n   */\n  unsubscribe(subscriptionId: string): boolean {\n    let found = false;\n\n    for (const [eventType, subs] of this.subscriptions.entries()) {\n      const filtered = subs.filter((s) => s.id !== subscriptionId);\n      if (filtered.length !== subs.length) {\n        found = true;\n        this.subscriptions.set(eventType, filtered);\n      }\n    }\n\n    return found;\n  }\n\n  /**\n   * Emit an event\n   */\n  async emit<T = unknown>(\n    type: WorkflowEventType,\n    data: T,\n    metadata?: WorkflowEvent['metadata']\n  ): Promise<void> {\n    const event: WorkflowEvent<T> = {\n      id: uuidv4(),\n      type,\n      timestamp: new Date(),\n      data,\n      metadata,\n    };\n\n    // Add to history\n    this.eventHistory.push(event as WorkflowEvent);\n    if (this.eventHistory.length > this.maxHistorySize) {\n      this.eventHistory = this.eventHistory.slice(-this.maxHistorySize);\n    }\n\n    // Get subscribers for this event type\n    const subscribers = this.subscriptions.get(type) || [];\n    const wildcardSubscribers = this.subscriptions.get('*') || [];\n    const allSubscribers = [...subscribers, ...wildcardSubscribers];\n\n    // Execute handlers\n    for (const subscription of allSubscribers) {\n      try {\n        // Apply filter if present\n        if (subscription.filter && !subscription.filter(event as WorkflowEvent)) {\n          continue;\n        }\n\n        await subscription.handler(event as WorkflowEvent);\n      } catch (error) {\n        console.error(`[EventBus] Handler error for ${type}:`, error);\n      }\n    }\n\n    // Trigger workflows configured for this event\n    await this.triggerEventWorkflows(event as WorkflowEvent);\n  }\n\n  /**\n   * Emit event without waiting for handlers (fire-and-forget)\n   */\n  emitAsync<T = unknown>(\n    type: WorkflowEventType,\n    data: T,\n    metadata?: WorkflowEvent['metadata']\n  ): void {\n    this.emit(type, data, metadata).catch((error) => {\n      console.error(`[EventBus] Async emit error for ${type}:`, error);\n    });\n  }\n\n  /**\n   * Get recent events\n   */\n  getHistory(limit = 100): WorkflowEvent[] {\n    return this.eventHistory.slice(-limit);\n  }\n\n  /**\n   * Get subscriptions for debugging\n   */\n  getSubscriptions(): Map<string, EventSubscription[]> {\n    return new Map(this.subscriptions);\n  }\n\n  /**\n   * Clear all subscriptions (for testing)\n   */\n  clearSubscriptions(): void {\n    this.subscriptions.clear();\n  }\n\n  /**\n   * Trigger workflows configured for EVENT trigger type\n   */\n  private async triggerEventWorkflows(event: WorkflowEvent): Promise<void> {\n    try {\n      // Find enabled workflows with EVENT trigger that match this event type\n      const workflows = await prisma.workflow.findMany({\n        where: {\n          enabled: true,\n          triggerType: 'EVENT',\n        },\n      });\n\n      for (const workflow of workflows) {\n        const triggerConfig = workflow.triggerConfig as Record<string, unknown> | null;\n        if (!triggerConfig) continue;\n\n        const eventTypes = triggerConfig.eventTypes as string[] | undefined;\n        if (!eventTypes || !eventTypes.includes(event.type)) continue;\n\n        // Check event filter if present\n        const filter = triggerConfig.filter as Record<string, unknown> | undefined;\n        if (filter && !this.matchesFilter(event.data, filter)) continue;\n\n        // Queue workflow execution (import dynamically to avoid circular deps)\n        const { executeWorkflow } = await import('./engine');\n        executeWorkflow(workflow.id, {\n          triggeredBy: 'event',\n          eventData: event,\n        }).catch((error) => {\n          console.error(`[EventBus] Workflow execution error for ${workflow.id}:`, error);\n        });\n      }\n    } catch (error) {\n      console.error('[EventBus] Error triggering event workflows:', error);\n    }\n  }\n\n  /**\n   * Check if data matches a filter object\n   */\n  private matchesFilter(data: unknown, filter: Record<string, unknown>): boolean {\n    if (!data || typeof data !== 'object') return false;\n\n    const dataObj = data as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(filter)) {\n      const dataValue = this.getNestedValue(dataObj, key);\n\n      if (typeof value === 'object' && value !== null) {\n        // Handle operators like $eq, $gt, $in, etc.\n        const ops = value as Record<string, unknown>;\n        if ('$eq' in ops && dataValue !== ops.$eq) return false;\n        if ('$neq' in ops && dataValue === ops.$neq) return false;\n        if ('$gt' in ops && (typeof dataValue !== 'number' || dataValue <= (ops.$gt as number))) return false;\n        if ('$gte' in ops && (typeof dataValue !== 'number' || dataValue < (ops.$gte as number))) return false;\n        if ('$lt' in ops && (typeof dataValue !== 'number' || dataValue >= (ops.$lt as number))) return false;\n        if ('$lte' in ops && (typeof dataValue !== 'number' || dataValue > (ops.$lte as number))) return false;\n        if ('$in' in ops && !Array.isArray(ops.$in)) return false;\n        if ('$in' in ops && !(ops.$in as unknown[]).includes(dataValue)) return false;\n        if ('$contains' in ops && (typeof dataValue !== 'string' || !dataValue.includes(ops.$contains as string))) return false;\n        if ('$exists' in ops && (ops.$exists ? dataValue === undefined : dataValue !== undefined)) return false;\n      } else {\n        // Simple equality check\n        if (dataValue !== value) return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get nested value from object using dot notation\n   */\n  private getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n    return path.split('.').reduce((current: unknown, key) => {\n      if (current && typeof current === 'object') {\n        return (current as Record<string, unknown>)[key];\n      }\n      return undefined;\n    }, obj);\n  }\n}\n\n// =============================================================================\n// SINGLETON INSTANCE\n// =============================================================================\n\nexport const eventBus = new EventBus();\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Emit an event (convenience function)\n */\nexport function emit<T = unknown>(\n  type: WorkflowEventType,\n  data: T,\n  metadata?: WorkflowEvent['metadata']\n): Promise<void> {\n  return eventBus.emit(type, data, metadata);\n}\n\n/**\n * Emit an event without waiting (convenience function)\n */\nexport function emitAsync<T = unknown>(\n  type: WorkflowEventType,\n  data: T,\n  metadata?: WorkflowEvent['metadata']\n): void {\n  eventBus.emitAsync(type, data, metadata);\n}\n\n/**\n * Subscribe to events (convenience function)\n */\nexport function subscribe(subscription: Omit<EventSubscription, 'id'>): string {\n  return eventBus.subscribe(subscription);\n}\n\n/**\n * Unsubscribe from events (convenience function)\n */\nexport function unsubscribe(subscriptionId: string): boolean {\n  return eventBus.unsubscribe(subscriptionId);\n}\n\n// =============================================================================\n// PREDEFINED EVENT EMITTERS\n// =============================================================================\n\nexport const events = {\n  // Order events\n  order: {\n    created: (order: unknown) => emit('order.created', order),\n    paid: (order: unknown) => emit('order.paid', order),\n    shipped: (order: unknown, shipment?: unknown) => emit('order.shipped', { order, shipment }),\n    delivered: (order: unknown) => emit('order.delivered', order),\n    cancelled: (order: unknown, reason?: string) => emit('order.cancelled', { order, reason }),\n    refunded: (order: unknown, refund?: unknown) => emit('order.refunded', { order, refund }),\n  },\n\n  // User events\n  user: {\n    created: (user: unknown) => emit('user.created', user),\n    updated: (user: unknown, changes?: unknown) => emit('user.updated', { user, changes }),\n    deleted: (userId: string) => emit('user.deleted', { userId }),\n    subscribed: (user: unknown, list?: string) => emit('user.subscribed', { user, list }),\n    unsubscribed: (user: unknown, list?: string) => emit('user.unsubscribed', { user, list }),\n  },\n\n  // Product events\n  product: {\n    created: (product: unknown) => emit('product.created', product),\n    updated: (product: unknown, changes?: unknown) => emit('product.updated', { product, changes }),\n    deleted: (productId: string) => emit('product.deleted', { productId }),\n    lowStock: (product: unknown, threshold: number) => emit('product.low_stock', { product, threshold }),\n    outOfStock: (product: unknown) => emit('product.out_of_stock', product),\n  },\n\n  // Content events\n  content: {\n    pageCreated: (page: unknown) => emit('page.created', page),\n    pagePublished: (page: unknown) => emit('page.published', page),\n    pageUpdated: (page: unknown) => emit('page.updated', page),\n    blogCreated: (post: unknown) => emit('blog.created', post),\n    blogPublished: (post: unknown) => emit('blog.published', post),\n    blogUpdated: (post: unknown) => emit('blog.updated', post),\n  },\n\n  // Payment events\n  payment: {\n    succeeded: (payment: unknown) => emit('payment.succeeded', payment),\n    failed: (payment: unknown, error?: string) => emit('payment.failed', { payment, error }),\n    subscriptionCreated: (subscription: unknown) => emit('subscription.created', subscription),\n    subscriptionCancelled: (subscription: unknown) => emit('subscription.cancelled', subscription),\n  },\n\n  // Form events\n  form: {\n    submitted: (form: unknown, data: unknown) => emit('form.submitted', { form, data }),\n    contactCreated: (contact: unknown) => emit('contact.created', contact),\n  },\n\n  // Webhook events\n  webhook: {\n    received: (source: string, payload: unknown) => emit('webhook.received', { source, payload }),\n  },\n\n  // Custom events\n  custom: (eventType: string, data: unknown) => emit(eventType, data),\n};\n","/**\n * React Flow Integration\n *\n * Utilities for integrating workflows with React Flow visual editor.\n * Handles node/edge conversion, validation, and workflow serialization.\n */\n\n// React Flow types (defined locally to avoid hard dependency)\n// These match the reactflow package types for compatibility\nexport interface XYPosition {\n  x: number;\n  y: number;\n}\n\nexport interface Viewport {\n  x: number;\n  y: number;\n  zoom: number;\n}\n\nexport interface Node<T = unknown> {\n  id: string;\n  type?: string;\n  position: XYPosition;\n  data: T;\n  width?: number;\n  height?: number;\n  selected?: boolean;\n  dragging?: boolean;\n  hidden?: boolean;\n}\n\nexport interface Edge<T = unknown> {\n  id: string;\n  source: string;\n  target: string;\n  sourceHandle?: string | null;\n  targetHandle?: string | null;\n  type?: string;\n  animated?: boolean;\n  hidden?: boolean;\n  data?: T;\n  label?: string;\n  selected?: boolean;\n}\n\nimport type {\n  WorkflowTemplateNode,\n  WorkflowTemplateEdge,\n  WorkflowNodeType,\n  WorkflowNodeConfig,\n  WorkflowCondition,\n} from './types';\n\n// =============================================================================\n// NODE TYPES FOR REACT FLOW\n// =============================================================================\n\nexport interface WorkflowNodeData {\n  label: string;\n  nodeType: WorkflowNodeType;\n  primitiveId?: string;\n  primitiveName?: string;\n  primitiveIcon?: string;\n  config?: WorkflowNodeConfig;\n  // UI state\n  isExecuting?: boolean;\n  isCompleted?: boolean;\n  hasError?: boolean;\n  errorMessage?: string;\n  executionTime?: number;\n}\n\nexport interface WorkflowEdgeData {\n  condition?: WorkflowCondition;\n  label?: string;\n}\n\nexport type WorkflowReactFlowNode = Node<WorkflowNodeData>;\nexport type WorkflowReactFlowEdge = Edge<WorkflowEdgeData>;\n\n// =============================================================================\n// NODE DEFINITIONS\n// =============================================================================\n\nexport interface NodeTypeDefinition {\n  type: WorkflowNodeType;\n  label: string;\n  description: string;\n  icon: string;\n  color: string;\n  category: 'trigger' | 'action' | 'control' | 'output';\n  handles: {\n    inputs: number;\n    outputs: number;\n    conditionalOutputs?: string[];\n  };\n  defaultConfig?: WorkflowNodeConfig;\n}\n\nexport const nodeTypeDefinitions: Record<WorkflowNodeType, NodeTypeDefinition> = {\n  trigger: {\n    type: 'trigger',\n    label: 'Trigger',\n    description: 'Starting point of the workflow',\n    icon: 'Zap',\n    color: '#f59e0b',\n    category: 'trigger',\n    handles: { inputs: 0, outputs: 1 },\n  },\n  primitive: {\n    type: 'primitive',\n    label: 'Action',\n    description: 'Execute a primitive action',\n    icon: 'Play',\n    color: '#3b82f6',\n    category: 'action',\n    handles: { inputs: 1, outputs: 1 },\n  },\n  condition: {\n    type: 'condition',\n    label: 'Condition',\n    description: 'Branch based on conditions',\n    icon: 'GitBranch',\n    color: '#8b5cf6',\n    category: 'control',\n    handles: { inputs: 1, outputs: 2, conditionalOutputs: ['true', 'false'] },\n  },\n  loop: {\n    type: 'loop',\n    label: 'Loop',\n    description: 'Iterate over a collection',\n    icon: 'Repeat',\n    color: '#10b981',\n    category: 'control',\n    handles: { inputs: 1, outputs: 2, conditionalOutputs: ['body', 'complete'] },\n  },\n  delay: {\n    type: 'delay',\n    label: 'Delay',\n    description: 'Wait for a specified duration',\n    icon: 'Clock',\n    color: '#6b7280',\n    category: 'control',\n    handles: { inputs: 1, outputs: 1 },\n  },\n  parallel: {\n    type: 'parallel',\n    label: 'Parallel',\n    description: 'Execute multiple branches simultaneously',\n    icon: 'GitMerge',\n    color: '#ec4899',\n    category: 'control',\n    handles: { inputs: 1, outputs: 4 },\n  },\n  output: {\n    type: 'output',\n    label: 'Output',\n    description: 'Workflow output/result',\n    icon: 'Flag',\n    color: '#14b8a6',\n    category: 'output',\n    handles: { inputs: 1, outputs: 0 },\n  },\n};\n\n// =============================================================================\n// CONVERSION UTILITIES\n// =============================================================================\n\n/**\n * Convert workflow template nodes to React Flow nodes\n */\nexport function toReactFlowNodes(\n  templateNodes: WorkflowTemplateNode[]\n): WorkflowReactFlowNode[] {\n  return templateNodes.map((node) => ({\n    id: node.id,\n    type: getReactFlowNodeType(node.data.nodeType),\n    position: node.position,\n    data: {\n      label: node.data.label,\n      nodeType: node.data.nodeType,\n      primitiveId: node.data.primitiveId,\n      config: node.data.config,\n    },\n  }));\n}\n\n/**\n * Convert workflow template edges to React Flow edges\n */\nexport function toReactFlowEdges(\n  templateEdges: WorkflowTemplateEdge[]\n): WorkflowReactFlowEdge[] {\n  return templateEdges.map((edge) => ({\n    id: edge.id,\n    source: edge.source,\n    target: edge.target,\n    sourceHandle: edge.sourceHandle,\n    targetHandle: edge.targetHandle,\n    type: edge.data?.condition ? 'conditional' : 'default',\n    animated: false,\n    data: edge.data,\n  }));\n}\n\n/**\n * Convert React Flow nodes back to workflow template format\n */\nexport function fromReactFlowNodes(\n  nodes: WorkflowReactFlowNode[]\n): WorkflowTemplateNode[] {\n  return nodes.map((node) => ({\n    id: node.id,\n    type: node.data.nodeType,\n    position: node.position,\n    data: {\n      label: node.data.label,\n      nodeType: node.data.nodeType,\n      primitiveId: node.data.primitiveId,\n      config: node.data.config,\n    },\n  }));\n}\n\n/**\n * Convert React Flow edges back to workflow template format\n */\nexport function fromReactFlowEdges(\n  edges: WorkflowReactFlowEdge[]\n): WorkflowTemplateEdge[] {\n  return edges.map((edge) => ({\n    id: edge.id,\n    source: edge.source,\n    target: edge.target,\n    sourceHandle: edge.sourceHandle ?? undefined,\n    targetHandle: edge.targetHandle ?? undefined,\n    data: edge.data,\n  }));\n}\n\n/**\n * Get React Flow node type from workflow node type\n */\nfunction getReactFlowNodeType(nodeType: WorkflowNodeType): string {\n  // Map to custom node types if you have them registered\n  return `workflow-${nodeType}`;\n}\n\n// =============================================================================\n// WORKFLOW VALIDATION\n// =============================================================================\n\nexport interface WorkflowValidationResult {\n  valid: boolean;\n  errors: WorkflowValidationError[];\n  warnings: WorkflowValidationWarning[];\n}\n\nexport interface WorkflowValidationError {\n  type: 'error';\n  code: string;\n  message: string;\n  nodeId?: string;\n  edgeId?: string;\n}\n\nexport interface WorkflowValidationWarning {\n  type: 'warning';\n  code: string;\n  message: string;\n  nodeId?: string;\n}\n\n/**\n * Validate a workflow graph\n */\nexport function validateWorkflow(\n  nodes: WorkflowReactFlowNode[],\n  edges: WorkflowReactFlowEdge[]\n): WorkflowValidationResult {\n  const errors: WorkflowValidationError[] = [];\n  const warnings: WorkflowValidationWarning[] = [];\n\n  // Check for trigger node\n  const triggerNodes = nodes.filter((n) => n.data.nodeType === 'trigger');\n  if (triggerNodes.length === 0) {\n    errors.push({\n      type: 'error',\n      code: 'NO_TRIGGER',\n      message: 'Workflow must have at least one trigger node',\n    });\n  }\n  if (triggerNodes.length > 1) {\n    warnings.push({\n      type: 'warning',\n      code: 'MULTIPLE_TRIGGERS',\n      message: 'Workflow has multiple trigger nodes',\n    });\n  }\n\n  // Check for disconnected nodes\n  const connectedNodeIds = new Set<string>();\n  edges.forEach((edge) => {\n    connectedNodeIds.add(edge.source);\n    connectedNodeIds.add(edge.target);\n  });\n\n  nodes.forEach((node) => {\n    // Trigger nodes don't need incoming connections\n    if (node.data.nodeType === 'trigger') {\n      if (!edges.some((e) => e.source === node.id)) {\n        warnings.push({\n          type: 'warning',\n          code: 'DEAD_END_TRIGGER',\n          message: `Trigger node \"${node.data.label}\" has no outgoing connections`,\n          nodeId: node.id,\n        });\n      }\n      return;\n    }\n\n    // Other nodes should have incoming connections\n    if (!edges.some((e) => e.target === node.id)) {\n      errors.push({\n        type: 'error',\n        code: 'DISCONNECTED_NODE',\n        message: `Node \"${node.data.label}\" has no incoming connections`,\n        nodeId: node.id,\n      });\n    }\n  });\n\n  // Check primitive nodes have primitiveId\n  nodes\n    .filter((n) => n.data.nodeType === 'primitive')\n    .forEach((node) => {\n      if (!node.data.primitiveId) {\n        errors.push({\n          type: 'error',\n          code: 'MISSING_PRIMITIVE',\n          message: `Action node \"${node.data.label}\" has no primitive assigned`,\n          nodeId: node.id,\n        });\n      }\n    });\n\n  // Check condition nodes have conditions\n  nodes\n    .filter((n) => n.data.nodeType === 'condition')\n    .forEach((node) => {\n      if (!node.data.config?.condition) {\n        warnings.push({\n          type: 'warning',\n          code: 'MISSING_CONDITION',\n          message: `Condition node \"${node.data.label}\" has no condition configured`,\n          nodeId: node.id,\n        });\n      }\n    });\n\n  // Check for cycles (simplified - just check direct self-loops)\n  edges.forEach((edge) => {\n    if (edge.source === edge.target) {\n      errors.push({\n        type: 'error',\n        code: 'SELF_LOOP',\n        message: 'Edge creates a self-loop',\n        edgeId: edge.id,\n      });\n    }\n  });\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// =============================================================================\n// LAYOUT UTILITIES\n// =============================================================================\n\n/**\n * Auto-layout nodes in a hierarchical fashion\n */\nexport function autoLayoutNodes(\n  nodes: WorkflowReactFlowNode[],\n  edges: WorkflowReactFlowEdge[],\n  options?: {\n    direction?: 'TB' | 'LR';\n    nodeSpacingX?: number;\n    nodeSpacingY?: number;\n  }\n): WorkflowReactFlowNode[] {\n  const direction = options?.direction || 'TB';\n  const spacingX = options?.nodeSpacingX || 200;\n  const spacingY = options?.nodeSpacingY || 100;\n\n  // Build adjacency list\n  const children = new Map<string, string[]>();\n  const parents = new Map<string, string[]>();\n\n  nodes.forEach((node) => {\n    children.set(node.id, []);\n    parents.set(node.id, []);\n  });\n\n  edges.forEach((edge) => {\n    children.get(edge.source)?.push(edge.target);\n    parents.get(edge.target)?.push(edge.source);\n  });\n\n  // Find root nodes (no parents or trigger nodes)\n  const rootNodes = nodes.filter(\n    (n) =>\n      n.data.nodeType === 'trigger' || parents.get(n.id)?.length === 0\n  );\n\n  // Calculate levels using BFS\n  const levels = new Map<string, number>();\n  const queue: { id: string; level: number }[] = rootNodes.map((n) => ({\n    id: n.id,\n    level: 0,\n  }));\n\n  while (queue.length > 0) {\n    const { id, level } = queue.shift()!;\n\n    if (levels.has(id)) continue;\n    levels.set(id, level);\n\n    const nodeChildren = children.get(id) || [];\n    nodeChildren.forEach((childId) => {\n      queue.push({ id: childId, level: level + 1 });\n    });\n  }\n\n  // Group nodes by level\n  const levelGroups = new Map<number, string[]>();\n  levels.forEach((level, nodeId) => {\n    if (!levelGroups.has(level)) {\n      levelGroups.set(level, []);\n    }\n    levelGroups.get(level)!.push(nodeId);\n  });\n\n  // Position nodes\n  const nodeMap = new Map(nodes.map((n) => [n.id, n]));\n\n  return nodes.map((node) => {\n    const level = levels.get(node.id) || 0;\n    const nodesAtLevel = levelGroups.get(level) || [];\n    const indexAtLevel = nodesAtLevel.indexOf(node.id);\n\n    const totalWidth = (nodesAtLevel.length - 1) * spacingX;\n    const startX = -totalWidth / 2;\n\n    let position: XYPosition;\n    if (direction === 'TB') {\n      position = {\n        x: startX + indexAtLevel * spacingX,\n        y: level * spacingY,\n      };\n    } else {\n      position = {\n        x: level * spacingX,\n        y: startX + indexAtLevel * spacingY,\n      };\n    }\n\n    return {\n      ...node,\n      position,\n    };\n  });\n}\n\n// =============================================================================\n// NODE CREATION HELPERS\n// =============================================================================\n\nlet nodeIdCounter = 0;\n\n/**\n * Generate a unique node ID\n */\nexport function generateNodeId(): string {\n  return `node_${Date.now()}_${++nodeIdCounter}`;\n}\n\n/**\n * Generate a unique edge ID\n */\nexport function generateEdgeId(source: string, target: string): string {\n  return `edge_${source}_${target}_${++nodeIdCounter}`;\n}\n\n/**\n * Create a new trigger node\n */\nexport function createTriggerNode(\n  position: XYPosition,\n  triggerType: 'manual' | 'schedule' | 'webhook' | 'event'\n): WorkflowReactFlowNode {\n  return {\n    id: generateNodeId(),\n    type: 'workflow-trigger',\n    position,\n    data: {\n      label: `${triggerType.charAt(0).toUpperCase() + triggerType.slice(1)} Trigger`,\n      nodeType: 'trigger',\n      config: {},\n    },\n  };\n}\n\n/**\n * Create a new primitive/action node\n */\nexport function createPrimitiveNode(\n  position: XYPosition,\n  primitiveId: string,\n  primitiveName: string,\n  primitiveIcon?: string\n): WorkflowReactFlowNode {\n  return {\n    id: generateNodeId(),\n    type: 'workflow-primitive',\n    position,\n    data: {\n      label: primitiveName,\n      nodeType: 'primitive',\n      primitiveId,\n      primitiveName,\n      primitiveIcon,\n      config: {\n        inputMapping: {},\n      },\n    },\n  };\n}\n\n/**\n * Create a new condition node\n */\nexport function createConditionNode(\n  position: XYPosition,\n  label = 'Condition'\n): WorkflowReactFlowNode {\n  return {\n    id: generateNodeId(),\n    type: 'workflow-condition',\n    position,\n    data: {\n      label,\n      nodeType: 'condition',\n      config: {\n        condition: {\n          type: 'simple',\n          field: '',\n          operator: 'eq',\n          value: '',\n        },\n      },\n    },\n  };\n}\n\n/**\n * Create a new output node\n */\nexport function createOutputNode(\n  position: XYPosition,\n  label = 'Output'\n): WorkflowReactFlowNode {\n  return {\n    id: generateNodeId(),\n    type: 'workflow-output',\n    position,\n    data: {\n      label,\n      nodeType: 'output',\n      config: {\n        inputMapping: {},\n      },\n    },\n  };\n}\n\n// =============================================================================\n// SERIALIZATION\n// =============================================================================\n\nexport interface WorkflowGraphData {\n  nodes: WorkflowTemplateNode[];\n  edges: WorkflowTemplateEdge[];\n  viewport?: Viewport;\n}\n\n/**\n * Serialize workflow for storage\n */\nexport function serializeWorkflow(\n  nodes: WorkflowReactFlowNode[],\n  edges: WorkflowReactFlowEdge[],\n  viewport?: Viewport\n): WorkflowGraphData {\n  return {\n    nodes: fromReactFlowNodes(nodes),\n    edges: fromReactFlowEdges(edges),\n    viewport,\n  };\n}\n\n/**\n * Deserialize workflow for React Flow\n */\nexport function deserializeWorkflow(data: WorkflowGraphData): {\n  nodes: WorkflowReactFlowNode[];\n  edges: WorkflowReactFlowEdge[];\n  viewport?: Viewport;\n} {\n  return {\n    nodes: toReactFlowNodes(data.nodes),\n    edges: toReactFlowEdges(data.edges),\n    viewport: data.viewport,\n  };\n}\n","/**\n * Built-in Workflow Actions\n *\n * Pre-built actions that can be used in workflows without creating primitives.\n * These handle common operations like HTTP requests, data transformation,\n * notifications, and integrations.\n */\n\nimport type { ActionDefinition, WorkflowContext } from '../types';\n\n// =============================================================================\n// ACTION REGISTRY\n// =============================================================================\n\nconst actionRegistry = new Map<string, ActionDefinition>();\n\n/**\n * Register an action\n */\nexport function registerAction(action: ActionDefinition): void {\n  actionRegistry.set(action.name, action);\n}\n\n/**\n * Get an action by name\n */\nexport function getAction(name: string): ActionDefinition | undefined {\n  return actionRegistry.get(name);\n}\n\n/**\n * Get all registered actions\n */\nexport function getAllActions(): ActionDefinition[] {\n  return Array.from(actionRegistry.values());\n}\n\n/**\n * Get actions by category\n */\nexport function getActionsByCategory(category: string): ActionDefinition[] {\n  return getAllActions().filter((a) => a.category === category);\n}\n\n/**\n * Execute a built-in action\n */\nexport async function executeAction(\n  name: string,\n  input: Record<string, unknown>,\n  context: WorkflowContext\n): Promise<unknown> {\n  const action = getAction(name);\n  if (!action) {\n    throw new Error(`Action not found: ${name}`);\n  }\n\n  return action.handler(input, context);\n}\n\n// =============================================================================\n// HTTP ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'http.request',\n  description: 'Make an HTTP request',\n  category: 'http',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      url: { type: 'string', description: 'Request URL' },\n      method: { type: 'string', enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'] },\n      headers: { type: 'object', description: 'Request headers' },\n      body: { description: 'Request body' },\n      timeout: { type: 'number', description: 'Timeout in ms' },\n    },\n    required: ['url'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { url, method = 'GET', headers = {}, body, timeout = 30000 } = input;\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout as number);\n\n    try {\n      const response = await fetch(url as string, {\n        method: method as string,\n        headers: headers as HeadersInit,\n        body: body ? JSON.stringify(body) : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      const contentType = response.headers.get('content-type');\n      let data: unknown;\n\n      if (contentType?.includes('application/json')) {\n        data = await response.json();\n      } else {\n        data = await response.text();\n      }\n\n      return {\n        status: response.status,\n        statusText: response.statusText,\n        headers: Object.fromEntries(response.headers.entries()),\n        data,\n        ok: response.ok,\n      };\n    } catch (error) {\n      clearTimeout(timeoutId);\n      throw error;\n    }\n  },\n});\n\nregisterAction({\n  name: 'http.webhook',\n  description: 'Send a webhook notification',\n  category: 'http',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      url: { type: 'string', description: 'Webhook URL' },\n      payload: { type: 'object', description: 'Webhook payload' },\n      secret: { type: 'string', description: 'Webhook secret for signing' },\n    },\n    required: ['url', 'payload'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { url, payload, secret } = input;\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n\n    // Add signature if secret provided\n    if (secret) {\n      const crypto = await import('crypto');\n      const signature = crypto\n        .createHmac('sha256', secret as string)\n        .update(JSON.stringify(payload))\n        .digest('hex');\n      headers['X-Webhook-Signature'] = signature;\n    }\n\n    const response = await fetch(url as string, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(payload),\n    });\n\n    return {\n      status: response.status,\n      success: response.ok,\n    };\n  },\n});\n\n// =============================================================================\n// DATA TRANSFORMATION ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'data.transform',\n  description: 'Transform data using a mapping',\n  category: 'data',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      input: { description: 'Input data to transform' },\n      mapping: { type: 'object', description: 'Field mapping' },\n    },\n    required: ['input', 'mapping'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { input: data, mapping } = input;\n\n    if (!data || typeof data !== 'object') {\n      return data;\n    }\n\n    const dataObj = data as Record<string, unknown>;\n    const result: Record<string, unknown> = {};\n\n    for (const [targetKey, sourceKey] of Object.entries(mapping as Record<string, string>)) {\n      const value = sourceKey.split('.').reduce((obj: unknown, key) => {\n        if (obj && typeof obj === 'object') {\n          return (obj as Record<string, unknown>)[key];\n        }\n        return undefined;\n      }, dataObj);\n\n      result[targetKey] = value;\n    }\n\n    return result;\n  },\n});\n\nregisterAction({\n  name: 'data.filter',\n  description: 'Filter array data',\n  category: 'data',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      array: { type: 'array', description: 'Array to filter' },\n      field: { type: 'string', description: 'Field to check' },\n      operator: { type: 'string', enum: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'contains'] },\n      value: { description: 'Value to compare' },\n    },\n    required: ['array', 'field', 'operator', 'value'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { array, field, operator, value } = input;\n\n    if (!Array.isArray(array)) {\n      return [];\n    }\n\n    return array.filter((item) => {\n      const fieldValue = (item as Record<string, unknown>)[field as string];\n\n      switch (operator) {\n        case 'eq':\n          return fieldValue === value;\n        case 'neq':\n          return fieldValue !== value;\n        case 'gt':\n          return typeof fieldValue === 'number' && fieldValue > (value as number);\n        case 'gte':\n          return typeof fieldValue === 'number' && fieldValue >= (value as number);\n        case 'lt':\n          return typeof fieldValue === 'number' && fieldValue < (value as number);\n        case 'lte':\n          return typeof fieldValue === 'number' && fieldValue <= (value as number);\n        case 'contains':\n          return typeof fieldValue === 'string' && fieldValue.includes(value as string);\n        default:\n          return true;\n      }\n    });\n  },\n});\n\nregisterAction({\n  name: 'data.map',\n  description: 'Map array data to new structure',\n  category: 'data',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      array: { type: 'array', description: 'Array to map' },\n      mapping: { type: 'object', description: 'Field mapping for each item' },\n    },\n    required: ['array', 'mapping'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { array, mapping } = input;\n\n    if (!Array.isArray(array)) {\n      return [];\n    }\n\n    return array.map((item) => {\n      const result: Record<string, unknown> = {};\n      const itemObj = item as Record<string, unknown>;\n\n      for (const [targetKey, sourceKey] of Object.entries(mapping as Record<string, string>)) {\n        result[targetKey] = itemObj[sourceKey];\n      }\n\n      return result;\n    });\n  },\n});\n\nregisterAction({\n  name: 'data.aggregate',\n  description: 'Aggregate array data',\n  category: 'data',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      array: { type: 'array', description: 'Array to aggregate' },\n      operation: { type: 'string', enum: ['sum', 'avg', 'min', 'max', 'count'] },\n      field: { type: 'string', description: 'Field to aggregate (for sum, avg, min, max)' },\n    },\n    required: ['array', 'operation'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { array, operation, field } = input;\n\n    if (!Array.isArray(array)) {\n      return null;\n    }\n\n    const values = field\n      ? array.map((item) => (item as Record<string, unknown>)[field as string]).filter((v): v is number => typeof v === 'number')\n      : array.filter((v): v is number => typeof v === 'number');\n\n    switch (operation) {\n      case 'sum':\n        return values.reduce((a, b) => a + b, 0);\n      case 'avg':\n        return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;\n      case 'min':\n        return values.length > 0 ? Math.min(...values) : null;\n      case 'max':\n        return values.length > 0 ? Math.max(...values) : null;\n      case 'count':\n        return array.length;\n      default:\n        return null;\n    }\n  },\n});\n\n// =============================================================================\n// LOGIC ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'logic.switch',\n  description: 'Switch/case logic',\n  category: 'logic',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      value: { description: 'Value to switch on' },\n      cases: { type: 'object', description: 'Case mappings (value -> result)' },\n      default: { description: 'Default result if no case matches' },\n    },\n    required: ['value', 'cases'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { value, cases, default: defaultValue } = input;\n    const casesObj = cases as Record<string, unknown>;\n\n    const key = String(value);\n    if (key in casesObj) {\n      return casesObj[key];\n    }\n\n    return defaultValue;\n  },\n});\n\nregisterAction({\n  name: 'logic.coalesce',\n  description: 'Return first non-null value',\n  category: 'logic',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      values: { type: 'array', description: 'Array of values to check' },\n    },\n    required: ['values'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { values } = input;\n\n    if (!Array.isArray(values)) {\n      return null;\n    }\n\n    return values.find((v) => v !== null && v !== undefined) ?? null;\n  },\n});\n\n// =============================================================================\n// STRING ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'string.template',\n  description: 'Render a string template',\n  category: 'string',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      template: { type: 'string', description: 'Template string with {{placeholders}}' },\n      data: { type: 'object', description: 'Data for placeholders' },\n    },\n    required: ['template', 'data'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { template, data } = input;\n    const dataObj = data as Record<string, unknown>;\n\n    return (template as string).replace(/\\{\\{([^}]+)\\}\\}/g, (_, key) => {\n      const value = dataObj[key.trim()];\n      return value !== undefined && value !== null ? String(value) : '';\n    });\n  },\n});\n\nregisterAction({\n  name: 'string.format',\n  description: 'Format values (number, date, currency)',\n  category: 'string',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      value: { description: 'Value to format' },\n      type: { type: 'string', enum: ['number', 'date', 'currency', 'percent'] },\n      locale: { type: 'string', description: 'Locale for formatting' },\n      options: { type: 'object', description: 'Format options' },\n    },\n    required: ['value', 'type'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { value, type, locale = 'en-US', options = {} } = input;\n\n    switch (type) {\n      case 'number':\n        return new Intl.NumberFormat(locale as string, options as Intl.NumberFormatOptions).format(value as number);\n      case 'date':\n        return new Intl.DateTimeFormat(locale as string, options as Intl.DateTimeFormatOptions).format(new Date(value as string));\n      case 'currency':\n        return new Intl.NumberFormat(locale as string, {\n          style: 'currency',\n          currency: 'USD',\n          ...(options as Intl.NumberFormatOptions),\n        }).format(value as number);\n      case 'percent':\n        return new Intl.NumberFormat(locale as string, {\n          style: 'percent',\n          ...(options as Intl.NumberFormatOptions),\n        }).format(value as number);\n      default:\n        return String(value);\n    }\n  },\n});\n\n// =============================================================================\n// VARIABLE ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'variable.set',\n  description: 'Set a workflow variable',\n  category: 'variable',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      name: { type: 'string', description: 'Variable name' },\n      value: { description: 'Variable value' },\n    },\n    required: ['name', 'value'],\n  },\n  handler: async (input: Record<string, unknown>, context: WorkflowContext) => {\n    const { name, value } = input;\n    context.variables[name as string] = value;\n    return value;\n  },\n});\n\nregisterAction({\n  name: 'variable.get',\n  description: 'Get a workflow variable',\n  category: 'variable',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      name: { type: 'string', description: 'Variable name' },\n      default: { description: 'Default value if not found' },\n    },\n    required: ['name'],\n  },\n  handler: async (input: Record<string, unknown>, context: WorkflowContext) => {\n    const { name, default: defaultValue } = input;\n    return context.variables[name as string] ?? defaultValue;\n  },\n});\n\n// =============================================================================\n// UTILITY ACTIONS\n// =============================================================================\n\nregisterAction({\n  name: 'util.log',\n  description: 'Log a message (for debugging)',\n  category: 'utility',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      message: { type: 'string', description: 'Log message' },\n      data: { description: 'Additional data to log' },\n      level: { type: 'string', enum: ['info', 'warn', 'error', 'debug'] },\n    },\n    required: ['message'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { message, data, level = 'info' } = input;\n\n    const logFn = console[level as 'info' | 'warn' | 'error' | 'debug'] || console.log;\n    logFn(`[Workflow] ${message}`, data || '');\n\n    return { logged: true, message, level };\n  },\n});\n\nregisterAction({\n  name: 'util.wait',\n  description: 'Wait for a specified duration',\n  category: 'utility',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      duration: { type: 'number', description: 'Duration in milliseconds' },\n    },\n    required: ['duration'],\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { duration } = input;\n    await new Promise((resolve) => setTimeout(resolve, duration as number));\n    return { waited: duration };\n  },\n});\n\nregisterAction({\n  name: 'util.timestamp',\n  description: 'Get current timestamp',\n  category: 'utility',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      format: { type: 'string', enum: ['iso', 'unix', 'date'] },\n    },\n  },\n  handler: async (input: Record<string, unknown>) => {\n    const { format = 'iso' } = input;\n    const now = new Date();\n\n    switch (format) {\n      case 'unix':\n        return Math.floor(now.getTime() / 1000);\n      case 'date':\n        return now.toDateString();\n      default:\n        return now.toISOString();\n    }\n  },\n});\n\nregisterAction({\n  name: 'util.uuid',\n  description: 'Generate a UUID',\n  category: 'utility',\n  inputSchema: {\n    type: 'object',\n    properties: {},\n  },\n  handler: async () => {\n    const { v4: uuidv4 } = await import('uuid');\n    return uuidv4();\n  },\n});\n\n// =============================================================================\n// EXPORT ACTION CATEGORIES\n// =============================================================================\n\nexport const actionCategories = [\n  { id: 'http', label: 'HTTP', icon: 'Globe' },\n  { id: 'data', label: 'Data', icon: 'Database' },\n  { id: 'logic', label: 'Logic', icon: 'GitBranch' },\n  { id: 'string', label: 'String', icon: 'Type' },\n  { id: 'variable', label: 'Variables', icon: 'Variable' },\n  { id: 'utility', label: 'Utility', icon: 'Wrench' },\n];\n","/**\n * Workflow Template Service\n *\n * Manages pre-built workflow templates that can be installed and customized.\n * Provides one-click installation of common e-commerce automation patterns.\n */\n\nimport { prisma } from '../../db'\nimport type {\n  WorkflowTemplate as PrismaWorkflowTemplate,\n  WorkflowTemplateCategory,\n  Workflow,\n  WorkflowTrigger,\n  WorkflowStep\n} from '@prisma/client'\nimport { generateNodeId, generateEdgeId, autoLayoutNodes } from '../react-flow'\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface WorkflowTemplateWithDetails extends PrismaWorkflowTemplate {\n  workflowCount?: number\n}\n\nexport interface TemplateStepDefinition {\n  name: string\n  type: string\n  order: number\n  config?: Record<string, unknown>\n  conditions?: Record<string, unknown>\n}\n\nexport interface InstallTemplateOptions {\n  /** Custom name for the workflow (defaults to template name) */\n  name?: string\n  /** Enable the workflow immediately after install */\n  enabled?: boolean\n  /** Custom configuration overrides */\n  configOverrides?: Record<string, unknown>\n  /** Link to a plugin */\n  pluginId?: string\n}\n\nexport interface InstallResult {\n  success: boolean\n  workflow?: Workflow\n  steps?: WorkflowStep[]\n  error?: string\n}\n\n// =============================================================================\n// TEMPLATE QUERIES\n// =============================================================================\n\n/**\n * Get all available workflow templates\n */\nexport async function getWorkflowTemplates(options?: {\n  category?: WorkflowTemplateCategory\n  search?: string\n  onlyActive?: boolean\n  includeWorkflowCount?: boolean\n}): Promise<WorkflowTemplateWithDetails[]> {\n  const {\n    category,\n    search,\n    onlyActive = true,\n    includeWorkflowCount = false\n  } = options ?? {}\n\n  const templates = await prisma.workflowTemplate.findMany({\n    where: {\n      ...(onlyActive && { isActive: true }),\n      ...(category && { category }),\n      ...(search && {\n        OR: [\n          { name: { contains: search, mode: 'insensitive' } },\n          { description: { contains: search, mode: 'insensitive' } },\n          { tags: { has: search.toLowerCase() } }\n        ]\n      })\n    },\n    orderBy: [\n      { category: 'asc' },\n      { name: 'asc' }\n    ]\n  })\n\n  if (includeWorkflowCount) {\n    const templateIds = templates.map(t => t.id)\n    const workflowCounts = await prisma.workflow.groupBy({\n      by: ['templateId'],\n      where: { templateId: { in: templateIds } },\n      _count: true\n    })\n\n    const countMap = new Map(workflowCounts.map(wc => [wc.templateId, wc._count]))\n\n    return templates.map(template => ({\n      ...template,\n      workflowCount: countMap.get(template.id) ?? 0\n    }))\n  }\n\n  return templates\n}\n\n/**\n * Get a single workflow template by ID or slug\n */\nexport async function getWorkflowTemplate(\n  idOrSlug: string\n): Promise<WorkflowTemplateWithDetails | null> {\n  const template = await prisma.workflowTemplate.findFirst({\n    where: {\n      OR: [\n        { id: idOrSlug },\n        { slug: idOrSlug }\n      ]\n    }\n  })\n\n  if (!template) return null\n\n  const workflowCount = await prisma.workflow.count({\n    where: { templateId: template.id }\n  })\n\n  return {\n    ...template,\n    workflowCount\n  }\n}\n\n/**\n * Get templates by category with counts\n */\nexport async function getTemplatesByCategory(): Promise<\n  Record<WorkflowTemplateCategory, WorkflowTemplateWithDetails[]>\n> {\n  const templates = await getWorkflowTemplates({\n    includeWorkflowCount: true\n  })\n\n  const byCategory = templates.reduce((acc, template) => {\n    if (!acc[template.category]) {\n      acc[template.category] = []\n    }\n    acc[template.category].push(template)\n    return acc\n  }, {} as Record<WorkflowTemplateCategory, WorkflowTemplateWithDetails[]>)\n\n  return byCategory\n}\n\n/**\n * Get popular templates (most installed)\n */\nexport async function getPopularTemplates(limit = 5): Promise<WorkflowTemplateWithDetails[]> {\n  const templates = await getWorkflowTemplates({\n    includeWorkflowCount: true\n  })\n\n  return templates\n    .sort((a, b) => (b.workflowCount ?? 0) - (a.workflowCount ?? 0))\n    .slice(0, limit)\n}\n\n/**\n * Get recommended templates based on what's not yet installed\n */\nexport async function getRecommendedTemplates(limit = 4): Promise<WorkflowTemplateWithDetails[]> {\n  // Get all installed template IDs\n  const installedTemplates = await prisma.workflow.findMany({\n    where: { templateId: { not: null } },\n    select: { templateId: true },\n    distinct: ['templateId']\n  })\n\n  const installedIds = installedTemplates\n    .map(w => w.templateId)\n    .filter((id): id is string => id !== null)\n\n  // Get templates that aren't installed yet\n  const templates = await prisma.workflowTemplate.findMany({\n    where: {\n      isActive: true,\n      id: { notIn: installedIds },\n      tags: { has: 'essential' }\n    },\n    orderBy: { name: 'asc' },\n    take: limit\n  })\n\n  return templates\n}\n\n// =============================================================================\n// TEMPLATE INSTALLATION\n// =============================================================================\n\n/**\n * Install a workflow template as a new workflow\n */\nexport async function installWorkflowTemplate(\n  templateIdOrSlug: string,\n  options?: InstallTemplateOptions\n): Promise<InstallResult> {\n  try {\n    // Fetch the template\n    const template = await getWorkflowTemplate(templateIdOrSlug)\n\n    if (!template) {\n      return {\n        success: false,\n        error: `Template not found: ${templateIdOrSlug}`\n      }\n    }\n\n    // Generate unique slug\n    const baseSlug = `${template.slug}-copy`\n    let slug = baseSlug\n    let counter = 1\n\n    while (await prisma.workflow.findUnique({ where: { slug } })) {\n      slug = `${baseSlug}-${counter++}`\n    }\n\n    // Parse step definitions from template\n    const stepDefs = template.steps as unknown as TemplateStepDefinition[]\n\n    // Convert step definitions to React Flow nodes/edges\n    const { nodes, edges } = convertStepsToReactFlow(stepDefs, options?.configOverrides)\n\n    // Create the workflow\n    const workflow = await prisma.workflow.create({\n      data: {\n        name: options?.name ?? template.name,\n        slug,\n        description: template.description,\n        nodes,\n        edges,\n        viewport: { x: 0, y: 0, zoom: 1 },\n        triggerType: template.trigger,\n        triggerConfig: (template.triggerConfig as object ?? {}) as never,\n        config: (options?.configOverrides ?? {}) as never,\n        enabled: options?.enabled ?? false,\n        templateId: template.id,\n        pluginId: options?.pluginId\n      }\n    })\n\n    // Create workflow steps for easier querying\n    const steps = await Promise.all(\n      stepDefs.map((step, index) =>\n        prisma.workflowStep.create({\n          data: {\n            workflowId: workflow.id,\n            name: step.name,\n            type: step.type as any,\n            order: step.order ?? index,\n            config: (step.config ?? {}) as never,\n            conditions: (step.conditions ?? {}) as never,\n            enabled: true\n          }\n        })\n      )\n    )\n\n    return {\n      success: true,\n      workflow,\n      steps\n    }\n  } catch (error) {\n    console.error('Failed to install workflow template:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n\n/**\n * Convert template step definitions to React Flow format\n */\nfunction convertStepsToReactFlow(\n  steps: TemplateStepDefinition[],\n  configOverrides?: Record<string, unknown>\n): { nodes: object[]; edges: object[] } {\n  const nodes: object[] = []\n  const edges: object[] = []\n\n  // Sort steps by order\n  const sortedSteps = [...steps].sort((a, b) => a.order - b.order)\n\n  // Create nodes for each step\n  sortedSteps.forEach((step, index) => {\n    const nodeId = generateNodeId()\n\n    // Map step type to React Flow node type\n    const nodeType = mapStepTypeToNodeType(step.type)\n\n    nodes.push({\n      id: nodeId,\n      type: nodeType,\n      position: { x: 250, y: index * 150 },\n      data: {\n        label: step.name,\n        stepType: step.type,\n        config: {\n          ...step.config,\n          ...getConfigOverridesForStep(step.name, configOverrides)\n        },\n        conditions: step.conditions\n      }\n    })\n\n    // Create edge to next step (if not the last step)\n    if (index < sortedSteps.length - 1) {\n      edges.push({\n        id: generateEdgeId(nodeId, 'placeholder'),\n        source: nodeId,\n        target: '', // Will be filled in after all nodes are created\n        sourceHandle: 'output',\n        targetHandle: 'input'\n      })\n    }\n  })\n\n  // Fix edge targets now that we have all node IDs\n  edges.forEach((edge: any, index) => {\n    if (index < nodes.length - 1) {\n      edge.target = (nodes[index + 1] as any).id\n    }\n  })\n\n  // Auto-layout the nodes for better visualization\n  const layoutedNodes = autoLayoutNodes(nodes as any, edges as any)\n\n  return {\n    nodes: layoutedNodes,\n    edges\n  }\n}\n\n/**\n * Map workflow step type to React Flow node type\n */\nfunction mapStepTypeToNodeType(stepType: string): string {\n  const typeMap: Record<string, string> = {\n    TRIGGER: 'trigger',\n    ACTION: 'primitive',\n    CONDITION: 'condition',\n    DELAY: 'delay',\n    LOOP: 'loop',\n    TRANSFORM: 'transform',\n    HTTP: 'http',\n    DATABASE: 'database',\n    NOTIFICATION: 'notification',\n    END: 'output'\n  }\n\n  return typeMap[stepType] ?? 'primitive'\n}\n\n/**\n * Get config overrides for a specific step\n */\nfunction getConfigOverridesForStep(\n  stepName: string,\n  overrides?: Record<string, unknown>\n): Record<string, unknown> {\n  if (!overrides) return {}\n\n  // Check for step-specific overrides\n  const stepKey = stepName.toLowerCase().replace(/\\s+/g, '_')\n  return (overrides[stepKey] as Record<string, unknown>) ?? {}\n}\n\n// =============================================================================\n// TEMPLATE MANAGEMENT\n// =============================================================================\n\n/**\n * Create a new custom template from an existing workflow\n */\nexport async function createTemplateFromWorkflow(\n  workflowId: string,\n  templateData: {\n    name: string\n    slug: string\n    description?: string\n    category: WorkflowTemplateCategory\n    icon?: string\n    color?: string\n    tags?: string[]\n    documentation?: string\n    exampleUseCase?: string\n  }\n): Promise<PrismaWorkflowTemplate> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId },\n    include: { steps: { orderBy: { order: 'asc' } } }\n  })\n\n  if (!workflow) {\n    throw new Error(`Workflow not found: ${workflowId}`)\n  }\n\n  // Convert workflow steps to template step format\n  const steps: TemplateStepDefinition[] = workflow.steps.map(step => ({\n    name: step.name,\n    type: step.type,\n    order: step.order,\n    config: step.config as Record<string, unknown> ?? {},\n    conditions: step.conditions as Record<string, unknown> ?? {}\n  }))\n\n  return prisma.workflowTemplate.create({\n    data: {\n      name: templateData.name,\n      slug: templateData.slug,\n      description: templateData.description ?? workflow.description,\n      category: templateData.category,\n      trigger: workflow.triggerType,\n      triggerConfig: (workflow.triggerConfig ?? {}) as never,\n      steps: steps as never,\n      icon: templateData.icon,\n      color: templateData.color,\n      tags: templateData.tags ?? [],\n      documentation: templateData.documentation,\n      exampleUseCase: templateData.exampleUseCase,\n      isSystem: false,\n      isActive: true\n    }\n  })\n}\n\n/**\n * Update a custom template (system templates cannot be modified)\n */\nexport async function updateTemplate(\n  templateId: string,\n  data: Partial<{\n    name: string\n    description: string\n    category: WorkflowTemplateCategory\n    icon: string\n    color: string\n    tags: string[]\n    documentation: string\n    exampleUseCase: string\n    isActive: boolean\n  }>\n): Promise<PrismaWorkflowTemplate> {\n  const template = await prisma.workflowTemplate.findUnique({\n    where: { id: templateId }\n  })\n\n  if (!template) {\n    throw new Error(`Template not found: ${templateId}`)\n  }\n\n  if (template.isSystem) {\n    throw new Error('System templates cannot be modified')\n  }\n\n  return prisma.workflowTemplate.update({\n    where: { id: templateId },\n    data\n  })\n}\n\n/**\n * Delete a custom template\n */\nexport async function deleteTemplate(templateId: string): Promise<void> {\n  const template = await prisma.workflowTemplate.findUnique({\n    where: { id: templateId }\n  })\n\n  if (!template) {\n    throw new Error(`Template not found: ${templateId}`)\n  }\n\n  if (template.isSystem) {\n    throw new Error('System templates cannot be deleted')\n  }\n\n  // Remove templateId from any workflows using this template\n  await prisma.workflow.updateMany({\n    where: { templateId },\n    data: { templateId: null }\n  })\n\n  await prisma.workflowTemplate.delete({\n    where: { id: templateId }\n  })\n}\n\n// =============================================================================\n// TEMPLATE STATISTICS\n// =============================================================================\n\n/**\n * Get template usage statistics\n */\nexport async function getTemplateStats(templateId: string): Promise<{\n  totalInstalls: number\n  activeInstalls: number\n  totalExecutions: number\n  successfulExecutions: number\n  failedExecutions: number\n  averageExecutionTime: number\n}> {\n  const workflows = await prisma.workflow.findMany({\n    where: { templateId },\n    select: {\n      id: true,\n      enabled: true,\n      executionCount: true,\n      successCount: true,\n      failureCount: true\n    }\n  })\n\n  const workflowIds = workflows.map(w => w.id)\n\n  // Calculate average execution time from recent executions\n  const recentExecutions = await prisma.workflowExecution.findMany({\n    where: {\n      workflowId: { in: workflowIds },\n      status: 'COMPLETED',\n      completedAt: { not: null }\n    },\n    select: {\n      startedAt: true,\n      completedAt: true\n    },\n    orderBy: { startedAt: 'desc' },\n    take: 100\n  })\n\n  const executionTimes = recentExecutions\n    .filter(e => e.completedAt)\n    .map(e => e.completedAt!.getTime() - e.startedAt.getTime())\n\n  const avgTime = executionTimes.length > 0\n    ? executionTimes.reduce((a, b) => a + b, 0) / executionTimes.length\n    : 0\n\n  return {\n    totalInstalls: workflows.length,\n    activeInstalls: workflows.filter(w => w.enabled).length,\n    totalExecutions: workflows.reduce((sum, w) => sum + w.executionCount, 0),\n    successfulExecutions: workflows.reduce((sum, w) => sum + w.successCount, 0),\n    failedExecutions: workflows.reduce((sum, w) => sum + w.failureCount, 0),\n    averageExecutionTime: Math.round(avgTime)\n  }\n}\n\n/**\n * Get category statistics\n */\nexport async function getCategoryStats(): Promise<\n  Record<WorkflowTemplateCategory, {\n    templateCount: number\n    workflowCount: number\n  }>\n> {\n  const templates = await prisma.workflowTemplate.groupBy({\n    by: ['category'],\n    _count: true\n  })\n\n  const workflows = await prisma.workflow.findMany({\n    where: { templateId: { not: null } },\n    select: { template: { select: { category: true } } }\n  })\n\n  const stats: Record<string, { templateCount: number; workflowCount: number }> = {}\n\n  templates.forEach(t => {\n    stats[t.category] = {\n      templateCount: t._count,\n      workflowCount: 0\n    }\n  })\n\n  workflows.forEach(w => {\n    if (w.template?.category && stats[w.template.category]) {\n      stats[w.template.category].workflowCount++\n    }\n  })\n\n  return stats as Record<WorkflowTemplateCategory, { templateCount: number; workflowCount: number }>\n}\n","/**\n * Workflow Toggle Service\n *\n * Manages workflow enabled/disabled states with validation,\n * event subscription management, and execution tracking.\n */\n\nimport { prisma } from '../db'\nimport type { Workflow, WorkflowTrigger } from '@prisma/client'\nimport { eventBus, subscribe, unsubscribe } from './event-bus'\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface ToggleResult {\n  success: boolean\n  workflow?: Workflow\n  error?: string\n  message?: string\n}\n\nexport interface BulkToggleResult {\n  success: boolean\n  results: Array<{\n    workflowId: string\n    success: boolean\n    enabled?: boolean\n    error?: string\n  }>\n  enabledCount: number\n  disabledCount: number\n  errorCount: number\n}\n\nexport interface WorkflowStatus {\n  id: string\n  name: string\n  slug: string\n  enabled: boolean\n  triggerType: WorkflowTrigger\n  lastRunAt: Date | null\n  executionCount: number\n  successCount: number\n  failureCount: number\n  successRate: number\n}\n\n// Track active event subscriptions for cleanup\nconst activeSubscriptions = new Map<string, () => void>()\n\n// =============================================================================\n// SINGLE WORKFLOW TOGGLE\n// =============================================================================\n\n/**\n * Enable a workflow\n */\nexport async function enableWorkflow(workflowId: string): Promise<ToggleResult> {\n  return setWorkflowEnabled(workflowId, true)\n}\n\n/**\n * Disable a workflow\n */\nexport async function disableWorkflow(workflowId: string): Promise<ToggleResult> {\n  return setWorkflowEnabled(workflowId, false)\n}\n\n/**\n * Toggle a workflow's enabled state\n */\nexport async function toggleWorkflow(workflowId: string): Promise<ToggleResult> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId }\n  })\n\n  if (!workflow) {\n    return {\n      success: false,\n      error: `Workflow not found: ${workflowId}`\n    }\n  }\n\n  return setWorkflowEnabled(workflowId, !workflow.enabled)\n}\n\n/**\n * Set workflow enabled state with validation\n */\nasync function setWorkflowEnabled(\n  workflowId: string,\n  enabled: boolean\n): Promise<ToggleResult> {\n  try {\n    const workflow = await prisma.workflow.findUnique({\n      where: { id: workflowId },\n      include: {\n        workflowNodes: true\n      }\n    })\n\n    if (!workflow) {\n      return {\n        success: false,\n        error: `Workflow not found: ${workflowId}`\n      }\n    }\n\n    // If enabling, validate workflow is ready\n    if (enabled) {\n      const validation = validateWorkflowForEnable(workflow)\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: `Cannot enable workflow: ${validation.errors.join(', ')}`\n        }\n      }\n    }\n\n    // Update the workflow\n    const updatedWorkflow = await prisma.workflow.update({\n      where: { id: workflowId },\n      data: { enabled }\n    })\n\n    // Handle event subscriptions based on trigger type\n    if (enabled) {\n      await activateWorkflowTrigger(updatedWorkflow)\n    } else {\n      await deactivateWorkflowTrigger(updatedWorkflow)\n    }\n\n    return {\n      success: true,\n      workflow: updatedWorkflow,\n      message: `Workflow ${enabled ? 'enabled' : 'disabled'} successfully`\n    }\n  } catch (error) {\n    console.error('Failed to toggle workflow:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n\n// =============================================================================\n// BULK OPERATIONS\n// =============================================================================\n\n/**\n * Enable multiple workflows\n */\nexport async function enableWorkflows(workflowIds: string[]): Promise<BulkToggleResult> {\n  return bulkSetEnabled(workflowIds, true)\n}\n\n/**\n * Disable multiple workflows\n */\nexport async function disableWorkflows(workflowIds: string[]): Promise<BulkToggleResult> {\n  return bulkSetEnabled(workflowIds, false)\n}\n\n/**\n * Disable all workflows (emergency stop)\n */\nexport async function disableAllWorkflows(): Promise<BulkToggleResult> {\n  const enabledWorkflows = await prisma.workflow.findMany({\n    where: { enabled: true },\n    select: { id: true }\n  })\n\n  const workflowIds = enabledWorkflows.map(w => w.id)\n\n  if (workflowIds.length === 0) {\n    return {\n      success: true,\n      results: [],\n      enabledCount: 0,\n      disabledCount: 0,\n      errorCount: 0\n    }\n  }\n\n  return bulkSetEnabled(workflowIds, false)\n}\n\n/**\n * Enable all workflows by category\n */\nexport async function enableWorkflowsByCategory(\n  templateCategory: string\n): Promise<BulkToggleResult> {\n  const workflows = await prisma.workflow.findMany({\n    where: {\n      template: { category: templateCategory as any }\n    },\n    select: { id: true }\n  })\n\n  return bulkSetEnabled(workflows.map(w => w.id), true)\n}\n\n/**\n * Disable all workflows by trigger type\n */\nexport async function disableWorkflowsByTrigger(\n  triggerType: WorkflowTrigger\n): Promise<BulkToggleResult> {\n  const workflows = await prisma.workflow.findMany({\n    where: { triggerType, enabled: true },\n    select: { id: true }\n  })\n\n  return bulkSetEnabled(workflows.map(w => w.id), false)\n}\n\n/**\n * Bulk set enabled state for multiple workflows\n */\nasync function bulkSetEnabled(\n  workflowIds: string[],\n  enabled: boolean\n): Promise<BulkToggleResult> {\n  const results: BulkToggleResult['results'] = []\n  let enabledCount = 0\n  let disabledCount = 0\n  let errorCount = 0\n\n  for (const workflowId of workflowIds) {\n    const result = await setWorkflowEnabled(workflowId, enabled)\n\n    if (result.success) {\n      if (enabled) enabledCount++\n      else disabledCount++\n    } else {\n      errorCount++\n    }\n\n    results.push({\n      workflowId,\n      success: result.success,\n      enabled: result.workflow?.enabled,\n      error: result.error\n    })\n  }\n\n  return {\n    success: errorCount === 0,\n    results,\n    enabledCount,\n    disabledCount,\n    errorCount\n  }\n}\n\n// =============================================================================\n// VALIDATION\n// =============================================================================\n\ninterface ValidationResult {\n  valid: boolean\n  errors: string[]\n  warnings: string[]\n}\n\n/**\n * Validate that a workflow is ready to be enabled\n */\nfunction validateWorkflowForEnable(workflow: any): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  // Check for trigger node\n  const nodes = workflow.nodes as any[]\n  const hasTrigger = nodes.some(\n    node => node.type === 'trigger' || node.data?.stepType === 'TRIGGER'\n  )\n\n  if (!hasTrigger) {\n    errors.push('Workflow must have a trigger node')\n  }\n\n  // Check for at least one action\n  const hasAction = nodes.some(\n    node => node.type === 'primitive' ||\n           node.type === 'action' ||\n           node.data?.stepType === 'ACTION'\n  )\n\n  if (!hasAction) {\n    warnings.push('Workflow has no action nodes')\n  }\n\n  // Check trigger configuration for scheduled/event workflows\n  if (workflow.triggerType === 'SCHEDULE') {\n    const triggerConfig = workflow.triggerConfig as any\n    if (!triggerConfig?.cron) {\n      errors.push('Scheduled workflow must have a cron expression')\n    }\n  }\n\n  if (workflow.triggerType === 'EVENT') {\n    const triggerConfig = workflow.triggerConfig as any\n    if (!triggerConfig?.eventType) {\n      errors.push('Event workflow must specify an event type')\n    }\n  }\n\n  if (workflow.triggerType === 'WEBHOOK') {\n    const triggerConfig = workflow.triggerConfig as any\n    if (!triggerConfig?.path) {\n      errors.push('Webhook workflow must specify a path')\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings\n  }\n}\n\n/**\n * Check if a workflow can be enabled\n */\nexport async function canEnableWorkflow(workflowId: string): Promise<{\n  canEnable: boolean\n  validation: ValidationResult\n}> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId },\n    include: { workflowNodes: true }\n  })\n\n  if (!workflow) {\n    return {\n      canEnable: false,\n      validation: {\n        valid: false,\n        errors: ['Workflow not found'],\n        warnings: []\n      }\n    }\n  }\n\n  const validation = validateWorkflowForEnable(workflow)\n\n  return {\n    canEnable: validation.valid,\n    validation\n  }\n}\n\n// =============================================================================\n// TRIGGER MANAGEMENT\n// =============================================================================\n\n/**\n * Activate a workflow's trigger (subscribe to events, register webhook, etc.)\n */\nasync function activateWorkflowTrigger(workflow: Workflow): Promise<void> {\n  const triggerConfig = workflow.triggerConfig as Record<string, any> ?? {}\n\n  switch (workflow.triggerType) {\n    case 'EVENT':\n      await activateEventTrigger(workflow, triggerConfig)\n      break\n\n    case 'SCHEDULE':\n      // Scheduled workflows are handled by a cron job that checks getScheduledWorkflows()\n      // No additional activation needed\n      break\n\n    case 'WEBHOOK':\n      // Webhook workflows are handled by the webhook API route\n      // No additional activation needed, but log for debugging\n      console.log(`Activated webhook workflow: ${workflow.slug} at path ${triggerConfig.path}`)\n      break\n\n    case 'MANUAL':\n      // Manual workflows are triggered by user action\n      // No activation needed\n      break\n\n    case 'AI_AGENT':\n      // AI agent workflows are triggered by the AI system\n      // No additional activation needed\n      break\n  }\n}\n\n/**\n * Deactivate a workflow's trigger\n */\nasync function deactivateWorkflowTrigger(workflow: Workflow): Promise<void> {\n  // Remove event subscription if exists\n  const unsubscribeFn = activeSubscriptions.get(workflow.id)\n  if (unsubscribeFn) {\n    unsubscribeFn()\n    activeSubscriptions.delete(workflow.id)\n  }\n}\n\n/**\n * Activate an event-based trigger\n */\nasync function activateEventTrigger(\n  workflow: Workflow,\n  triggerConfig: Record<string, any>\n): Promise<void> {\n  const eventType = triggerConfig.eventType\n\n  if (!eventType) {\n    console.warn(`Event workflow ${workflow.id} has no eventType configured`)\n    return\n  }\n\n  // Subscribe to the event\n  const subscriptionId = subscribe({\n    eventType,\n    handler: async (event) => {\n      try {\n        // Import executeWorkflow dynamically to avoid circular dependency\n        const { executeWorkflow } = await import('./engine')\n\n        // Check event filters if configured\n        if (triggerConfig.filters) {\n          const matches = matchEventFilters(event.data as Record<string, unknown>, triggerConfig.filters)\n          if (!matches) return\n        }\n\n        // Execute the workflow\n        await executeWorkflow(workflow.id, {\n          triggeredBy: 'event',\n          eventData: {\n            type: eventType,\n            data: event.data,\n            timestamp: event.timestamp\n          }\n        })\n      } catch (error) {\n        console.error(`Failed to execute workflow ${workflow.id} for event ${eventType}:`, error)\n      }\n    }\n  })\n\n  // Store the unsubscribe function for cleanup\n  activeSubscriptions.set(workflow.id, () => unsubscribe(subscriptionId))\n\n  console.log(`Activated event trigger for workflow ${workflow.slug}: ${eventType}`)\n}\n\n/**\n * Check if event data matches configured filters\n */\nfunction matchEventFilters(\n  eventData: Record<string, any>,\n  filters: Record<string, any>\n): boolean {\n  for (const [key, value] of Object.entries(filters)) {\n    const eventValue = getNestedValue(eventData, key)\n\n    if (typeof value === 'object' && value !== null) {\n      // Handle operators like { $gt: 100, $lt: 200 }\n      for (const [op, opValue] of Object.entries(value as Record<string, any>)) {\n        switch (op) {\n          case '$eq':\n            if (eventValue !== opValue) return false\n            break\n          case '$ne':\n            if (eventValue === opValue) return false\n            break\n          case '$gt':\n            if (!(eventValue > opValue)) return false\n            break\n          case '$gte':\n            if (!(eventValue >= opValue)) return false\n            break\n          case '$lt':\n            if (!(eventValue < opValue)) return false\n            break\n          case '$lte':\n            if (!(eventValue <= opValue)) return false\n            break\n          case '$in':\n            if (!Array.isArray(opValue) || !opValue.includes(eventValue)) return false\n            break\n          case '$nin':\n            if (!Array.isArray(opValue) || opValue.includes(eventValue)) return false\n            break\n          case '$contains':\n            if (typeof eventValue !== 'string' || !eventValue.includes(opValue)) return false\n            break\n        }\n      }\n    } else {\n      // Simple equality check\n      if (eventValue !== value) return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Get nested value from object using dot notation\n */\nfunction getNestedValue(obj: Record<string, any>, path: string): any {\n  return path.split('.').reduce((current, key) => current?.[key], obj)\n}\n\n// =============================================================================\n// STATUS QUERIES\n// =============================================================================\n\n/**\n * Get workflow status summary\n */\nexport async function getWorkflowStatus(workflowId: string): Promise<WorkflowStatus | null> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId }\n  })\n\n  if (!workflow) return null\n\n  const successRate = workflow.executionCount > 0\n    ? (workflow.successCount / workflow.executionCount) * 100\n    : 0\n\n  return {\n    id: workflow.id,\n    name: workflow.name,\n    slug: workflow.slug,\n    enabled: workflow.enabled,\n    triggerType: workflow.triggerType,\n    lastRunAt: workflow.lastRunAt,\n    executionCount: workflow.executionCount,\n    successCount: workflow.successCount,\n    failureCount: workflow.failureCount,\n    successRate: Math.round(successRate * 100) / 100\n  }\n}\n\n/**\n * Get all workflow statuses\n */\nexport async function getAllWorkflowStatuses(): Promise<WorkflowStatus[]> {\n  const workflows = await prisma.workflow.findMany({\n    orderBy: [\n      { enabled: 'desc' },\n      { name: 'asc' }\n    ]\n  })\n\n  return workflows.map(workflow => {\n    const successRate = workflow.executionCount > 0\n      ? (workflow.successCount / workflow.executionCount) * 100\n      : 0\n\n    return {\n      id: workflow.id,\n      name: workflow.name,\n      slug: workflow.slug,\n      enabled: workflow.enabled,\n      triggerType: workflow.triggerType,\n      lastRunAt: workflow.lastRunAt,\n      executionCount: workflow.executionCount,\n      successCount: workflow.successCount,\n      failureCount: workflow.failureCount,\n      successRate: Math.round(successRate * 100) / 100\n    }\n  })\n}\n\n/**\n * Get enabled workflows count by trigger type\n */\nexport async function getEnabledWorkflowCounts(): Promise<Record<WorkflowTrigger, number>> {\n  const counts = await prisma.workflow.groupBy({\n    by: ['triggerType'],\n    where: { enabled: true },\n    _count: true\n  })\n\n  const result: Record<string, number> = {\n    MANUAL: 0,\n    SCHEDULE: 0,\n    WEBHOOK: 0,\n    EVENT: 0,\n    AI_AGENT: 0\n  }\n\n  counts.forEach(c => {\n    result[c.triggerType] = c._count\n  })\n\n  return result as Record<WorkflowTrigger, number>\n}\n\n// =============================================================================\n// INITIALIZATION\n// =============================================================================\n\n/**\n * Initialize all enabled event-based workflows on app startup\n */\nexport async function initializeEventWorkflows(): Promise<void> {\n  const eventWorkflows = await prisma.workflow.findMany({\n    where: {\n      enabled: true,\n      triggerType: 'EVENT'\n    }\n  })\n\n  console.log(`Initializing ${eventWorkflows.length} event workflows...`)\n\n  for (const workflow of eventWorkflows) {\n    try {\n      await activateWorkflowTrigger(workflow)\n    } catch (error) {\n      console.error(`Failed to initialize workflow ${workflow.id}:`, error)\n    }\n  }\n\n  console.log('Event workflow initialization complete')\n}\n\n/**\n * Cleanup all active subscriptions (for shutdown)\n */\nexport function cleanupAllSubscriptions(): void {\n  console.log(`Cleaning up ${activeSubscriptions.size} workflow subscriptions...`)\n\n  for (const [workflowId, unsubscribeFn] of activeSubscriptions) {\n    try {\n      unsubscribeFn()\n    } catch (error) {\n      console.error(`Failed to cleanup subscription for workflow ${workflowId}:`, error)\n    }\n  }\n\n  activeSubscriptions.clear()\n  console.log('Workflow subscription cleanup complete')\n}\n","/**\n * Shippo Shipping Service Layer\n *\n * Core integration with Shippo API for:\n * - Address validation\n * - Rate shopping (USPS, UPS, FedEx)\n * - Label generation (PDF/PNG)\n * - Tracking updates\n * - Refunds\n *\n * Configuration is read from:\n * 1. Database (settings table -> shipping group) - preferred\n * 2. Environment variables - fallback\n */\n\nimport { Shippo } from 'shippo'\nimport { prisma } from '../db'\nimport { safeDecrypt } from '../encryption'\nimport type {\n  ShippingAddress,\n  ValidatedAddress,\n  Parcel,\n  ShippingRate,\n  CreateShipmentRequest,\n  ShipmentResponse,\n  PurchaseLabelRequest,\n  LabelResponse,\n  LabelFormat,\n  TrackingStatus,\n  RefundResponse,\n  CarrierType,\n  ShippingSettings,\n} from './types'\n\n// Cache for shipping settings to avoid repeated DB queries\nlet cachedSettings: ShippingSettings | null = null\nlet cacheExpiry: number = 0\nconst CACHE_TTL = 60000 // 1 minute cache\n\n/**\n * Fetch shipping settings from the database\n * Falls back to environment variables if database settings are not available\n * API key always falls back to env var if not in database (for easier setup)\n */\nexport async function getShippingSettings(): Promise<ShippingSettings> {\n  // Return cached settings if still valid\n  if (cachedSettings && Date.now() < cacheExpiry) {\n    return cachedSettings\n  }\n\n  // Start with env-based defaults\n  const envApiKey = process.env.SHIPPO_API_KEY\n  const envWebhookSecret = process.env.SHIPPO_WEBHOOK_SECRET\n\n  try {\n    // Fetch all shipping-related settings from the database\n    const settings = await prisma.setting.findMany({\n      where: { group: 'shipping' },\n    })\n\n    if (settings.length > 0) {\n      // Build settings object from database records\n      // Decrypt encrypted values\n      const settingsMap: Record<string, string> = {}\n      for (const setting of settings) {\n        // Decrypt if marked as encrypted\n        settingsMap[setting.key] = setting.encrypted\n          ? safeDecrypt(setting.value)\n          : setting.value\n      }\n\n      const dbSettings: ShippingSettings = {\n        enabled: settingsMap['shipping.enabled'] === 'true',\n        // Always fall back to env var for API key - makes setup easier\n        shippoApiKey: settingsMap['shipping.shippoApiKey'] || envApiKey,\n        shippoWebhookSecret: settingsMap['shipping.shippoWebhookSecret'] || envWebhookSecret,\n        testMode: settingsMap['shipping.testMode'] === 'true',\n        useElements: settingsMap['shipping.useElements'] !== 'false', // Default to true\n        fromName: settingsMap['shipping.fromName'],\n        fromCompany: settingsMap['shipping.fromCompany'],\n        fromStreet1: settingsMap['shipping.fromStreet1'],\n        fromStreet2: settingsMap['shipping.fromStreet2'],\n        fromCity: settingsMap['shipping.fromCity'],\n        fromState: settingsMap['shipping.fromState'],\n        fromZip: settingsMap['shipping.fromZip'],\n        fromCountry: settingsMap['shipping.fromCountry'] || 'US',\n        fromPhone: settingsMap['shipping.fromPhone'],\n        fromEmail: settingsMap['shipping.fromEmail'],\n        enabledCarriers: settingsMap['shipping.enabledCarriers']\n          ? JSON.parse(settingsMap['shipping.enabledCarriers'])\n          : ['usps', 'ups', 'fedex'],\n        defaultLabelFormat: settingsMap['shipping.defaultLabelFormat'] as LabelFormat || 'PDF',\n        defaultPackageWeight: settingsMap['shipping.defaultPackageWeight']\n          ? parseInt(settingsMap['shipping.defaultPackageWeight'])\n          : 16,\n        requireSignature: settingsMap['shipping.requireSignature'] === 'true',\n      }\n\n      // If shipping is enabled (either explicitly or API key present in env), use db settings\n      // This allows using env var for API key while still customizing other settings in DB\n      if (dbSettings.enabled || (dbSettings.shippoApiKey && settingsMap['shipping.enabled'] === undefined)) {\n        // If enabled wasn't explicitly set but we have an API key, auto-enable\n        if (settingsMap['shipping.enabled'] === undefined && dbSettings.shippoApiKey) {\n          dbSettings.enabled = true\n        }\n        cachedSettings = dbSettings\n        cacheExpiry = Date.now() + CACHE_TTL\n        return dbSettings\n      }\n    }\n  } catch (error) {\n    console.warn('Could not fetch shipping settings from database, using env vars:', error)\n  }\n\n  // Fall back to environment variables entirely\n  // Auto-enable if API key is present\n  const envSettings: ShippingSettings = {\n    enabled: !!envApiKey, // Auto-enable if API key exists\n    shippoApiKey: envApiKey,\n    shippoWebhookSecret: envWebhookSecret,\n    testMode: process.env.NODE_ENV !== 'production',\n    useElements: true, // Default to using Shippo Elements\n    fromName: process.env.SHIP_FROM_NAME,\n    fromCompany: process.env.SHIP_FROM_COMPANY,\n    fromStreet1: process.env.SHIP_FROM_STREET,\n    fromStreet2: process.env.SHIP_FROM_STREET2,\n    fromCity: process.env.SHIP_FROM_CITY,\n    fromState: process.env.SHIP_FROM_STATE,\n    fromZip: process.env.SHIP_FROM_ZIP,\n    fromCountry: process.env.SHIP_FROM_COUNTRY || 'US',\n    fromPhone: process.env.SHIP_FROM_PHONE,\n    fromEmail: process.env.SHIP_FROM_EMAIL,\n    enabledCarriers: ['usps', 'ups', 'fedex'],\n    defaultLabelFormat: 'PDF',\n    defaultPackageWeight: 16,\n    requireSignature: false,\n  }\n\n  cachedSettings = envSettings\n  cacheExpiry = Date.now() + CACHE_TTL\n  return envSettings\n}\n\n/**\n * Clear the settings cache (useful after settings are updated)\n */\nexport function clearShippingSettingsCache(): void {\n  cachedSettings = null\n  cacheExpiry = 0\n}\n\n/**\n * Get the Shippo API key from database or environment\n */\nasync function getShippoApiKey(): Promise<string> {\n  const settings = await getShippingSettings()\n  const apiKey = settings.shippoApiKey || process.env.SHIPPO_API_KEY\n\n  if (!apiKey) {\n    throw new Error('Shippo API key is not configured. Set it in Settings > Shipping or SHIPPO_API_KEY env var.')\n  }\n\n  return apiKey\n}\n\n/**\n * Initialize Shippo client with API key from database or environment\n */\nasync function getShippoClientAsync(): Promise<Shippo> {\n  const apiKey = await getShippoApiKey()\n  return new Shippo({ apiKeyHeader: apiKey })\n}\n\n// Synchronous version for backwards compatibility (uses env var only)\nconst getShippoClient = (): Shippo => {\n  const apiKey = process.env.SHIPPO_API_KEY\n  if (!apiKey) {\n    throw new Error('SHIPPO_API_KEY environment variable is not set')\n  }\n  return new Shippo({ apiKeyHeader: apiKey })\n}\n\n/**\n * Get default ship-from address from database or environment variables\n */\nexport async function getDefaultFromAddress(): Promise<ShippingAddress> {\n  const settings = await getShippingSettings()\n\n  return {\n    name: settings.fromName || process.env.SHIP_FROM_NAME || '',\n    company: settings.fromCompany || process.env.SHIP_FROM_COMPANY,\n    street1: settings.fromStreet1 || process.env.SHIP_FROM_STREET || '',\n    street2: settings.fromStreet2 || process.env.SHIP_FROM_STREET2,\n    city: settings.fromCity || process.env.SHIP_FROM_CITY || '',\n    state: settings.fromState || process.env.SHIP_FROM_STATE || '',\n    zip: settings.fromZip || process.env.SHIP_FROM_ZIP || '',\n    country: settings.fromCountry || process.env.SHIP_FROM_COUNTRY || 'US',\n    phone: settings.fromPhone || process.env.SHIP_FROM_PHONE,\n    email: settings.fromEmail || process.env.SHIP_FROM_EMAIL,\n  }\n}\n\n/**\n * Validate a shipping address\n * Returns validated/standardized address with any messages\n */\nexport async function validateAddress(address: ShippingAddress): Promise<ValidatedAddress> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const response = await shippo.addresses.create({\n      name: address.name,\n      company: address.company,\n      street1: address.street1,\n      street2: address.street2,\n      city: address.city,\n      state: address.state,\n      zip: address.zip,\n      country: address.country,\n      phone: address.phone,\n      email: address.email,\n      validate: true,\n    })\n\n    const isValid = response.validationResults?.isValid ?? false\n    const messages = response.validationResults?.messages?.map((msg: { source?: string; code?: string; text?: string; type?: string }) => ({\n      source: msg.source || 'shippo',\n      code: msg.code || '',\n      text: msg.text || '',\n      type: (msg.type as 'error' | 'warning' | 'info') || 'info',\n    })) || []\n\n    return {\n      ...address,\n      name: response.name || address.name,\n      street1: response.street1 || address.street1,\n      street2: response.street2,\n      city: response.city || address.city,\n      state: response.state || address.state,\n      zip: response.zip || address.zip,\n      country: response.country || address.country,\n      isValid,\n      messages,\n    }\n  } catch (error) {\n    console.error('Address validation error:', error)\n    return {\n      ...address,\n      isValid: false,\n      messages: [{\n        source: 'shippo',\n        code: 'VALIDATION_ERROR',\n        text: error instanceof Error ? error.message : 'Address validation failed',\n        type: 'error',\n      }],\n    }\n  }\n}\n\n/**\n * Create a shipment and get rates from all carriers\n */\nexport async function createShipment(request: CreateShipmentRequest): Promise<ShipmentResponse> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const shipment = await shippo.shipments.create({\n      addressFrom: {\n        name: request.addressFrom.name,\n        company: request.addressFrom.company,\n        street1: request.addressFrom.street1,\n        street2: request.addressFrom.street2,\n        city: request.addressFrom.city,\n        state: request.addressFrom.state,\n        zip: request.addressFrom.zip,\n        country: request.addressFrom.country,\n        phone: request.addressFrom.phone,\n        email: request.addressFrom.email,\n      },\n      addressTo: {\n        name: request.addressTo.name,\n        company: request.addressTo.company,\n        street1: request.addressTo.street1,\n        street2: request.addressTo.street2,\n        city: request.addressTo.city,\n        state: request.addressTo.state,\n        zip: request.addressTo.zip,\n        country: request.addressTo.country,\n        phone: request.addressTo.phone,\n        email: request.addressTo.email,\n      },\n      parcels: request.parcels.map((parcel) => ({\n        length: String(parcel.length),\n        width: String(parcel.width),\n        height: String(parcel.height),\n        weight: String(parcel.weight),\n        massUnit: parcel.massUnit || 'oz',\n        distanceUnit: parcel.distanceUnit || 'in',\n      })),\n      extra: request.extra ? {\n        signatureConfirmation: request.extra.signature,\n        insurance: request.extra.insurance ? {\n          amount: request.extra.insurance.amount,\n          currency: request.extra.insurance.currency,\n          content: request.extra.insurance.content,\n        } : undefined,\n        reference1: request.extra.reference1,\n        reference2: request.extra.reference2,\n        saturdayDelivery: request.extra.saturdayDelivery,\n      } : undefined,\n      async: false,\n    })\n\n    // Map rates to our format\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const rates: ShippingRate[] = (shipment.rates || []).map((rate: any) => ({\n      rateId: rate.objectId || '',\n      carrier: mapCarrier(rate.provider || ''),\n      carrierAccount: rate.carrierAccount || '',\n      servicelevel: {\n        name: rate.servicelevel?.name || '',\n        token: rate.servicelevel?.token || '',\n        terms: rate.servicelevel?.terms,\n      },\n      amount: rate.amount || '0',\n      currency: rate.currency || 'USD',\n      amountLocal: rate.amountLocal,\n      currencyLocal: rate.currencyLocal,\n      estimatedDays: rate.estimatedDays,\n      durationTerms: rate.durationTerms,\n      zone: rate.zone,\n      attributes: rate.attributes,\n      provider: rate.provider,\n      arrivesBy: rate.arrivesBy,\n    }))\n\n    // Sort rates by price\n    rates.sort((a, b) => parseFloat(a.amount) - parseFloat(b.amount))\n\n    return {\n      shipmentId: shipment.objectId || '',\n      status: (shipment.status as ShipmentResponse['status']) || 'ERROR',\n      rates,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      messages: shipment.messages?.map((msg: any) => ({\n        source: msg.source || '',\n        code: msg.code || '',\n        text: msg.text || '',\n      })),\n    }\n  } catch (error) {\n    console.error('Create shipment error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to create shipment')\n  }\n}\n\n/**\n * Get rates for an existing shipment\n */\nexport async function getRates(shipmentId: string): Promise<ShippingRate[]> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const shipment = await shippo.shipments.get(shipmentId)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const rates: ShippingRate[] = (shipment.rates || []).map((rate: any) => ({\n      rateId: rate.objectId || '',\n      carrier: mapCarrier(rate.provider || ''),\n      carrierAccount: rate.carrierAccount || '',\n      servicelevel: {\n        name: rate.servicelevel?.name || '',\n        token: rate.servicelevel?.token || '',\n        terms: rate.servicelevel?.terms,\n      },\n      amount: rate.amount || '0',\n      currency: rate.currency || 'USD',\n      amountLocal: rate.amountLocal,\n      currencyLocal: rate.currencyLocal,\n      estimatedDays: rate.estimatedDays,\n      durationTerms: rate.durationTerms,\n      zone: rate.zone,\n      attributes: rate.attributes,\n      provider: rate.provider,\n      arrivesBy: rate.arrivesBy,\n    }))\n\n    return rates.sort((a, b) => parseFloat(a.amount) - parseFloat(b.amount))\n  } catch (error) {\n    console.error('Get rates error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to get rates')\n  }\n}\n\n/**\n * Purchase a shipping label\n */\nexport async function purchaseLabel(request: PurchaseLabelRequest): Promise<LabelResponse> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const transaction = await shippo.transactions.create({\n      rate: request.rateId,\n      labelFileType: mapLabelFormat(request.labelFormat || 'PDF'),\n      async: request.async ?? false,\n    })\n\n    // Handle rate being either a string ID or CoreRate object\n    const rateData = typeof transaction.rate === 'string'\n      ? { objectId: transaction.rate }\n      : transaction.rate\n\n    return {\n      transactionId: transaction.objectId || '',\n      status: (transaction.status as LabelResponse['status']) || 'ERROR',\n      rate: {\n        rateId: rateData?.objectId || request.rateId,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        carrier: mapCarrier((rateData as any)?.provider || ''),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        carrierAccount: (rateData as any)?.carrierAccount || '',\n        servicelevel: {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          name: (rateData as any)?.servicelevel?.name || '',\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          token: (rateData as any)?.servicelevel?.token || '',\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        amount: (rateData as any)?.amount || '0',\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        currency: (rateData as any)?.currency || 'USD',\n      },\n      trackingNumber: transaction.trackingNumber || '',\n      trackingUrl: transaction.trackingUrlProvider || '',\n      labelUrl: transaction.labelUrl || '',\n      commercialInvoiceUrl: transaction.commercialInvoiceUrl,\n      eta: transaction.eta,\n      messages: transaction.messages?.map((msg: { source?: string; code?: string; text?: string }) => ({\n        source: msg.source || '',\n        code: msg.code || '',\n        text: msg.text || '',\n      })),\n    }\n  } catch (error) {\n    console.error('Purchase label error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to purchase label')\n  }\n}\n\n/**\n * Get tracking status for a shipment\n */\nexport async function getTracking(carrier: CarrierType, trackingNumber: string): Promise<TrackingStatus> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const tracking = await shippo.trackingStatus.get(carrier, trackingNumber)\n\n    // Helper to convert Date to ISO string\n    const toIsoString = (date: Date | string | undefined): string | undefined => {\n      if (!date) return undefined\n      return date instanceof Date ? date.toISOString() : date\n    }\n\n    return {\n      carrier,\n      trackingNumber: tracking.trackingNumber || trackingNumber,\n      eta: toIsoString(tracking.eta),\n      servicelevel: tracking.servicelevel ? {\n        name: tracking.servicelevel.name || '',\n        token: tracking.servicelevel.token || '',\n      } : undefined,\n      addressFrom: tracking.addressFrom ? {\n        city: tracking.addressFrom.city,\n        state: tracking.addressFrom.state,\n        zip: tracking.addressFrom.zip,\n        country: tracking.addressFrom.country,\n      } : undefined,\n      addressTo: tracking.addressTo ? {\n        city: tracking.addressTo.city,\n        state: tracking.addressTo.state,\n        zip: tracking.addressTo.zip,\n        country: tracking.addressTo.country,\n      } : undefined,\n      trackingStatus: {\n        status: mapTrackingStatus(tracking.trackingStatus?.status || 'UNKNOWN'),\n        statusDetails: tracking.trackingStatus?.statusDetails || '',\n        statusDate: toIsoString(tracking.trackingStatus?.statusDate) || new Date().toISOString(),\n        location: tracking.trackingStatus?.location ? {\n          city: tracking.trackingStatus.location.city,\n          state: tracking.trackingStatus.location.state,\n          zip: tracking.trackingStatus.location.zip,\n          country: tracking.trackingStatus.location.country,\n        } : undefined,\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      trackingHistory: (tracking.trackingHistory || []).map((event: any) => ({\n        status: mapTrackingStatus(event.status || 'UNKNOWN'),\n        statusDetails: event.statusDetails || '',\n        statusDate: toIsoString(event.statusDate) || '',\n        location: event.location ? {\n          city: event.location.city,\n          state: event.location.state,\n          zip: event.location.zip,\n          country: event.location.country,\n        } : undefined,\n      })),\n    }\n  } catch (error) {\n    console.error('Get tracking error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to get tracking')\n  }\n}\n\n/**\n * Request a refund for a label\n */\nexport async function refundLabel(transactionId: string): Promise<RefundResponse> {\n  const shippo = await getShippoClientAsync()\n\n  try {\n    const refund = await shippo.refunds.create({\n      transaction: transactionId,\n    })\n\n    return {\n      transactionId,\n      status: (refund.status as 'PENDING' | 'SUCCESS' | 'ERROR') || 'PENDING',\n    }\n  } catch (error) {\n    console.error('Refund label error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to refund label')\n  }\n}\n\n/**\n * Register a webhook for tracking updates\n */\nexport async function registerTrackingWebhook(webhookUrl: string): Promise<void> {\n  const apiKey = await getShippoApiKey()\n\n  try {\n    const response = await fetch('https://api.goshippo.com/webhooks/', {\n      method: 'POST',\n      headers: {\n        'Authorization': `ShippoToken ${apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        url: webhookUrl,\n        event: 'track_updated',\n        is_test: process.env.NODE_ENV !== 'production',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.text()\n      throw new Error(`Failed to register webhook: ${error}`)\n    }\n  } catch (error) {\n    console.error('Register webhook error:', error)\n    throw new Error(error instanceof Error ? error.message : 'Failed to register webhook')\n  }\n}\n\n// Helper functions\nfunction mapCarrier(provider: string): CarrierType {\n  const lower = provider.toLowerCase()\n  if (lower.includes('usps')) return 'usps'\n  if (lower.includes('ups')) return 'ups'\n  if (lower.includes('fedex')) return 'fedex'\n  return 'usps' // Default\n}\n\nfunction mapLabelFormat(format: LabelFormat): 'PDF' | 'PNG' | 'ZPLII' {\n  if (format.startsWith('PDF')) return 'PDF'\n  if (format === 'PNG') return 'PNG'\n  if (format === 'ZPLII') return 'ZPLII'\n  return 'PDF'\n}\n\nfunction mapTrackingStatus(status: string): TrackingStatus['trackingStatus']['status'] {\n  const statusMap: Record<string, TrackingStatus['trackingStatus']['status']> = {\n    'UNKNOWN': 'UNKNOWN',\n    'PRE_TRANSIT': 'PRE_TRANSIT',\n    'TRANSIT': 'TRANSIT',\n    'DELIVERED': 'DELIVERED',\n    'RETURNED': 'RETURNED',\n    'FAILURE': 'FAILURE',\n  }\n  return statusMap[status] || 'UNKNOWN'\n}\n\n// Export types\nexport * from './types'\n","/**\n * Shippo Integration Types\n *\n * TypeScript interfaces for working with Shippo shipping API.\n */\n\n// Address Types\nexport interface ShippingAddress {\n  name: string\n  company?: string\n  street1: string\n  street2?: string\n  city: string\n  state: string\n  zip: string\n  country: string\n  phone?: string\n  email?: string\n  isResidential?: boolean\n}\n\nexport interface ValidatedAddress extends ShippingAddress {\n  isValid: boolean\n  messages?: AddressValidationMessage[]\n  suggestedAddress?: ShippingAddress\n}\n\nexport interface AddressValidationMessage {\n  source: string\n  code: string\n  text: string\n  type: 'error' | 'warning' | 'info'\n}\n\n// Parcel Types\nexport interface Parcel {\n  length: number // inches\n  width: number // inches\n  height: number // inches\n  weight: number // ounces\n  massUnit?: 'oz' | 'lb' | 'g' | 'kg'\n  distanceUnit?: 'in' | 'cm'\n}\n\nexport interface ParcelTemplate {\n  name: string\n  carrier: CarrierType\n  token: string // Shippo parcel template token\n  dimensions: {\n    length: number\n    width: number\n    height: number\n  }\n}\n\n// Rate Types\nexport interface ShippingRate {\n  rateId: string\n  carrier: CarrierType\n  carrierAccount: string\n  servicelevel: {\n    name: string\n    token: string\n    terms?: string\n  }\n  amount: string\n  currency: string\n  amountLocal?: string\n  currencyLocal?: string\n  estimatedDays?: number\n  durationTerms?: string\n  zone?: string\n  attributes?: string[]\n  provider?: string\n  arrivesBy?: string\n}\n\n// Carrier Types\nexport type CarrierType = 'usps' | 'ups' | 'fedex'\n\nexport interface CarrierAccount {\n  id: string\n  carrier: CarrierType\n  accountId: string\n  isActive: boolean\n  test: boolean\n}\n\n// Shipment Types\nexport interface CreateShipmentRequest {\n  addressFrom: ShippingAddress\n  addressTo: ShippingAddress\n  parcels: Parcel[]\n  customsDeclaration?: CustomsDeclaration\n  extra?: ShipmentExtras\n}\n\nexport interface ShipmentExtras {\n  signature?: 'STANDARD' | 'ADULT' | 'CERTIFIED' | 'INDIRECT' | 'CARRIER_CONFIRMATION'\n  insurance?: {\n    amount: string\n    currency: string\n    content?: string\n  }\n  reference1?: string\n  reference2?: string\n  containsAlcohol?: boolean\n  saturdayDelivery?: boolean\n}\n\nexport interface CustomsDeclaration {\n  contentsType: 'DOCUMENTS' | 'GIFT' | 'SAMPLE' | 'MERCHANDISE' | 'HUMANITARIAN_DONATION' | 'RETURN_MERCHANDISE' | 'OTHER'\n  contentsExplanation?: string\n  items: CustomsItem[]\n  nonDeliveryOption?: 'ABANDON' | 'RETURN'\n  certify?: boolean\n  certifySigner?: string\n  incoterm?: 'DDP' | 'DDU'\n}\n\nexport interface CustomsItem {\n  description: string\n  quantity: number\n  netWeight: string\n  massUnit: 'oz' | 'lb' | 'g' | 'kg'\n  valueAmount: string\n  valueCurrency: string\n  originCountry: string\n  tariffNumber?: string\n}\n\nexport interface ShipmentResponse {\n  shipmentId: string\n  status: 'QUEUED' | 'WAITING' | 'SUCCESS' | 'ERROR'\n  rates: ShippingRate[]\n  messages?: ShipmentMessage[]\n}\n\nexport interface ShipmentMessage {\n  source: string\n  code: string\n  text: string\n}\n\n// Transaction (Label) Types\nexport type LabelFormat = 'PDF' | 'PNG' | 'PDF_4x6' | 'PDF_A4' | 'PDF_A6' | 'PNG_2.3x7.5' | 'ZPLII'\n\nexport interface PurchaseLabelRequest {\n  rateId: string\n  labelFormat?: LabelFormat\n  labelFileType?: 'PDF' | 'PNG' | 'ZPLII'\n  async?: boolean\n}\n\nexport interface LabelResponse {\n  transactionId: string\n  status: 'QUEUED' | 'WAITING' | 'SUCCESS' | 'ERROR' | 'REFUNDED' | 'REFUNDPENDING' | 'REFUNDREJECTED'\n  rate: ShippingRate\n  trackingNumber: string\n  trackingUrl: string\n  labelUrl: string\n  commercialInvoiceUrl?: string\n  eta?: string\n  messages?: ShipmentMessage[]\n}\n\n// Tracking Types\nexport interface TrackingStatus {\n  carrier: CarrierType\n  trackingNumber: string\n  eta?: string\n  servicelevel?: {\n    name: string\n    token: string\n  }\n  addressFrom?: Partial<ShippingAddress>\n  addressTo?: Partial<ShippingAddress>\n  trackingStatus: TrackingEvent\n  trackingHistory: TrackingEvent[]\n}\n\nexport interface TrackingEvent {\n  status: TrackingStatusType\n  statusDetails: string\n  statusDate: string\n  location?: {\n    city?: string\n    state?: string\n    zip?: string\n    country?: string\n  }\n  substatus?: {\n    code: string\n    text: string\n    actionRequired: boolean\n  }\n}\n\nexport type TrackingStatusType =\n  | 'UNKNOWN'\n  | 'PRE_TRANSIT'\n  | 'TRANSIT'\n  | 'DELIVERED'\n  | 'RETURNED'\n  | 'FAILURE'\n\n// Refund Types\nexport interface RefundRequest {\n  transactionId: string\n}\n\nexport interface RefundResponse {\n  transactionId: string\n  status: 'PENDING' | 'SUCCESS' | 'ERROR'\n}\n\n// Webhook Types\nexport interface ShippoWebhookPayload {\n  event: string\n  test: boolean\n  data: {\n    carrier: string\n    tracking_number: string\n    tracking_status: TrackingEvent\n    tracking_history: TrackingEvent[]\n  }\n}\n\n// Configuration Types\nexport interface ShippoConfig {\n  apiKey: string\n  webhookSecret?: string\n  defaultFromAddress: ShippingAddress\n  carriers: CarrierType[]\n  testMode: boolean\n}\n\nexport interface ShippingSettings {\n  enabled?: boolean\n  shippoApiKey?: string\n  shippoWebhookSecret?: string\n  testMode?: boolean\n  /** Use Shippo Shipping Elements (embedded widget) instead of custom API integration */\n  useElements?: boolean\n  fromName?: string\n  fromCompany?: string\n  fromStreet1?: string\n  fromStreet2?: string\n  fromCity?: string\n  fromState?: string\n  fromZip?: string\n  fromCountry?: string\n  fromPhone?: string\n  fromEmail?: string\n  enabledCarriers?: CarrierType[]\n  defaultLabelFormat?: LabelFormat\n  defaultPackageWeight?: number\n  requireSignature?: boolean\n}\n\n// Shippo Elements Types\nexport interface ShippoElementsAuthResponse {\n  token: string\n  expiresAt: string\n  organizationId: string\n}\n\nexport interface ShippoElementsLabel {\n  transactionId: string\n  trackingNumber: string\n  trackingUrl: string\n  labelUrl: string\n  rate: {\n    carrier: string\n    service: string\n    amount: string\n    currency: string\n  }\n}\n\n// Status Constants\nexport interface ShipmentStatusOption {\n  value: 'pending' | 'label_purchased' | 'in_transit' | 'delivered' | 'exception' | 'refunded'\n  label: string\n}\n\nexport const SHIPMENT_STATUSES: ShipmentStatusOption[] = [\n  { value: 'pending', label: 'Pending' },\n  { value: 'label_purchased', label: 'Label Purchased' },\n  { value: 'in_transit', label: 'In Transit' },\n  { value: 'delivered', label: 'Delivered' },\n  { value: 'exception', label: 'Exception' },\n  { value: 'refunded', label: 'Refunded' },\n]\n\nexport const CARRIER_OPTIONS = [\n  { value: 'usps', label: 'USPS' },\n  { value: 'ups', label: 'UPS' },\n  { value: 'fedex', label: 'FedEx' },\n] as const\n\nexport const LABEL_FORMAT_OPTIONS = [\n  { value: 'PDF', label: 'PDF (Standard)' },\n  { value: 'PDF_4x6', label: 'PDF 4x6 (Thermal)' },\n  { value: 'PNG', label: 'PNG' },\n] as const\n","/**\n * Customer Dashboard Configuration Types\n *\n * Defines the structure for configurable, modular dashboards\n * that can be customized for different business types:\n * - E-commerce: Orders, shipping, payment methods\n * - Consulting: Projects, invoices, scheduling\n * - Services: Bookings, subscriptions, usage\n * - General: Profile, addresses, notifications\n */\n\n/**\n * Available dashboard widget types\n */\nexport type DashboardWidgetType =\n  // Core widgets (all dashboard types)\n  | 'profile-overview'\n  | 'quick-actions'\n  | 'notifications'\n  | 'support'\n  // E-commerce widgets\n  | 'recent-orders'\n  | 'order-tracking'\n  | 'payment-methods'\n  | 'addresses'\n  | 'wishlist'\n  | 'loyalty-points'\n  | 'subscriptions'\n  // Consulting/Services widgets\n  | 'active-projects'\n  | 'project-milestones'\n  | 'invoices'\n  | 'upcoming-meetings'\n  | 'time-tracking'\n  | 'documents'\n  // Bookings/Appointments\n  | 'upcoming-bookings'\n  | 'booking-history'\n  | 'available-services'\n  // Usage-based\n  | 'usage-stats'\n  | 'billing-summary'\n  | 'api-keys';\n\n/**\n * Dashboard preset types\n */\nexport type DashboardPreset =\n  | 'ecommerce'\n  | 'consulting'\n  | 'services'\n  | 'booking'\n  | 'saas'\n  | 'custom';\n\n/**\n * Widget configuration\n */\nexport interface DashboardWidget {\n  id: string;\n  type: DashboardWidgetType;\n  title: string;\n  description?: string;\n  enabled: boolean;\n  /** Grid column span (1-4) */\n  colSpan?: 1 | 2 | 3 | 4;\n  /** Sort order (lower = first) */\n  order: number;\n  /** Widget-specific settings */\n  settings?: Record<string, unknown>;\n}\n\n/**\n * Dashboard tab configuration\n */\nexport interface DashboardTab {\n  id: string;\n  label: string;\n  icon?: string;\n  slug: string;\n  enabled: boolean;\n  order: number;\n  widgets: DashboardWidget[];\n}\n\n/**\n * Full dashboard configuration\n */\nexport interface DashboardConfig {\n  /** Preset type for quick configuration */\n  preset: DashboardPreset;\n  /** Dashboard title shown to customers */\n  title: string;\n  /** Whether to show the main overview tab */\n  showOverview: boolean;\n  /** Tabs configuration */\n  tabs: DashboardTab[];\n  /** Theme customization */\n  theme?: {\n    primaryColor?: string;\n    accentColor?: string;\n    borderRadius?: 'none' | 'sm' | 'md' | 'lg';\n    cardStyle?: 'flat' | 'bordered' | 'elevated';\n  };\n}\n\n/**\n * Default widget configurations by type\n */\nexport const DEFAULT_WIDGETS: Record<DashboardWidgetType, Partial<DashboardWidget>> = {\n  // Core\n  'profile-overview': { title: 'Profile', colSpan: 2 },\n  'quick-actions': { title: 'Quick Actions', colSpan: 2 },\n  'notifications': { title: 'Notifications', colSpan: 1 },\n  'support': { title: 'Need Help?', colSpan: 1 },\n  // E-commerce\n  'recent-orders': { title: 'Recent Orders', colSpan: 4 },\n  'order-tracking': { title: 'Track Your Order', colSpan: 2 },\n  'payment-methods': { title: 'Payment Methods', colSpan: 2 },\n  'addresses': { title: 'Addresses', colSpan: 2 },\n  'wishlist': { title: 'Wishlist', colSpan: 2 },\n  'loyalty-points': { title: 'Rewards', colSpan: 1 },\n  'subscriptions': { title: 'Subscriptions', colSpan: 2 },\n  // Consulting\n  'active-projects': { title: 'Active Projects', colSpan: 4 },\n  'project-milestones': { title: 'Milestones', colSpan: 2 },\n  'invoices': { title: 'Invoices', colSpan: 2 },\n  'upcoming-meetings': { title: 'Upcoming Meetings', colSpan: 2 },\n  'time-tracking': { title: 'Time Tracking', colSpan: 2 },\n  'documents': { title: 'Documents', colSpan: 2 },\n  // Bookings\n  'upcoming-bookings': { title: 'Upcoming Bookings', colSpan: 4 },\n  'booking-history': { title: 'Past Bookings', colSpan: 4 },\n  'available-services': { title: 'Book a Service', colSpan: 2 },\n  // SaaS\n  'usage-stats': { title: 'Usage', colSpan: 2 },\n  'billing-summary': { title: 'Billing', colSpan: 2 },\n  'api-keys': { title: 'API Keys', colSpan: 2 },\n};\n\n/**\n * Preset configurations\n */\nexport const DASHBOARD_PRESETS: Record<DashboardPreset, Partial<DashboardConfig>> = {\n  ecommerce: {\n    title: 'My Account',\n    showOverview: true,\n    tabs: [\n      {\n        id: 'orders',\n        label: 'Orders',\n        slug: 'orders',\n        icon: 'package',\n        enabled: true,\n        order: 1,\n        widgets: [\n          { id: 'recent-orders', type: 'recent-orders', title: 'Orders', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'addresses',\n        label: 'Addresses',\n        slug: 'addresses',\n        icon: 'map-pin',\n        enabled: true,\n        order: 2,\n        widgets: [\n          { id: 'addresses', type: 'addresses', title: 'Addresses', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'payments',\n        label: 'Payment Methods',\n        slug: 'payments',\n        icon: 'credit-card',\n        enabled: true,\n        order: 3,\n        widgets: [\n          { id: 'payment-methods', type: 'payment-methods', title: 'Payment Methods', enabled: true, order: 1 },\n        ],\n      },\n    ],\n  },\n  consulting: {\n    title: 'Client Portal',\n    showOverview: true,\n    tabs: [\n      {\n        id: 'projects',\n        label: 'Projects',\n        slug: 'projects',\n        icon: 'briefcase',\n        enabled: true,\n        order: 1,\n        widgets: [\n          { id: 'active-projects', type: 'active-projects', title: 'Your Projects', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'billing',\n        label: 'Billing',\n        slug: 'billing',\n        icon: 'file-text',\n        enabled: true,\n        order: 2,\n        widgets: [\n          { id: 'invoices', type: 'invoices', title: 'Invoices', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'meetings',\n        label: 'Meetings',\n        slug: 'meetings',\n        icon: 'calendar',\n        enabled: true,\n        order: 3,\n        widgets: [\n          { id: 'upcoming-meetings', type: 'upcoming-meetings', title: 'Upcoming Meetings', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'documents',\n        label: 'Documents',\n        slug: 'documents',\n        icon: 'folder',\n        enabled: true,\n        order: 4,\n        widgets: [\n          { id: 'documents', type: 'documents', title: 'Shared Documents', enabled: true, order: 1 },\n        ],\n      },\n    ],\n  },\n  services: {\n    title: 'My Account',\n    showOverview: true,\n    tabs: [\n      {\n        id: 'bookings',\n        label: 'My Bookings',\n        slug: 'bookings',\n        icon: 'calendar-check',\n        enabled: true,\n        order: 1,\n        widgets: [\n          { id: 'upcoming-bookings', type: 'upcoming-bookings', title: 'Upcoming', enabled: true, order: 1 },\n          { id: 'booking-history', type: 'booking-history', title: 'History', enabled: true, order: 2 },\n        ],\n      },\n      {\n        id: 'services',\n        label: 'Book',\n        slug: 'book',\n        icon: 'plus-circle',\n        enabled: true,\n        order: 2,\n        widgets: [\n          { id: 'available-services', type: 'available-services', title: 'Book a Service', enabled: true, order: 1 },\n        ],\n      },\n    ],\n  },\n  booking: {\n    title: 'My Reservations',\n    showOverview: true,\n    tabs: [\n      {\n        id: 'reservations',\n        label: 'Reservations',\n        slug: 'reservations',\n        icon: 'calendar',\n        enabled: true,\n        order: 1,\n        widgets: [\n          { id: 'upcoming-bookings', type: 'upcoming-bookings', title: 'Upcoming', enabled: true, order: 1 },\n        ],\n      },\n    ],\n  },\n  saas: {\n    title: 'Dashboard',\n    showOverview: true,\n    tabs: [\n      {\n        id: 'usage',\n        label: 'Usage',\n        slug: 'usage',\n        icon: 'bar-chart',\n        enabled: true,\n        order: 1,\n        widgets: [\n          { id: 'usage-stats', type: 'usage-stats', title: 'Usage Statistics', enabled: true, order: 1 },\n        ],\n      },\n      {\n        id: 'billing',\n        label: 'Billing',\n        slug: 'billing',\n        icon: 'credit-card',\n        enabled: true,\n        order: 2,\n        widgets: [\n          { id: 'billing-summary', type: 'billing-summary', title: 'Billing', enabled: true, order: 1 },\n          { id: 'invoices', type: 'invoices', title: 'Invoices', enabled: true, order: 2 },\n        ],\n      },\n      {\n        id: 'api',\n        label: 'API',\n        slug: 'api',\n        icon: 'code',\n        enabled: true,\n        order: 3,\n        widgets: [\n          { id: 'api-keys', type: 'api-keys', title: 'API Keys', enabled: true, order: 1 },\n        ],\n      },\n    ],\n  },\n  custom: {\n    title: 'My Account',\n    showOverview: true,\n    tabs: [],\n  },\n};\n\n/**\n * Get default dashboard configuration for a preset\n */\nexport function getDefaultDashboardConfig(preset: DashboardPreset = 'ecommerce'): DashboardConfig {\n  const presetConfig = DASHBOARD_PRESETS[preset];\n  return {\n    preset,\n    title: presetConfig.title || 'My Account',\n    showOverview: presetConfig.showOverview ?? true,\n    tabs: presetConfig.tabs || [],\n    theme: {\n      borderRadius: 'md',\n      cardStyle: 'bordered',\n    },\n  };\n}\n","/**\n * Customer Dashboard Configuration\n *\n * Functions for managing configurable customer dashboards.\n * Configuration is stored in the settings table under the 'dashboard' group.\n */\n\nimport { prisma } from '../db';\nimport {\n  type DashboardConfig,\n  type DashboardPreset,\n  type DashboardTab,\n  type DashboardWidget,\n  getDefaultDashboardConfig,\n  DASHBOARD_PRESETS,\n} from './types';\n\n// Re-export types\nexport * from './types';\n\nconst DASHBOARD_SETTINGS_KEY = 'dashboard.config';\n\n/**\n * Get the current dashboard configuration\n */\nexport async function getDashboardConfig(): Promise<DashboardConfig> {\n  try {\n    const setting = await prisma.setting.findUnique({\n      where: { key: DASHBOARD_SETTINGS_KEY },\n    });\n\n    if (setting?.value) {\n      const config = JSON.parse(setting.value) as DashboardConfig;\n      // Merge with defaults to ensure new fields are present\n      return {\n        ...getDefaultDashboardConfig(config.preset),\n        ...config,\n      };\n    }\n  } catch (error) {\n    console.error('Error loading dashboard config:', error);\n  }\n\n  // Return default e-commerce config\n  return getDefaultDashboardConfig('ecommerce');\n}\n\n/**\n * Save dashboard configuration\n */\nexport async function saveDashboardConfig(config: Partial<DashboardConfig>): Promise<DashboardConfig> {\n  const currentConfig = await getDashboardConfig();\n  const newConfig: DashboardConfig = {\n    ...currentConfig,\n    ...config,\n  };\n\n  await prisma.setting.upsert({\n    where: { key: DASHBOARD_SETTINGS_KEY },\n    create: {\n      key: DASHBOARD_SETTINGS_KEY,\n      value: JSON.stringify(newConfig),\n      group: 'dashboard',\n      encrypted: false,\n    },\n    update: {\n      value: JSON.stringify(newConfig),\n    },\n  });\n\n  return newConfig;\n}\n\n/**\n * Apply a preset configuration\n */\nexport async function applyDashboardPreset(preset: DashboardPreset): Promise<DashboardConfig> {\n  const presetConfig = getDefaultDashboardConfig(preset);\n  return saveDashboardConfig(presetConfig);\n}\n\n/**\n * Enable or disable a tab\n */\nexport async function toggleTab(tabId: string, enabled: boolean): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  const tabIndex = config.tabs.findIndex((t) => t.id === tabId);\n\n  if (tabIndex >= 0) {\n    config.tabs[tabIndex].enabled = enabled;\n    return saveDashboardConfig(config);\n  }\n\n  return config;\n}\n\n/**\n * Add a new tab\n */\nexport async function addTab(tab: Omit<DashboardTab, 'order'>): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  const maxOrder = Math.max(...config.tabs.map((t) => t.order), 0);\n\n  config.tabs.push({\n    ...tab,\n    order: maxOrder + 1,\n  });\n\n  return saveDashboardConfig(config);\n}\n\n/**\n * Remove a tab\n */\nexport async function removeTab(tabId: string): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  config.tabs = config.tabs.filter((t) => t.id !== tabId);\n  return saveDashboardConfig(config);\n}\n\n/**\n * Reorder tabs\n */\nexport async function reorderTabs(tabIds: string[]): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n\n  config.tabs = tabIds\n    .map((id, index) => {\n      const tab = config.tabs.find((t) => t.id === id);\n      if (tab) {\n        return { ...tab, order: index + 1 };\n      }\n      return null;\n    })\n    .filter((t): t is DashboardTab => t !== null);\n\n  return saveDashboardConfig(config);\n}\n\n/**\n * Add a widget to a tab\n */\nexport async function addWidget(\n  tabId: string,\n  widget: Omit<DashboardWidget, 'order'>\n): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  const tabIndex = config.tabs.findIndex((t) => t.id === tabId);\n\n  if (tabIndex >= 0) {\n    const maxOrder = Math.max(...config.tabs[tabIndex].widgets.map((w) => w.order), 0);\n    config.tabs[tabIndex].widgets.push({\n      ...widget,\n      order: maxOrder + 1,\n    });\n    return saveDashboardConfig(config);\n  }\n\n  return config;\n}\n\n/**\n * Remove a widget from a tab\n */\nexport async function removeWidget(tabId: string, widgetId: string): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  const tabIndex = config.tabs.findIndex((t) => t.id === tabId);\n\n  if (tabIndex >= 0) {\n    config.tabs[tabIndex].widgets = config.tabs[tabIndex].widgets.filter(\n      (w) => w.id !== widgetId\n    );\n    return saveDashboardConfig(config);\n  }\n\n  return config;\n}\n\n/**\n * Toggle a widget's enabled state\n */\nexport async function toggleWidget(\n  tabId: string,\n  widgetId: string,\n  enabled: boolean\n): Promise<DashboardConfig> {\n  const config = await getDashboardConfig();\n  const tabIndex = config.tabs.findIndex((t) => t.id === tabId);\n\n  if (tabIndex >= 0) {\n    const widgetIndex = config.tabs[tabIndex].widgets.findIndex((w) => w.id === widgetId);\n    if (widgetIndex >= 0) {\n      config.tabs[tabIndex].widgets[widgetIndex].enabled = enabled;\n      return saveDashboardConfig(config);\n    }\n  }\n\n  return config;\n}\n\n/**\n * Get available presets with their descriptions\n */\nexport function getAvailablePresets(): Array<{\n  id: DashboardPreset;\n  name: string;\n  description: string;\n}> {\n  return [\n    {\n      id: 'ecommerce',\n      name: 'E-commerce',\n      description: 'Orders, shipping tracking, payment methods, addresses, and wishlist',\n    },\n    {\n      id: 'consulting',\n      name: 'Consulting / Agency',\n      description: 'Projects, milestones, invoices, meetings, and shared documents',\n    },\n    {\n      id: 'services',\n      name: 'Service Business',\n      description: 'Appointment booking, service history, and scheduling',\n    },\n    {\n      id: 'booking',\n      name: 'Reservations',\n      description: 'Simple booking and reservation management',\n    },\n    {\n      id: 'saas',\n      name: 'SaaS Platform',\n      description: 'Usage statistics, billing, subscriptions, and API keys',\n    },\n    {\n      id: 'custom',\n      name: 'Custom',\n      description: 'Start from scratch and build your own dashboard layout',\n    },\n  ];\n}\n","/**\n * Route Configuration Utilities\n *\n * Handles fetching and resolving route configurations.\n */\n\nimport { prisma } from '../db'\nimport { cache } from 'react'\n\nexport type { RouteType } from '@prisma/client'\n\nexport interface ResolvedRoute {\n  type: 'PUCK' | 'CUSTOM' | 'REDIRECT' | 'NOT_FOUND'\n  // For PUCK\n  pageId?: string\n  pageContent?: unknown\n  pageTitle?: string\n  pageSlug?: string\n  pageMetaTitle?: string | null\n  pageMetaDescription?: string | null\n  // For CUSTOM\n  componentKey?: string\n  // For REDIRECT\n  redirectUrl?: string\n  redirectCode?: number\n}\n\n/**\n * Get route configuration for a given slug\n * Cached per request using React cache\n */\nexport const getRouteConfig = cache(async (slug: string): Promise<ResolvedRoute> => {\n  // Normalize slug\n  const normalizedSlug = slug.startsWith('/') ? slug : `/${slug}`\n\n  const routeConfig = await prisma.routeConfig.findUnique({\n    where: { slug: normalizedSlug },\n    include: {\n      page: {\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n          status: true,\n          content: true,\n          metaTitle: true,\n          metaDescription: true,\n        },\n      },\n    },\n  })\n\n  if (!routeConfig || !routeConfig.isActive) {\n    return { type: 'NOT_FOUND' }\n  }\n\n  switch (routeConfig.type) {\n    case 'PUCK':\n      if (!routeConfig.page) {\n        return { type: 'NOT_FOUND' }\n      }\n      // Only show published pages\n      if (routeConfig.page.status !== 'PUBLISHED') {\n        return { type: 'NOT_FOUND' }\n      }\n      return {\n        type: 'PUCK',\n        pageId: routeConfig.page.id,\n        pageContent: routeConfig.page.content,\n        pageTitle: routeConfig.page.title,\n        pageSlug: routeConfig.page.slug,\n        pageMetaTitle: routeConfig.page.metaTitle,\n        pageMetaDescription: routeConfig.page.metaDescription,\n      }\n\n    case 'CUSTOM':\n      if (!routeConfig.componentKey) {\n        return { type: 'NOT_FOUND' }\n      }\n      return {\n        type: 'CUSTOM',\n        componentKey: routeConfig.componentKey,\n      }\n\n    case 'REDIRECT':\n      if (!routeConfig.redirectUrl) {\n        return { type: 'NOT_FOUND' }\n      }\n      return {\n        type: 'REDIRECT',\n        redirectUrl: routeConfig.redirectUrl,\n        redirectCode: routeConfig.redirectCode || 307,\n      }\n\n    default:\n      return { type: 'NOT_FOUND' }\n  }\n})\n\n/**\n * Check if a slug is reserved by a route config\n */\nexport async function isSlugReserved(slug: string): Promise<boolean> {\n  const normalizedSlug = slug.startsWith('/') ? slug : `/${slug}`\n\n  const existing = await prisma.routeConfig.findUnique({\n    where: { slug: normalizedSlug },\n    select: { id: true },\n  })\n\n  return !!existing\n}\n\n/**\n * Get all route configurations (for admin)\n */\nexport async function getAllRouteConfigs() {\n  return prisma.routeConfig.findMany({\n    include: {\n      page: {\n        select: {\n          id: true,\n          title: true,\n          slug: true,\n          status: true,\n        },\n      },\n    },\n    orderBy: { slug: 'asc' },\n  })\n}\n"]}