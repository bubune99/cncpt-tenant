{"version":3,"sources":["/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-72BQHJ6F.js","../src/hooks/use-auth.ts","../src/contexts/CMSConfigContext.tsx","../src/hooks/use-media-upload.ts"],"names":["useState"],"mappings":"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","file":"/mnt/c/Users/bubun/CascadeProjects/cncpt-tenant/packages/cms/dist/chunk-72BQHJ6F.js","sourcesContent":[null,"\"use client\";\n\nimport { useUser } from \"@stackframe/stack\";\nimport { useState, useEffect, useRef } from \"react\";\nimport { useRouter } from \"next/navigation\";\n\ninterface DbUser {\n  id: string;\n  stackAuthId: string;\n  email: string;\n  name: string | null;\n  role: string;\n}\n\nexport function useAuth() {\n  const stackUser = useUser();\n  const router = useRouter();\n  const [authChecked, setAuthChecked] = useState(false);\n  const [dbUser, setDbUser] = useState<DbUser | null>(null);\n  const [syncError, setSyncError] = useState<string | null>(null);\n  const syncAttemptedRef = useRef(false);\n\n  // Sync Stack Auth user to database\n  useEffect(() => {\n    if (stackUser && !syncAttemptedRef.current) {\n      syncAttemptedRef.current = true;\n\n      const syncUser = async () => {\n        try {\n          const response = await fetch(\"/api/auth/sync\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              stackAuthId: stackUser.id,\n              email: stackUser.primaryEmail,\n              name: stackUser.displayName,\n              avatar: stackUser.profileImageUrl,\n            }),\n          });\n\n          if (response.ok) {\n            const data = await response.json();\n            setDbUser(data.user);\n          } else {\n            const error = await response.json();\n            console.error(\"User sync failed:\", error);\n            setSyncError(error.error || \"Sync failed\");\n          }\n        } catch (error) {\n          console.error(\"User sync error:\", error);\n          setSyncError(\"Network error during sync\");\n        }\n      };\n\n      syncUser();\n    }\n  }, [stackUser]);\n\n  useEffect(() => {\n    if (stackUser !== undefined) {\n      setAuthChecked(true);\n    }\n    // Reset sync attempt when user changes\n    if (!stackUser) {\n      syncAttemptedRef.current = false;\n      setDbUser(null);\n      setSyncError(null);\n    }\n  }, [stackUser]);\n\n  return {\n    user: stackUser,\n    dbUser, // The synced database user with local ID\n    isLoading: stackUser === undefined,\n    isAuthenticated: !!stackUser,\n    authChecked,\n    syncError,\n    signOut: async () => {\n      try {\n        if (stackUser) {\n          await stackUser.signOut();\n        } else {\n          router.push('/handler/sign-out');\n        }\n      } catch (error) {\n        console.error('Sign out error:', error);\n        router.push('/handler/sign-out');\n      }\n    }\n  };\n}","'use client';\n\nimport { createContext, useContext, ReactNode } from 'react';\n\nexport interface CMSConfig {\n  /** Base path prefix for all admin routes (e.g., '/cms/subdomain') */\n  basePath?: string;\n  /** Navigation groups to hide entirely */\n  hiddenGroups?: string[];\n  /** Individual navigation items to hide by name */\n  hiddenItems?: string[];\n  /** URL for \"View Site\" link */\n  siteUrl?: string;\n  /** Site name to display */\n  siteName?: string;\n  /** User's role to display */\n  userRole?: string;\n  /** Whether to show the AI chat panel */\n  showChat?: boolean;\n}\n\ninterface CMSConfigContextValue {\n  basePath: string;\n  siteUrl: string;\n  siteName?: string;\n  userRole: string;\n  /** Build a path prefixed with the base path */\n  buildPath: (path: string) => string;\n  /** Build an API path prefixed for the current tenant */\n  buildApiPath: (path: string) => string;\n}\n\nconst CMSConfigContext = createContext<CMSConfigContextValue | null>(null);\n\nexport function CMSConfigProvider({\n  children,\n  config,\n}: {\n  children: ReactNode;\n  config: CMSConfig;\n}) {\n  const basePath = config.basePath || '';\n  const siteUrl = config.siteUrl || '/';\n  const siteName = config.siteName;\n  const userRole = config.userRole || 'Super Admin';\n\n  // Helper to prefix paths with basePath\n  const buildPath = (path: string): string => {\n    if (!basePath) return path;\n    // Replace /admin with basePath/admin\n    return path.replace('/admin', `${basePath}/admin`);\n  };\n\n  // Helper to build API paths for multi-tenant\n  // E.g., /api/admin/stats -> /api/cms/subdomain/admin/stats\n  const buildApiPath = (path: string): string => {\n    // For now, API paths remain unchanged\n    // In multi-tenant setup, the API routes would also be namespaced\n    return path;\n  };\n\n  return (\n    <CMSConfigContext.Provider\n      value={{\n        basePath,\n        siteUrl,\n        siteName,\n        userRole,\n        buildPath,\n        buildApiPath,\n      }}\n    >\n      {children}\n    </CMSConfigContext.Provider>\n  );\n}\n\nexport function useCMSConfig(): CMSConfigContextValue {\n  const context = useContext(CMSConfigContext);\n  if (!context) {\n    // Return defaults when not in a CMS context (standalone CMS)\n    return {\n      basePath: '',\n      siteUrl: '/',\n      userRole: 'Super Admin',\n      buildPath: (path) => path,\n      buildApiPath: (path) => path,\n    };\n  }\n  return context;\n}\n","'use client'\n\nimport { useState, useCallback } from 'react'\nimport type { UploadProgress } from '../lib/media/types'\n\ninterface UseMediaUploadOptions {\n  folderId?: string | null\n  onSuccess?: (media: any) => void\n  onError?: (error: string) => void\n}\n\nexport function useMediaUpload(options: UseMediaUploadOptions = {}) {\n  const [uploads, setUploads] = useState<Map<string, UploadProgress>>(new Map())\n  const [isUploading, setIsUploading] = useState(false)\n\n  const updateUpload = useCallback((id: string, updates: Partial<UploadProgress>) => {\n    setUploads((prev) => {\n      const newMap = new Map(prev)\n      const current = newMap.get(id)\n      if (current) {\n        newMap.set(id, { ...current, ...updates })\n      }\n      return newMap\n    })\n  }, [])\n\n  const uploadFile = useCallback(\n    async (file: File): Promise<any> => {\n      const uploadId = `${file.name}-${Date.now()}`\n\n      // Add to uploads\n      setUploads((prev) => {\n        const newMap = new Map(prev)\n        newMap.set(uploadId, {\n          id: uploadId,\n          filename: file.name,\n          progress: 0,\n          status: 'pending',\n          size: file.size,\n        })\n        return newMap\n      })\n\n      try {\n        updateUpload(uploadId, { status: 'uploading', progress: 10 })\n\n        // Step 1: Get presigned URL\n        const presignResponse = await fetch('/api/media', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            action: 'presign',\n            filename: file.name,\n            mimeType: file.type,\n            size: file.size,\n          }),\n        })\n\n        if (!presignResponse.ok) {\n          const error = await presignResponse.json()\n          throw new Error(error.error || 'Failed to get upload URL')\n        }\n\n        const presignData = await presignResponse.json()\n        updateUpload(uploadId, { progress: 30 })\n\n        // Step 2: Upload to storage\n        const uploadResponse = await fetch(presignData.uploadUrl, {\n          method: 'PUT',\n          body: file,\n          headers: {\n            'Content-Type': file.type,\n          },\n        })\n\n        if (!uploadResponse.ok) {\n          throw new Error('Failed to upload file')\n        }\n\n        updateUpload(uploadId, { progress: 70 })\n\n        // Step 3: Create media record\n        const completeResponse = await fetch('/api/media', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            action: 'complete',\n            filename: presignData.key.split('/').pop(),\n            originalName: file.name,\n            mimeType: file.type,\n            size: file.size,\n            url: presignData.publicUrl,\n            key: presignData.key,\n            bucket: presignData.bucket,\n            provider: presignData.provider,\n            folderId: options.folderId,\n          }),\n        })\n\n        if (!completeResponse.ok) {\n          const error = await completeResponse.json()\n          throw new Error(error.error || 'Failed to create media record')\n        }\n\n        const media = await completeResponse.json()\n\n        updateUpload(uploadId, {\n          status: 'complete',\n          progress: 100,\n          url: media.url,\n        })\n\n        options.onSuccess?.(media)\n        return media\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'Upload failed'\n        updateUpload(uploadId, {\n          status: 'error',\n          error: message,\n        })\n        options.onError?.(message)\n        throw error\n      }\n    },\n    [options, updateUpload]\n  )\n\n  const uploadFiles = useCallback(\n    async (files: FileList | File[]) => {\n      setIsUploading(true)\n\n      const fileArray = Array.from(files)\n      const results: any[] = []\n\n      for (const file of fileArray) {\n        try {\n          const media = await uploadFile(file)\n          results.push(media)\n        } catch (error) {\n          // Continue with other files\n        }\n      }\n\n      setIsUploading(false)\n      return results\n    },\n    [uploadFile]\n  )\n\n  const clearCompleted = useCallback(() => {\n    setUploads((prev) => {\n      const newMap = new Map(prev)\n      for (const [id, upload] of newMap) {\n        if (upload.status === 'complete' || upload.status === 'error') {\n          newMap.delete(id)\n        }\n      }\n      return newMap\n    })\n  }, [])\n\n  const clearAll = useCallback(() => {\n    setUploads(new Map())\n  }, [])\n\n  return {\n    uploads: Array.from(uploads.values()),\n    isUploading,\n    uploadFile,\n    uploadFiles,\n    clearCompleted,\n    clearAll,\n  }\n}\n"]}