{"version":3,"sources":["../src/lib/email/providers/smtp.ts","../src/lib/email/providers/sendgrid.ts","../src/lib/email/providers/resend.ts","../src/lib/email/providers/mailgun.ts","../src/lib/email/providers/ses.ts","../src/lib/email/merge-tags.ts","../src/lib/encryption/index.ts","../src/lib/settings/types.ts","../src/lib/settings/index.ts","../src/lib/email/tracking.ts","../src/lib/email/webhooks.ts","../src/lib/email/subscriptions.ts","../src/lib/email/queue.ts","../src/lib/email/index.ts"],"sourcesContent":["/**\n * SMTP Email Provider\n *\n * Uses nodemailer for SMTP email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SmtpConfig,\n  EmailAddress,\n} from '../types'\n\n// We'll use dynamic import for nodemailer to avoid issues if not installed\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet nodemailer: any = null\n\nasync function getNodemailer() {\n  if (!nodemailer) {\n    try {\n      nodemailer = await import('nodemailer')\n    } catch {\n      throw new Error('nodemailer is not installed. Run: npm install nodemailer')\n    }\n  }\n  return nodemailer\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `\"${addr.name}\" <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress).join(', ')\n}\n\nexport class SmtpProvider implements IEmailProvider {\n  readonly name = 'smtp' as const\n  private config: SmtpConfig\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private transporter: any = null\n\n  constructor(config: SmtpConfig) {\n    this.config = config\n  }\n\n  private async getTransporter() {\n    if (this.transporter) return this.transporter\n\n    const nm = await getNodemailer()\n    this.transporter = nm.createTransport({\n      host: this.config.host,\n      port: this.config.port,\n      secure: this.config.secure ?? this.config.port === 465,\n      auth: this.config.user\n        ? {\n            user: this.config.user,\n            pass: this.config.pass,\n          }\n        : undefined,\n      pool: this.config.pool ?? true,\n      maxConnections: this.config.maxConnections ?? 5,\n    })\n\n    return this.transporter\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    try {\n      const transporter = await this.getTransporter()\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const mailOptions: any = {\n        from: message.from ? formatAddress(message.from) : undefined,\n        to: formatAddresses(message.to),\n        subject: message.subject,\n        text: message.text,\n        html: message.html,\n        replyTo: message.replyTo ? formatAddress(message.replyTo) : undefined,\n        cc: message.cc ? formatAddresses(message.cc) : undefined,\n        bcc: message.bcc ? formatAddresses(message.bcc) : undefined,\n        headers: message.headers,\n        attachments: message.attachments?.map((att) => ({\n          filename: att.filename,\n          content: att.content,\n          contentType: att.contentType,\n          encoding: att.encoding as BufferEncoding | undefined,\n          cid: att.cid,\n        })),\n      }\n\n      const result = await transporter.sendMail(mailOptions)\n\n      return {\n        success: true,\n        messageId: result.messageId,\n        provider: 'smtp',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'smtp',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    // SMTP doesn't support true bulk sending, so we send individually\n    for (const recipient of message.recipients) {\n      const result = await this.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: 'smtp',\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const transporter = await this.getTransporter()\n      await transporter.verify()\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.transporter) {\n      this.transporter.close()\n      this.transporter = null\n    }\n  }\n}\n","/**\n * SendGrid Email Provider\n *\n * Uses SendGrid API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SendGridConfig,\n  EmailAddress,\n} from '../types'\n\ninterface SendGridMailContent {\n  type: string\n  value: string\n}\n\ninterface SendGridPersonalization {\n  to: Array<{ email: string; name?: string }>\n  cc?: Array<{ email: string; name?: string }>\n  bcc?: Array<{ email: string; name?: string }>\n  subject?: string\n  substitutions?: Record<string, string>\n  custom_args?: Record<string, string>\n}\n\ninterface SendGridMailRequest {\n  personalizations: SendGridPersonalization[]\n  from: { email: string; name?: string }\n  reply_to?: { email: string; name?: string }\n  subject: string\n  content: SendGridMailContent[]\n  attachments?: Array<{\n    content: string\n    filename: string\n    type?: string\n    disposition?: string\n    content_id?: string\n  }>\n  headers?: Record<string, string>\n  categories?: string[]\n  custom_args?: Record<string, string>\n  mail_settings?: {\n    sandbox_mode?: { enable: boolean }\n  }\n  tracking_settings?: {\n    click_tracking?: { enable: boolean }\n    open_tracking?: { enable: boolean }\n  }\n}\n\nfunction toSendGridAddress(addr: EmailAddress): { email: string; name?: string } {\n  return { email: addr.email, name: addr.name }\n}\n\nfunction toSendGridAddresses(addrs: EmailAddress | EmailAddress[]): Array<{ email: string; name?: string }> {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(toSendGridAddress)\n}\n\nexport class SendGridProvider implements IEmailProvider {\n  readonly name = 'sendgrid' as const\n  private config: SendGridConfig\n\n  constructor(config: SendGridConfig) {\n    this.config = config\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'sendgrid',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const personalization: SendGridPersonalization = {\n        to: toSendGridAddresses(message.to),\n      }\n\n      if (message.cc) {\n        personalization.cc = toSendGridAddresses(message.cc)\n      }\n      if (message.bcc) {\n        personalization.bcc = toSendGridAddresses(message.bcc)\n      }\n      if (message.metadata) {\n        personalization.custom_args = message.metadata\n      }\n\n      const content: SendGridMailContent[] = []\n      if (message.text) {\n        content.push({ type: 'text/plain', value: message.text })\n      }\n      if (message.html) {\n        content.push({ type: 'text/html', value: message.html })\n      }\n\n      const request: SendGridMailRequest = {\n        personalizations: [personalization],\n        from: toSendGridAddress(message.from),\n        subject: message.subject,\n        content,\n      }\n\n      if (message.replyTo) {\n        request.reply_to = toSendGridAddress(message.replyTo)\n      }\n\n      if (message.headers) {\n        request.headers = message.headers\n      }\n\n      if (message.tags) {\n        request.categories = message.tags\n      }\n\n      if (message.attachments) {\n        request.attachments = message.attachments.map((att) => ({\n          content: typeof att.content === 'string' ? att.content : att.content.toString('base64'),\n          filename: att.filename,\n          type: att.contentType,\n          content_id: att.cid,\n        }))\n      }\n\n      // Tracking settings\n      request.tracking_settings = {\n        click_tracking: { enable: message.trackClicks ?? true },\n        open_tracking: { enable: message.trackOpens ?? true },\n      }\n\n      if (this.config.sandboxMode) {\n        request.mail_settings = { sandbox_mode: { enable: true } }\n      }\n\n      // Campaign attribution\n      if (message.campaignId || message.recipientId) {\n        request.custom_args = {\n          ...request.custom_args,\n          ...(message.campaignId && { campaign_id: message.campaignId }),\n          ...(message.recipientId && { recipient_id: message.recipientId }),\n        }\n      }\n\n      const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      })\n\n      if (!response.ok) {\n        const errorBody = await response.text()\n        return {\n          success: false,\n          provider: 'sendgrid',\n          error: `SendGrid API error: ${response.status} - ${errorBody}`,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n        }\n      }\n\n      const messageId = response.headers.get('x-message-id') || undefined\n\n      return {\n        success: true,\n        messageId,\n        provider: 'sendgrid',\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'sendgrid',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'sendgrid',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // SendGrid supports up to 1000 personalizations per request\n      const batchSize = 1000\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const personalizations: SendGridPersonalization[] = batch.map((recipient) => ({\n          to: [toSendGridAddress(recipient.to)],\n          substitutions: recipient.substitutions,\n          custom_args: recipient.metadata,\n        }))\n\n        const content: SendGridMailContent[] = []\n        if (message.text) {\n          content.push({ type: 'text/plain', value: message.text })\n        }\n        if (message.html) {\n          content.push({ type: 'text/html', value: message.html })\n        }\n\n        const request: SendGridMailRequest = {\n          personalizations,\n          from: toSendGridAddress(message.from),\n          subject: message.subject,\n          content,\n          tracking_settings: {\n            click_tracking: { enable: message.trackClicks ?? true },\n            open_tracking: { enable: message.trackOpens ?? true },\n          },\n        }\n\n        if (message.replyTo) {\n          request.reply_to = toSendGridAddress(message.replyTo)\n        }\n\n        if (this.config.sandboxMode) {\n          request.mail_settings = { sandbox_mode: { enable: true } }\n        }\n\n        const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${this.config.apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(request),\n        })\n\n        if (response.ok) {\n          const messageId = response.headers.get('x-message-id') || undefined\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: true,\n              messageId,\n            })\n            totalSent++\n          }\n        } else {\n          const errorBody = await response.text()\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: `SendGrid API error: ${response.status} - ${errorBody}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'sendgrid',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'sendgrid',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      // Verify by checking API key validity\n      const response = await fetch('https://api.sendgrid.com/v3/user/profile', {\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Resend Email Provider\n *\n * Uses Resend API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  ResendConfig,\n  EmailAddress,\n} from '../types'\n\ninterface ResendEmailRequest {\n  from: string\n  to: string | string[]\n  subject: string\n  html?: string\n  text?: string\n  cc?: string | string[]\n  bcc?: string | string[]\n  reply_to?: string | string[]\n  headers?: Record<string, string>\n  attachments?: Array<{\n    filename: string\n    content: string\n  }>\n  tags?: Array<{\n    name: string\n    value: string\n  }>\n}\n\ninterface ResendBatchRequest {\n  from: string\n  to: string[]\n  subject: string\n  html?: string\n  text?: string\n  reply_to?: string\n  tags?: Array<{\n    name: string\n    value: string\n  }>\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string[] {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress)\n}\n\nexport class ResendProvider implements IEmailProvider {\n  readonly name = 'resend' as const\n  private config: ResendConfig\n\n  constructor(config: ResendConfig) {\n    this.config = config\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'resend',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const request: ResendEmailRequest = {\n        from: formatAddress(message.from),\n        to: formatAddresses(message.to),\n        subject: message.subject,\n        html: message.html,\n        text: message.text,\n      }\n\n      if (message.cc) {\n        request.cc = formatAddresses(message.cc)\n      }\n      if (message.bcc) {\n        request.bcc = formatAddresses(message.bcc)\n      }\n      if (message.replyTo) {\n        request.reply_to = formatAddress(message.replyTo)\n      }\n      if (message.headers) {\n        request.headers = message.headers\n      }\n\n      if (message.attachments) {\n        request.attachments = message.attachments.map((att) => ({\n          filename: att.filename,\n          content: typeof att.content === 'string' ? att.content : att.content.toString('base64'),\n        }))\n      }\n\n      // Add tags for tracking\n      const tags: Array<{ name: string; value: string }> = []\n      if (message.campaignId) {\n        tags.push({ name: 'campaign_id', value: message.campaignId })\n      }\n      if (message.recipientId) {\n        tags.push({ name: 'recipient_id', value: message.recipientId })\n      }\n      if (message.tags) {\n        message.tags.forEach((tag) => {\n          tags.push({ name: 'tag', value: tag })\n        })\n      }\n      if (tags.length > 0) {\n        request.tags = tags\n      }\n\n      const response = await fetch('https://api.resend.com/emails', {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      })\n\n      const result = await response.json()\n\n      if (!response.ok) {\n        return {\n          success: false,\n          provider: 'resend',\n          error: result.message || `Resend API error: ${response.status}`,\n          errorCode: result.name,\n          timestamp: new Date(),\n          raw: result,\n        }\n      }\n\n      return {\n        success: true,\n        messageId: result.id,\n        provider: 'resend',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'resend',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'resend',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Resend's batch API supports up to 100 emails per request\n      const batchSize = 100\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const batchRequests: ResendBatchRequest[] = batch.map((recipient) => ({\n          from: formatAddress(message.from!),\n          to: [formatAddress(recipient.to)],\n          subject: message.subject,\n          html: message.html,\n          text: message.text,\n          reply_to: message.replyTo ? formatAddress(message.replyTo) : undefined,\n          tags: [\n            ...(message.campaignId ? [{ name: 'campaign_id', value: message.campaignId }] : []),\n            ...(recipient.metadata?.recipientId\n              ? [{ name: 'recipient_id', value: recipient.metadata.recipientId }]\n              : []),\n          ],\n        }))\n\n        const response = await fetch('https://api.resend.com/emails/batch', {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${this.config.apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(batchRequests),\n        })\n\n        const result = await response.json()\n\n        if (response.ok && Array.isArray(result.data)) {\n          for (let j = 0; j < batch.length; j++) {\n            const itemResult = result.data[j]\n            if (itemResult?.id) {\n              allResults.push({\n                email: batch[j].to.email,\n                success: true,\n                messageId: itemResult.id,\n              })\n              totalSent++\n            } else {\n              allResults.push({\n                email: batch[j].to.email,\n                success: false,\n                error: itemResult?.message || 'Unknown error',\n              })\n              totalFailed++\n            }\n          }\n        } else {\n          // Batch failed\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: result.message || `Resend API error: ${response.status}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'resend',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'resend',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const response = await fetch('https://api.resend.com/domains', {\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Mailgun Email Provider\n *\n * Uses Mailgun API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  MailgunConfig,\n  EmailAddress,\n} from '../types'\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress).join(', ')\n}\n\nexport class MailgunProvider implements IEmailProvider {\n  readonly name = 'mailgun' as const\n  private config: MailgunConfig\n  private baseUrl: string\n\n  constructor(config: MailgunConfig) {\n    this.config = config\n    this.baseUrl =\n      config.region === 'eu'\n        ? `https://api.eu.mailgun.net/v3/${config.domain}`\n        : `https://api.mailgun.net/v3/${config.domain}`\n  }\n\n  private getAuthHeader(): string {\n    return 'Basic ' + Buffer.from(`api:${this.config.apiKey}`).toString('base64')\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'mailgun',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      const formData = new FormData()\n      formData.append('from', formatAddress(message.from))\n      formData.append('to', formatAddresses(message.to))\n      formData.append('subject', message.subject)\n\n      if (message.text) {\n        formData.append('text', message.text)\n      }\n      if (message.html) {\n        formData.append('html', message.html)\n      }\n      if (message.cc) {\n        formData.append('cc', formatAddresses(message.cc))\n      }\n      if (message.bcc) {\n        formData.append('bcc', formatAddresses(message.bcc))\n      }\n      if (message.replyTo) {\n        formData.append('h:Reply-To', formatAddress(message.replyTo))\n      }\n\n      // Add custom headers\n      if (message.headers) {\n        for (const [key, value] of Object.entries(message.headers)) {\n          formData.append(`h:${key}`, value)\n        }\n      }\n\n      // Add tags\n      if (message.tags) {\n        for (const tag of message.tags) {\n          formData.append('o:tag', tag)\n        }\n      }\n\n      // Tracking options\n      formData.append('o:tracking', 'yes')\n      formData.append('o:tracking-clicks', message.trackClicks !== false ? 'yes' : 'no')\n      formData.append('o:tracking-opens', message.trackOpens !== false ? 'yes' : 'no')\n\n      // Campaign attribution\n      if (message.campaignId) {\n        formData.append('v:campaign_id', message.campaignId)\n      }\n      if (message.recipientId) {\n        formData.append('v:recipient_id', message.recipientId)\n      }\n\n      // Add metadata as custom variables\n      if (message.metadata) {\n        for (const [key, value] of Object.entries(message.metadata)) {\n          formData.append(`v:${key}`, value)\n        }\n      }\n\n      // Add attachments\n      if (message.attachments) {\n        for (const att of message.attachments) {\n          let content: string\n          if (typeof att.content === 'string') {\n            content = att.content\n          } else {\n            content = att.content.toString('base64')\n          }\n          // Use base64 encoded content directly\n          const blob = new Blob([Buffer.from(content, 'base64')], { type: att.contentType || 'application/octet-stream' })\n          if (att.cid) {\n            formData.append('inline', blob, att.filename)\n          } else {\n            formData.append('attachment', blob, att.filename)\n          }\n        }\n      }\n\n      const response = await fetch(`${this.baseUrl}/messages`, {\n        method: 'POST',\n        headers: {\n          Authorization: this.getAuthHeader(),\n        },\n        body: formData,\n      })\n\n      const result = await response.json()\n\n      if (!response.ok) {\n        return {\n          success: false,\n          provider: 'mailgun',\n          error: result.message || `Mailgun API error: ${response.status}`,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n          raw: result,\n        }\n      }\n\n      return {\n        success: true,\n        messageId: result.id,\n        provider: 'mailgun',\n        timestamp: new Date(),\n        raw: result,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'mailgun',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'mailgun',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: 'From address is required',\n        })),\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Mailgun supports batch sending with recipient variables\n      // Maximum 1000 recipients per batch\n      const batchSize = 1000\n      const allResults: BulkEmailResult['results'] = []\n      let totalSent = 0\n      let totalFailed = 0\n\n      for (let i = 0; i < message.recipients.length; i += batchSize) {\n        const batch = message.recipients.slice(i, i + batchSize)\n\n        const formData = new FormData()\n        formData.append('from', formatAddress(message.from))\n        formData.append('to', batch.map((r) => formatAddress(r.to)).join(', '))\n        formData.append('subject', message.subject)\n\n        if (message.text) {\n          formData.append('text', message.text)\n        }\n        if (message.html) {\n          formData.append('html', message.html)\n        }\n        if (message.replyTo) {\n          formData.append('h:Reply-To', formatAddress(message.replyTo))\n        }\n\n        // Tracking\n        formData.append('o:tracking', 'yes')\n        formData.append('o:tracking-clicks', message.trackClicks !== false ? 'yes' : 'no')\n        formData.append('o:tracking-opens', message.trackOpens !== false ? 'yes' : 'no')\n\n        // Add recipient variables for substitutions\n        const recipientVariables: Record<string, Record<string, string>> = {}\n        for (const recipient of batch) {\n          recipientVariables[recipient.to.email] = {\n            ...recipient.substitutions,\n            ...recipient.metadata,\n          }\n        }\n        formData.append('recipient-variables', JSON.stringify(recipientVariables))\n\n        const response = await fetch(`${this.baseUrl}/messages`, {\n          method: 'POST',\n          headers: {\n            Authorization: this.getAuthHeader(),\n          },\n          body: formData,\n        })\n\n        const result = await response.json()\n\n        if (response.ok) {\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: true,\n              messageId: result.id,\n            })\n            totalSent++\n          }\n        } else {\n          for (const recipient of batch) {\n            allResults.push({\n              email: recipient.to.email,\n              success: false,\n              error: result.message || `Mailgun API error: ${response.status}`,\n            })\n            totalFailed++\n          }\n        }\n      }\n\n      return {\n        success: totalFailed === 0,\n        provider: 'mailgun',\n        totalSent,\n        totalFailed,\n        results: allResults,\n        timestamp: new Date(),\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'mailgun',\n        totalSent: 0,\n        totalFailed: message.recipients.length,\n        results: message.recipients.map((r) => ({\n          email: r.to.email,\n          success: false,\n          error: err.message,\n        })),\n        timestamp: new Date(),\n      }\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}`, {\n        headers: {\n          Authorization: this.getAuthHeader(),\n        },\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * AWS SES Email Provider\n *\n * Uses AWS SES API for email delivery\n */\n\nimport type {\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  SesConfig,\n  EmailAddress,\n} from '../types'\n\n// Simple AWS4 signature for SES\n// In production, you'd use @aws-sdk/client-ses\nasync function signRequest(\n  config: SesConfig,\n  method: string,\n  url: string,\n  body: string,\n  headers: Record<string, string>\n): Promise<Record<string, string>> {\n  const now = new Date()\n  const amzDate = now.toISOString().replace(/[:-]|\\.\\d{3}/g, '')\n  const dateStamp = amzDate.slice(0, 8)\n\n  const host = new URL(url).host\n  const service = 'ses'\n\n  // Create canonical request\n  const signedHeaders = 'content-type;host;x-amz-date'\n  const canonicalHeaders = `content-type:${headers['Content-Type']}\\nhost:${host}\\nx-amz-date:${amzDate}\\n`\n\n  const encoder = new TextEncoder()\n  const payloadHash = await crypto.subtle.digest('SHA-256', encoder.encode(body))\n  const payloadHashHex = Array.from(new Uint8Array(payloadHash))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const canonicalRequest = `${method}\\n/\\n\\n${canonicalHeaders}\\n${signedHeaders}\\n${payloadHashHex}`\n\n  const credentialScope = `${dateStamp}/${config.region}/${service}/aws4_request`\n  const canonicalRequestHash = await crypto.subtle.digest('SHA-256', encoder.encode(canonicalRequest))\n  const canonicalRequestHashHex = Array.from(new Uint8Array(canonicalRequestHash))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const stringToSign = `AWS4-HMAC-SHA256\\n${amzDate}\\n${credentialScope}\\n${canonicalRequestHashHex}`\n\n  // Calculate signature\n  async function hmac(key: ArrayBuffer | string, data: string): Promise<ArrayBuffer> {\n    const keyData = typeof key === 'string' ? encoder.encode(key) : key\n    const cryptoKey = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign'])\n    return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(data))\n  }\n\n  const kDate = await hmac(`AWS4${config.secretAccessKey}`, dateStamp)\n  const kRegion = await hmac(kDate, config.region)\n  const kService = await hmac(kRegion, service)\n  const kSigning = await hmac(kService, 'aws4_request')\n  const signature = await hmac(kSigning, stringToSign)\n  const signatureHex = Array.from(new Uint8Array(signature))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')\n\n  const authorizationHeader = `AWS4-HMAC-SHA256 Credential=${config.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signatureHex}`\n\n  return {\n    ...headers,\n    'X-Amz-Date': amzDate,\n    Authorization: authorizationHeader,\n  }\n}\n\nfunction formatAddress(addr: EmailAddress): string {\n  return addr.name ? `${addr.name} <${addr.email}>` : addr.email\n}\n\nfunction formatAddresses(addrs: EmailAddress | EmailAddress[]): string[] {\n  const arr = Array.isArray(addrs) ? addrs : [addrs]\n  return arr.map(formatAddress)\n}\n\nexport class SesProvider implements IEmailProvider {\n  readonly name = 'ses' as const\n  private config: SesConfig\n  private endpoint: string\n\n  constructor(config: SesConfig) {\n    this.config = config\n    this.endpoint = `https://email.${config.region}.amazonaws.com`\n  }\n\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    if (!message.from) {\n      return {\n        success: false,\n        provider: 'ses',\n        error: 'From address is required',\n        timestamp: new Date(),\n      }\n    }\n\n    try {\n      // Build the SES SendEmail parameters\n      const params = new URLSearchParams()\n      params.append('Action', 'SendEmail')\n      params.append('Version', '2010-12-01')\n      params.append('Source', formatAddress(message.from))\n\n      // To addresses\n      const toAddrs = Array.isArray(message.to) ? message.to : [message.to]\n      toAddrs.forEach((addr, i) => {\n        params.append(`Destination.ToAddresses.member.${i + 1}`, formatAddress(addr))\n      })\n\n      // CC addresses\n      if (message.cc) {\n        const ccAddrs = Array.isArray(message.cc) ? message.cc : [message.cc]\n        ccAddrs.forEach((addr, i) => {\n          params.append(`Destination.CcAddresses.member.${i + 1}`, formatAddress(addr))\n        })\n      }\n\n      // BCC addresses\n      if (message.bcc) {\n        const bccAddrs = Array.isArray(message.bcc) ? message.bcc : [message.bcc]\n        bccAddrs.forEach((addr, i) => {\n          params.append(`Destination.BccAddresses.member.${i + 1}`, formatAddress(addr))\n        })\n      }\n\n      // Subject\n      params.append('Message.Subject.Data', message.subject)\n      params.append('Message.Subject.Charset', 'UTF-8')\n\n      // Body\n      if (message.text) {\n        params.append('Message.Body.Text.Data', message.text)\n        params.append('Message.Body.Text.Charset', 'UTF-8')\n      }\n      if (message.html) {\n        params.append('Message.Body.Html.Data', message.html)\n        params.append('Message.Body.Html.Charset', 'UTF-8')\n      }\n\n      // Reply-To\n      if (message.replyTo) {\n        params.append('ReplyToAddresses.member.1', formatAddress(message.replyTo))\n      }\n\n      // Tags for tracking\n      let tagIndex = 1\n      if (message.campaignId) {\n        params.append(`Tags.member.${tagIndex}.Name`, 'campaign_id')\n        params.append(`Tags.member.${tagIndex}.Value`, message.campaignId)\n        tagIndex++\n      }\n      if (message.recipientId) {\n        params.append(`Tags.member.${tagIndex}.Name`, 'recipient_id')\n        params.append(`Tags.member.${tagIndex}.Value`, message.recipientId)\n        tagIndex++\n      }\n      if (message.tags) {\n        for (const tag of message.tags) {\n          params.append(`Tags.member.${tagIndex}.Name`, 'tag')\n          params.append(`Tags.member.${tagIndex}.Value`, tag)\n          tagIndex++\n        }\n      }\n\n      const body = params.toString()\n      const headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      }\n\n      const signedHeaders = await signRequest(this.config, 'POST', this.endpoint, body, headers)\n\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: signedHeaders,\n        body,\n      })\n\n      const responseText = await response.text()\n\n      if (!response.ok) {\n        // Parse XML error response\n        const errorMatch = responseText.match(/<Message>([^<]+)<\\/Message>/)\n        const errorMessage = errorMatch ? errorMatch[1] : `SES API error: ${response.status}`\n        return {\n          success: false,\n          provider: 'ses',\n          error: errorMessage,\n          errorCode: response.status.toString(),\n          timestamp: new Date(),\n          raw: responseText,\n        }\n      }\n\n      // Parse message ID from response\n      const messageIdMatch = responseText.match(/<MessageId>([^<]+)<\\/MessageId>/)\n      const messageId = messageIdMatch ? messageIdMatch[1] : undefined\n\n      return {\n        success: true,\n        messageId,\n        provider: 'ses',\n        timestamp: new Date(),\n        raw: responseText,\n      }\n    } catch (error) {\n      const err = error as Error\n      return {\n        success: false,\n        provider: 'ses',\n        error: err.message,\n        timestamp: new Date(),\n        raw: error,\n      }\n    }\n  }\n\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    // SES doesn't have true bulk sending in the simple API\n    // For bulk, you'd use SendBulkTemplatedEmail which requires SES templates\n    // For now, we send individually\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const result = await this.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n\n      // Basic rate limiting for SES (14 emails/second for sandbox)\n      await new Promise((resolve) => setTimeout(resolve, 100))\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: 'ses',\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  async verify(): Promise<boolean> {\n    try {\n      const params = new URLSearchParams()\n      params.append('Action', 'GetSendQuota')\n      params.append('Version', '2010-12-01')\n\n      const body = params.toString()\n      const headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      }\n\n      const signedHeaders = await signRequest(this.config, 'POST', this.endpoint, body, headers)\n\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: signedHeaders,\n        body,\n      })\n\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n}\n","/**\n * Merge Tag Parser\n *\n * Handles Mailchimp-style merge tags for email personalization\n *\n * Supported formats:\n * - {{FNAME}} - Simple variable\n * - {{subscriber.firstName}} - Nested path\n * - {{product.name|default:\"Product\"}} - With default value\n * - {{order.total|currency}} - With formatter\n * - {{#if hasOrders}}...{{/if}} - Conditional blocks\n * - {{#each products}}...{{/each}} - Loops\n */\n\nexport interface MergeTagData {\n  [key: string]: string | number | boolean | null | undefined | MergeTagData | MergeTagData[]\n}\n\n// Built-in formatters\nconst formatters: Record<string, (value: unknown, ...args: string[]) => string> = {\n  // Default value if empty/undefined\n  default: (value, defaultValue = '') => {\n    if (value === null || value === undefined || value === '') {\n      return defaultValue\n    }\n    return String(value)\n  },\n\n  // Currency formatting\n  currency: (value, currency = 'USD', locale = 'en-US') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return new Intl.NumberFormat(locale, {\n      style: 'currency',\n      currency,\n    }).format(num / 100) // Assuming cents\n  },\n\n  // Date formatting\n  date: (value, format = 'short', locale = 'en-US') => {\n    const date = value instanceof Date ? value : new Date(String(value))\n    if (isNaN(date.getTime())) return String(value)\n\n    const options: Intl.DateTimeFormatOptions = {}\n    switch (format) {\n      case 'short':\n        options.dateStyle = 'short'\n        break\n      case 'medium':\n        options.dateStyle = 'medium'\n        break\n      case 'long':\n        options.dateStyle = 'long'\n        break\n      case 'full':\n        options.dateStyle = 'full'\n        break\n      default:\n        options.dateStyle = 'short'\n    }\n    return new Intl.DateTimeFormat(locale, options).format(date)\n  },\n\n  // Time formatting\n  time: (value, format = 'short', locale = 'en-US') => {\n    const date = value instanceof Date ? value : new Date(String(value))\n    if (isNaN(date.getTime())) return String(value)\n\n    const options: Intl.DateTimeFormatOptions = {}\n    switch (format) {\n      case 'short':\n        options.timeStyle = 'short'\n        break\n      case 'medium':\n        options.timeStyle = 'medium'\n        break\n      case 'long':\n        options.timeStyle = 'long'\n        break\n      default:\n        options.timeStyle = 'short'\n    }\n    return new Intl.DateTimeFormat(locale, options).format(date)\n  },\n\n  // Number formatting\n  number: (value, locale = 'en-US') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return new Intl.NumberFormat(locale).format(num)\n  },\n\n  // Percent formatting\n  percent: (value, decimals = '0') => {\n    const num = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(num)) return String(value)\n    return `${(num * 100).toFixed(parseInt(decimals))}%`\n  },\n\n  // Uppercase\n  upper: (value) => String(value).toUpperCase(),\n\n  // Lowercase\n  lower: (value) => String(value).toLowerCase(),\n\n  // Capitalize first letter\n  capitalize: (value) => {\n    const str = String(value)\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()\n  },\n\n  // Title case\n  title: (value) => {\n    return String(value)\n      .split(' ')\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ')\n  },\n\n  // Truncate\n  truncate: (value, length = '50', suffix = '...') => {\n    const str = String(value)\n    const maxLength = parseInt(length)\n    if (str.length <= maxLength) return str\n    return str.slice(0, maxLength) + suffix\n  },\n\n  // URL encode\n  urlencode: (value) => encodeURIComponent(String(value)),\n\n  // HTML escape\n  escape: (value) => {\n    return String(value)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;')\n  },\n}\n\n/**\n * Get value from nested path\n */\nfunction getNestedValue(data: MergeTagData, path: string): unknown {\n  const parts = path.split('.')\n  let current: unknown = data\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined\n    }\n    if (typeof current === 'object' && part in (current as Record<string, unknown>)) {\n      current = (current as Record<string, unknown>)[part]\n    } else {\n      return undefined\n    }\n  }\n\n  return current\n}\n\n/**\n * Parse formatter string like \"currency:USD:en-US\"\n */\nfunction parseFormatter(formatterStr: string): { name: string; args: string[] } {\n  const parts = formatterStr.split(':')\n  return {\n    name: parts[0],\n    args: parts.slice(1),\n  }\n}\n\n/**\n * Process a single merge tag\n */\nfunction processMergeTag(tag: string, data: MergeTagData): string {\n  // Remove {{ and }}\n  let content = tag.slice(2, -2).trim()\n\n  // Check for pipe (formatter)\n  let formatterStr: string | null = null\n  const pipeIndex = content.indexOf('|')\n  if (pipeIndex !== -1) {\n    formatterStr = content.slice(pipeIndex + 1).trim()\n    content = content.slice(0, pipeIndex).trim()\n  }\n\n  // Get the value\n  let value = getNestedValue(data, content)\n\n  // Handle legacy Mailchimp-style tags (all caps)\n  if (value === undefined) {\n    const mailchimpMappings: Record<string, string> = {\n      FNAME: 'subscriber.firstName',\n      LNAME: 'subscriber.lastName',\n      EMAIL: 'subscriber.email',\n      MERGE0: 'subscriber.email',\n      MERGE1: 'subscriber.firstName',\n      MERGE2: 'subscriber.lastName',\n    }\n    if (content in mailchimpMappings) {\n      value = getNestedValue(data, mailchimpMappings[content])\n    }\n  }\n\n  // Apply formatter if present\n  if (formatterStr) {\n    // Handle default with quotes: default:\"value\"\n    const defaultMatch = formatterStr.match(/^default:\"([^\"]*)\"$/)\n    if (defaultMatch) {\n      return formatters.default(value, defaultMatch[1])\n    }\n\n    const { name, args } = parseFormatter(formatterStr)\n    const formatter = formatters[name]\n    if (formatter) {\n      return formatter(value, ...args)\n    }\n  }\n\n  // Return value or empty string\n  if (value === null || value === undefined) {\n    return ''\n  }\n\n  return String(value)\n}\n\n/**\n * Process conditional blocks: {{#if condition}}...{{/if}}\n */\nfunction processConditionals(template: string, data: MergeTagData): string {\n  // Simple if blocks\n  const ifRegex = /\\{\\{#if\\s+([^}]+)\\}\\}([\\s\\S]*?)\\{\\{\\/if\\}\\}/g\n\n  return template.replace(ifRegex, (_, condition, content) => {\n    const value = getNestedValue(data, condition.trim())\n    const isTruthy = Boolean(value) && value !== '' && value !== 0 && value !== '0'\n\n    // Check for else block\n    const parts = content.split(/\\{\\{else\\}\\}/)\n    if (isTruthy) {\n      return parts[0] || ''\n    } else {\n      return parts[1] || ''\n    }\n  })\n}\n\n/**\n * Process loop blocks: {{#each items}}...{{/each}}\n */\nfunction processLoops(template: string, data: MergeTagData): string {\n  const eachRegex = /\\{\\{#each\\s+([^}]+)\\}\\}([\\s\\S]*?)\\{\\{\\/each\\}\\}/g\n\n  return template.replace(eachRegex, (_, arrayPath, content) => {\n    const items = getNestedValue(data, arrayPath.trim())\n    if (!Array.isArray(items)) {\n      return ''\n    }\n\n    return items\n      .map((item, index) => {\n        // Create context with item, index, and @first/@last\n        const itemData: MergeTagData = {\n          ...data,\n          '@index': index,\n          '@first': index === 0,\n          '@last': index === items.length - 1,\n          this: item as MergeTagData,\n        }\n\n        // Replace {{this.property}} with item values\n        let itemContent = content.replace(/\\{\\{this\\.([^}|]+)([^}]*)?\\}\\}/g, (_: string, path: string, rest: string) => {\n          const fullTag = `{{${path}${rest || ''}}}`\n          return processMergeTag(fullTag, item as MergeTagData)\n        })\n\n        // Also support {{property}} directly (without this.)\n        itemContent = itemContent.replace(/\\{\\{([a-zA-Z_][a-zA-Z0-9_]*)([^}]*)?\\}\\}/g, (match: string, path: string, rest: string) => {\n          // Skip special tags\n          if (path.startsWith('#') || path.startsWith('/') || path === 'else') {\n            return match\n          }\n          // Check if it's an item property\n          if (typeof item === 'object' && item !== null && path in (item as Record<string, unknown>)) {\n            const fullTag = `{{${path}${rest || ''}}}`\n            return processMergeTag(fullTag, item as MergeTagData)\n          }\n          return match\n        })\n\n        return processMergeTagsInternal(itemContent, itemData)\n      })\n      .join('')\n  })\n}\n\n/**\n * Internal merge tag processing (after conditionals and loops)\n */\nfunction processMergeTagsInternal(template: string, data: MergeTagData): string {\n  // Match {{...}} tags\n  const tagRegex = /\\{\\{([^#/}][^}]*)\\}\\}/g\n\n  return template.replace(tagRegex, (match) => processMergeTag(match, data))\n}\n\n/**\n * Parse and replace all merge tags in a template\n */\nexport function parseMergeTags(template: string, data: MergeTagData): string {\n  let result = template\n\n  // Process loops first (they may contain conditionals and simple tags)\n  result = processLoops(result, data)\n\n  // Process conditionals\n  result = processConditionals(result, data)\n\n  // Process remaining simple tags\n  result = processMergeTagsInternal(result, data)\n\n  return result\n}\n\n/**\n * Extract all merge tags from a template\n */\nexport function extractMergeTags(template: string): string[] {\n  const tags = new Set<string>()\n\n  // Simple tags\n  const simpleRegex = /\\{\\{([^#/}][^}|]*)/g\n  let match\n  while ((match = simpleRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  // Conditional tags\n  const ifRegex = /\\{\\{#if\\s+([^}]+)\\}\\}/g\n  while ((match = ifRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  // Loop tags\n  const eachRegex = /\\{\\{#each\\s+([^}]+)\\}\\}/g\n  while ((match = eachRegex.exec(template)) !== null) {\n    tags.add(match[1].trim())\n  }\n\n  return Array.from(tags)\n}\n\n/**\n * Validate that all required merge tags have data\n */\nexport function validateMergeTagData(template: string, data: MergeTagData): { valid: boolean; missing: string[] } {\n  const tags = extractMergeTags(template)\n  const missing: string[] = []\n\n  for (const tag of tags) {\n    const value = getNestedValue(data, tag)\n    if (value === undefined) {\n      missing.push(tag)\n    }\n  }\n\n  return {\n    valid: missing.length === 0,\n    missing,\n  }\n}\n\n/**\n * Register a custom formatter\n */\nexport function registerFormatter(name: string, formatter: (value: unknown, ...args: string[]) => string): void {\n  formatters[name] = formatter\n}\n\n/**\n * Get all available formatters\n */\nexport function getFormatters(): string[] {\n  return Object.keys(formatters)\n}\n","/**\n * Encryption Utilities\n *\n * Provides AES-256-GCM encryption for storing sensitive data in the database\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto'\n\nconst ALGORITHM = 'aes-256-gcm'\nconst IV_LENGTH = 16\nconst SALT_LENGTH = 32\nconst TAG_LENGTH = 16\nconst KEY_LENGTH = 32\n\n// Get encryption key from environment or generate a warning\nfunction getEncryptionKey(): Buffer {\n  const key = process.env.ENCRYPTION_KEY\n\n  if (!key) {\n    console.warn(\n      'WARNING: ENCRYPTION_KEY not set. Using fallback key. Set ENCRYPTION_KEY in production!'\n    )\n    // Fallback key for development only - DO NOT use in production\n    return scryptSync('development-fallback-key', 'salt', KEY_LENGTH)\n  }\n\n  // If key is hex string, convert to buffer\n  if (key.length === 64) {\n    return Buffer.from(key, 'hex')\n  }\n\n  // Otherwise derive key from provided string\n  return scryptSync(key, 'nextjs-cms-salt', KEY_LENGTH)\n}\n\n/**\n * Encrypt a string value\n * Returns format: salt:iv:tag:encrypted (all hex encoded)\n */\nexport function encrypt(plaintext: string): string {\n  const key = getEncryptionKey()\n  const iv = randomBytes(IV_LENGTH)\n  const salt = randomBytes(SALT_LENGTH)\n\n  // Derive a unique key for this encryption using salt\n  const derivedKey = scryptSync(key, salt, KEY_LENGTH)\n\n  const cipher = createCipheriv(ALGORITHM, derivedKey, iv)\n\n  let encrypted = cipher.update(plaintext, 'utf8', 'hex')\n  encrypted += cipher.final('hex')\n\n  const tag = cipher.getAuthTag()\n\n  // Combine salt, iv, tag, and encrypted data\n  return `${salt.toString('hex')}:${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`\n}\n\n/**\n * Decrypt an encrypted string\n * Expects format: salt:iv:tag:encrypted (all hex encoded)\n */\nexport function decrypt(encryptedData: string): string {\n  const key = getEncryptionKey()\n\n  const parts = encryptedData.split(':')\n  if (parts.length !== 4) {\n    throw new Error('Invalid encrypted data format')\n  }\n\n  const [saltHex, ivHex, tagHex, encrypted] = parts\n\n  const salt = Buffer.from(saltHex, 'hex')\n  const iv = Buffer.from(ivHex, 'hex')\n  const tag = Buffer.from(tagHex, 'hex')\n\n  // Derive the same key using the stored salt\n  const derivedKey = scryptSync(key, salt, KEY_LENGTH)\n\n  const decipher = createDecipheriv(ALGORITHM, derivedKey, iv)\n  decipher.setAuthTag(tag)\n\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8')\n  decrypted += decipher.final('utf8')\n\n  return decrypted\n}\n\n/**\n * Check if a value is encrypted (matches our format)\n */\nexport function isEncrypted(value: string): boolean {\n  const parts = value.split(':')\n  if (parts.length !== 4) return false\n\n  // Check if all parts are valid hex\n  return parts.every((part) => /^[0-9a-f]+$/i.test(part))\n}\n\n/**\n * Safely encrypt - returns original if encryption fails\n */\nexport function safeEncrypt(value: string): string {\n  try {\n    return encrypt(value)\n  } catch (error) {\n    console.error('Encryption failed:', error)\n    return value\n  }\n}\n\n/**\n * Safely decrypt - returns original if decryption fails\n */\nexport function safeDecrypt(value: string): string {\n  try {\n    if (!isEncrypted(value)) {\n      return value\n    }\n    return decrypt(value)\n  } catch (error) {\n    console.error('Decryption failed:', error)\n    return value\n  }\n}\n\n/**\n * Hash a value (one-way, for comparison only)\n */\nexport function hash(value: string): string {\n  const salt = randomBytes(16).toString('hex')\n  const hashed = scryptSync(value, salt, 64).toString('hex')\n  return `${salt}:${hashed}`\n}\n\n/**\n * Verify a value against a hash\n */\nexport function verifyHash(value: string, hashedValue: string): boolean {\n  const [salt, originalHash] = hashedValue.split(':')\n  const hashed = scryptSync(value, salt, 64).toString('hex')\n  return hashed === originalHash\n}\n","/**\n * Settings Types\n */\n\n// Setting groups\nexport type SettingGroup =\n  | 'general'\n  | 'branding'\n  | 'store'\n  | 'payments'\n  | 'shipping'\n  | 'analytics'\n  | 'seo'\n  | 'email'\n  | 'storage'\n  | 'ai'\n  | 'security'\n\n// Branding settings (white-label)\nexport interface BrandingSettings {\n  siteName: string\n  siteTagline?: string\n  logoUrl?: string\n  logoAlt?: string\n  logoDarkUrl?: string // Logo for dark mode\n  faviconUrl?: string\n  appleTouchIconUrl?: string\n  ogImageUrl?: string // Default Open Graph image\n  primaryColor?: string\n  accentColor?: string\n}\n\n// General/Store settings\nexport interface GeneralSettings {\n  siteName: string\n  siteUrl: string\n  supportEmail: string\n  supportPhone?: string\n  timezone: string\n  currency: string\n  locale: string\n  logoUrl?: string\n  faviconUrl?: string\n}\n\n// Email settings\nexport interface EmailSettings {\n  provider: 'smtp' | 'sendgrid' | 'resend' | 'mailgun' | 'ses'\n  fromName: string\n  fromEmail: string\n  replyTo?: string\n\n  // SMTP settings\n  smtpHost?: string\n  smtpPort?: number\n  smtpUser?: string\n  smtpPass?: string\n  smtpSecure?: boolean\n\n  // Provider API keys\n  sendgridApiKey?: string\n  resendApiKey?: string\n  mailgunApiKey?: string\n  mailgunDomain?: string\n\n  // AWS SES\n  sesRegion?: string\n  sesAccessKeyId?: string\n  sesSecretAccessKey?: string\n}\n\n// Storage settings\nexport interface StorageSettings {\n  provider: 's3' | 'r2' | 'local'\n  bucket?: string\n  region?: string\n  accessKeyId?: string\n  secretAccessKey?: string\n  endpoint?: string // For R2 or S3-compatible\n  publicUrl?: string\n  maxFileSize: number // in MB\n  allowedFileTypes: string[]\n}\n\n// AI settings\nexport interface AiSettings {\n  enabled: boolean\n  provider: 'openai' | 'anthropic' | 'google'\n  apiKey?: string\n  model: string\n  maxTokens: number\n  temperature: number\n}\n\n// Security settings\nexport interface SecuritySettings {\n  allowRegistration: boolean\n  requireEmailVerification: boolean\n  sessionTimeout: number // in minutes\n  maxLoginAttempts: number\n  lockoutDuration: number // in minutes\n  twoFactorEnabled: boolean\n  passwordMinLength: number\n  passwordRequireUppercase: boolean\n  passwordRequireNumbers: boolean\n  passwordRequireSymbols: boolean\n}\n\n// Environment variable status\nexport interface EnvVarStatus {\n  name: string\n  configured: boolean\n  required: boolean\n  group: SettingGroup\n  description: string\n}\n\n// All settings combined\nexport interface AllSettings {\n  general: GeneralSettings\n  payments: import('../stripe/types').StripeSettings\n  shipping: import('../shippo/types').ShippingSettings\n  analytics: import('../analytics/types').AnalyticsSettings\n  seo: import('../seo/types').SeoConfig\n  email: EmailSettings\n  storage: StorageSettings\n  ai: AiSettings\n  security: SecuritySettings\n}\n\n// Default settings\nexport const DEFAULT_BRANDING_SETTINGS: BrandingSettings = {\n  siteName: process.env.NEXT_PUBLIC_SITE_NAME || 'My Site',\n  siteTagline: 'Welcome to our platform',\n  primaryColor: '#0066cc',\n  accentColor: '#6366f1',\n}\n\nexport const DEFAULT_GENERAL_SETTINGS: GeneralSettings = {\n  siteName: 'My Store',\n  siteUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n  supportEmail: 'support@example.com',\n  timezone: 'America/New_York',\n  currency: 'USD',\n  locale: 'en-US',\n}\n\nexport const DEFAULT_EMAIL_SETTINGS: EmailSettings = {\n  provider: 'smtp',\n  fromName: 'My Store',\n  fromEmail: 'noreply@example.com',\n}\n\nexport const DEFAULT_STORAGE_SETTINGS: StorageSettings = {\n  provider: 's3',\n  maxFileSize: 10, // 10MB\n  allowedFileTypes: ['image/*', 'application/pdf'],\n}\n\nexport const DEFAULT_AI_SETTINGS: AiSettings = {\n  enabled: false,\n  provider: 'openai',\n  model: 'gpt-4o',\n  maxTokens: 4096,\n  temperature: 0.7,\n}\n\nexport const DEFAULT_SECURITY_SETTINGS: SecuritySettings = {\n  allowRegistration: true,\n  requireEmailVerification: true,\n  sessionTimeout: 60,\n  maxLoginAttempts: 5,\n  lockoutDuration: 15,\n  twoFactorEnabled: false,\n  passwordMinLength: 8,\n  passwordRequireUppercase: true,\n  passwordRequireNumbers: true,\n  passwordRequireSymbols: false,\n}\n\n// Required environment variables\nexport const REQUIRED_ENV_VARS: EnvVarStatus[] = [\n  // Database\n  { name: 'DATABASE_URL', configured: false, required: true, group: 'general', description: 'PostgreSQL connection string' },\n\n  // Auth\n  { name: 'NEXTAUTH_SECRET', configured: false, required: true, group: 'security', description: 'NextAuth secret for session encryption' },\n  { name: 'NEXTAUTH_URL', configured: false, required: true, group: 'security', description: 'Application URL for auth callbacks' },\n\n  // Stripe\n  { name: 'STRIPE_SECRET_KEY', configured: false, required: false, group: 'payments', description: 'Stripe API secret key' },\n  { name: 'STRIPE_WEBHOOK_SECRET', configured: false, required: false, group: 'payments', description: 'Stripe webhook signing secret' },\n  { name: 'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY', configured: false, required: false, group: 'payments', description: 'Stripe publishable key (public)' },\n\n  // Shippo\n  { name: 'SHIPPO_API_KEY', configured: false, required: false, group: 'shipping', description: 'Shippo API token' },\n  { name: 'SHIPPO_WEBHOOK_SECRET', configured: false, required: false, group: 'shipping', description: 'Shippo webhook secret' },\n\n  // Analytics\n  { name: 'NEXT_PUBLIC_GA_MEASUREMENT_ID', configured: false, required: false, group: 'analytics', description: 'Google Analytics 4 Measurement ID' },\n  { name: 'NEXT_PUBLIC_MATOMO_URL', configured: false, required: false, group: 'analytics', description: 'Matomo server URL' },\n  { name: 'NEXT_PUBLIC_MATOMO_SITE_ID', configured: false, required: false, group: 'analytics', description: 'Matomo site ID' },\n\n  // Storage (S3/R2)\n  { name: 'S3_BUCKET', configured: false, required: false, group: 'storage', description: 'S3 bucket name' },\n  { name: 'S3_REGION', configured: false, required: false, group: 'storage', description: 'S3 region' },\n  { name: 'S3_ACCESS_KEY_ID', configured: false, required: false, group: 'storage', description: 'S3 access key ID' },\n  { name: 'S3_SECRET_ACCESS_KEY', configured: false, required: false, group: 'storage', description: 'S3 secret access key' },\n  { name: 'S3_ENDPOINT', configured: false, required: false, group: 'storage', description: 'S3-compatible endpoint (for R2)' },\n\n  // AI\n  { name: 'OPENAI_API_KEY', configured: false, required: false, group: 'ai', description: 'OpenAI API key' },\n  { name: 'ANTHROPIC_API_KEY', configured: false, required: false, group: 'ai', description: 'Anthropic API key' },\n  { name: 'GOOGLE_AI_API_KEY', configured: false, required: false, group: 'ai', description: 'Google AI API key' },\n\n  // Email\n  { name: 'SMTP_HOST', configured: false, required: false, group: 'email', description: 'SMTP server host' },\n  { name: 'SMTP_PORT', configured: false, required: false, group: 'email', description: 'SMTP server port' },\n  { name: 'SMTP_USER', configured: false, required: false, group: 'email', description: 'SMTP username' },\n  { name: 'SMTP_PASS', configured: false, required: false, group: 'email', description: 'SMTP password' },\n  { name: 'SENDGRID_API_KEY', configured: false, required: false, group: 'email', description: 'SendGrid API key' },\n  { name: 'RESEND_API_KEY', configured: false, required: false, group: 'email', description: 'Resend API key' },\n]\n","/**\n * Settings Library\n *\n * Centralized settings management with database storage and encryption\n */\n\nimport { prisma } from '../db'\nimport { encrypt, safeDecrypt, isEncrypted } from '../encryption'\nimport type {\n  SettingGroup,\n  BrandingSettings,\n  GeneralSettings,\n  EmailSettings,\n  StorageSettings,\n  AiSettings,\n  SecuritySettings,\n  EnvVarStatus,\n} from './types'\nimport {\n  REQUIRED_ENV_VARS,\n  DEFAULT_BRANDING_SETTINGS,\n  DEFAULT_GENERAL_SETTINGS,\n  DEFAULT_EMAIL_SETTINGS,\n  DEFAULT_STORAGE_SETTINGS,\n  DEFAULT_AI_SETTINGS,\n  DEFAULT_SECURITY_SETTINGS,\n} from './types'\n\n// Keys that should be encrypted in the database\nconst SENSITIVE_KEYS: Record<SettingGroup, string[]> = {\n  email: ['smtpPass', 'sendgridApiKey', 'resendApiKey', 'mailgunApiKey', 'sesAccessKeyId', 'sesSecretAccessKey'],\n  storage: ['accessKeyId', 'secretAccessKey'],\n  ai: ['apiKey'],\n  payments: ['stripeSecretKey', 'stripeWebhookSecret', 'paypalClientSecret'],\n  branding: [],\n  general: [],\n  store: [],\n  shipping: [],\n  analytics: [],\n  seo: [],\n  security: [],\n}\n\n// Cache for settings\nconst settingsCache: Map<SettingGroup, { data: any; timestamp: number }> = new Map()\nconst CACHE_TTL = 60 * 1000 // 1 minute\n\n/**\n * Get settings for a specific group\n */\nexport async function getSettings<T>(\n  group: SettingGroup,\n  defaults: T\n): Promise<T> {\n  // Check cache\n  const cached = settingsCache.get(group)\n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return cached.data as T\n  }\n\n  const records = await prisma.setting.findMany({\n    where: { group },\n  })\n\n  const settings = { ...defaults } as any\n  const sensitiveKeys = SENSITIVE_KEYS[group] || []\n\n  for (const record of records) {\n    const key = record.key.replace(`${group}.`, '')\n    let value = record.value\n\n    // Decrypt if this is a sensitive key and the value is encrypted\n    if (sensitiveKeys.includes(key) && record.encrypted && isEncrypted(value)) {\n      value = safeDecrypt(value)\n    }\n\n    try {\n      // Try to parse JSON values\n      settings[key] = JSON.parse(value)\n    } catch {\n      // Use raw value if not JSON\n      settings[key] = value\n    }\n  }\n\n  // Update cache\n  settingsCache.set(group, { data: settings, timestamp: Date.now() })\n\n  return settings as T\n}\n\n/**\n * Update settings for a group\n */\nexport async function updateSettings(\n  group: SettingGroup,\n  settings: Record<string, any>\n): Promise<void> {\n  const sensitiveKeys = SENSITIVE_KEYS[group] || []\n\n  for (const [key, value] of Object.entries(settings)) {\n    if (value === undefined) continue\n\n    // Skip if value is masked (unchanged)\n    if (value === '********') continue\n\n    const fullKey = `${group}.${key}`\n    const isSensitive = sensitiveKeys.includes(key)\n\n    // Encrypt sensitive values before storing\n    let stringValue = typeof value === 'string' ? value : JSON.stringify(value)\n    if (isSensitive && stringValue && stringValue !== '') {\n      stringValue = encrypt(stringValue)\n    }\n\n    await prisma.setting.upsert({\n      where: { key: fullKey },\n      create: {\n        key: fullKey,\n        value: stringValue,\n        group,\n        encrypted: isSensitive,\n      },\n      update: {\n        value: stringValue,\n        encrypted: isSensitive,\n      },\n    })\n  }\n\n  // Clear cache for this group\n  settingsCache.delete(group)\n}\n\n/**\n * Clear settings cache\n */\nexport function clearSettingsCache(group?: SettingGroup): void {\n  if (group) {\n    settingsCache.delete(group)\n  } else {\n    settingsCache.clear()\n  }\n}\n\n// Convenience functions for each settings group\nexport async function getBrandingSettings(): Promise<BrandingSettings> {\n  return getSettings('branding', DEFAULT_BRANDING_SETTINGS)\n}\n\nexport async function getGeneralSettings(): Promise<GeneralSettings> {\n  return getSettings('general', DEFAULT_GENERAL_SETTINGS)\n}\n\nexport async function getEmailSettings(): Promise<EmailSettings> {\n  const settings = await getSettings('email', DEFAULT_EMAIL_SETTINGS)\n\n  // Fallback to environment variables\n  if (!settings.smtpHost) settings.smtpHost = process.env.SMTP_HOST\n  if (!settings.smtpPort) settings.smtpPort = parseInt(process.env.SMTP_PORT || '587')\n  if (!settings.smtpUser) settings.smtpUser = process.env.SMTP_USER\n  if (!settings.smtpPass) settings.smtpPass = process.env.SMTP_PASS\n  if (!settings.sendgridApiKey) settings.sendgridApiKey = process.env.SENDGRID_API_KEY\n  if (!settings.resendApiKey) settings.resendApiKey = process.env.RESEND_API_KEY\n\n  return settings\n}\n\nexport async function getStorageSettings(): Promise<StorageSettings> {\n  const settings = await getSettings('storage', DEFAULT_STORAGE_SETTINGS)\n\n  // Fallback to environment variables (S3 or R2)\n  if (!settings.bucket) settings.bucket = process.env.S3_BUCKET || process.env.R2_BUCKET\n  if (!settings.region) settings.region = process.env.S3_REGION || 'auto'\n  if (!settings.accessKeyId) settings.accessKeyId = process.env.S3_ACCESS_KEY_ID || process.env.R2_ACCESS_KEY_ID\n  if (!settings.secretAccessKey) settings.secretAccessKey = process.env.S3_SECRET_ACCESS_KEY || process.env.R2_SECRET_ACCESS_KEY\n\n  // Build R2 endpoint from account ID if not explicitly set\n  if (!settings.endpoint) {\n    if (process.env.S3_ENDPOINT) {\n      settings.endpoint = process.env.S3_ENDPOINT\n    } else if (process.env.R2_ACCOUNT_ID) {\n      settings.endpoint = `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`\n    }\n  }\n\n  // Public URL for R2\n  if (!settings.publicUrl) settings.publicUrl = process.env.R2_PUBLIC_URL\n\n  // Auto-detect R2 provider when R2 env vars are used\n  if (process.env.R2_BUCKET || process.env.R2_ACCOUNT_ID) {\n    settings.provider = 'r2'\n  }\n\n  return settings\n}\n\nexport async function getAiSettings(): Promise<AiSettings> {\n  const settings = await getSettings('ai', DEFAULT_AI_SETTINGS)\n\n  // Fallback to environment variables\n  if (!settings.apiKey) {\n    switch (settings.provider) {\n      case 'openai':\n        settings.apiKey = process.env.OPENAI_API_KEY\n        break\n      case 'anthropic':\n        settings.apiKey = process.env.ANTHROPIC_API_KEY\n        break\n      case 'google':\n        settings.apiKey = process.env.GOOGLE_AI_API_KEY\n        break\n    }\n  }\n\n  return settings\n}\n\nexport async function getSecuritySettings(): Promise<SecuritySettings> {\n  return getSettings('security', DEFAULT_SECURITY_SETTINGS)\n}\n\n/**\n * Check environment variable status\n */\nexport function getEnvVarStatus(): EnvVarStatus[] {\n  return REQUIRED_ENV_VARS.map((envVar) => ({\n    ...envVar,\n    configured: !!process.env[envVar.name],\n  }))\n}\n\n/**\n * Get all settings for admin dashboard\n */\nexport async function getAllSettings(): Promise<{\n  branding: BrandingSettings\n  general: GeneralSettings\n  email: EmailSettings\n  storage: StorageSettings\n  ai: AiSettings\n  security: SecuritySettings\n  envVars: EnvVarStatus[]\n}> {\n  const [branding, general, email, storage, ai, security] = await Promise.all([\n    getBrandingSettings(),\n    getGeneralSettings(),\n    getEmailSettings(),\n    getStorageSettings(),\n    getAiSettings(),\n    getSecuritySettings(),\n  ])\n\n  return {\n    branding,\n    general,\n    email: {\n      ...email,\n      // Mask sensitive values\n      smtpPass: email.smtpPass ? '********' : undefined,\n      sendgridApiKey: email.sendgridApiKey ? '********' : undefined,\n      resendApiKey: email.resendApiKey ? '********' : undefined,\n      mailgunApiKey: email.mailgunApiKey ? '********' : undefined,\n      sesSecretAccessKey: email.sesSecretAccessKey ? '********' : undefined,\n    },\n    storage: {\n      ...storage,\n      secretAccessKey: storage.secretAccessKey ? '********' : undefined,\n    },\n    ai: {\n      ...ai,\n      apiKey: ai.apiKey ? '********' : undefined,\n    },\n    security,\n    envVars: getEnvVarStatus(),\n  }\n}\n\nexport * from './types'\n","/**\n * Email Tracking Service\n *\n * Injects tracking pixels and rewrites links for email analytics\n */\n\nimport { prisma } from '../db'\nimport crypto from 'crypto'\n\nconst APP_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n\n/**\n * Generate a unique tracking token\n */\nexport function generateTrackingToken(): string {\n  return crypto.randomBytes(16).toString('hex')\n}\n\n/**\n * Create a tracking pixel URL\n */\nexport function createOpenTrackingUrl(recipientId: string, campaignId?: string): string {\n  const params = new URLSearchParams({\n    r: recipientId,\n    ...(campaignId && { c: campaignId }),\n  })\n  return `${APP_URL}/api/email/track/open?${params.toString()}`\n}\n\n/**\n * Create a click tracking URL\n */\nexport function createClickTrackingUrl(\n  recipientId: string,\n  originalUrl: string,\n  linkId?: string,\n  campaignId?: string\n): string {\n  const params = new URLSearchParams({\n    r: recipientId,\n    u: originalUrl,\n    ...(linkId && { l: linkId }),\n    ...(campaignId && { c: campaignId }),\n  })\n  return `${APP_URL}/api/email/track/click?${params.toString()}`\n}\n\n/**\n * Create an unsubscribe URL\n */\nexport function createUnsubscribeUrl(subscriberId: string, token?: string): string {\n  const params = new URLSearchParams({\n    s: subscriberId,\n    ...(token && { t: token }),\n  })\n  return `${APP_URL}/api/email/unsubscribe?${params.toString()}`\n}\n\n/**\n * Create a preference center URL\n */\nexport function createPreferenceCenterUrl(subscriberId: string, token?: string): string {\n  const params = new URLSearchParams({\n    s: subscriberId,\n    ...(token && { t: token }),\n  })\n  return `${APP_URL}/email/preferences?${params.toString()}`\n}\n\n/**\n * Inject open tracking pixel into HTML email\n */\nexport function injectOpenTrackingPixel(html: string, recipientId: string, campaignId?: string): string {\n  const trackingUrl = createOpenTrackingUrl(recipientId, campaignId)\n  const pixel = `<img src=\"${trackingUrl}\" width=\"1\" height=\"1\" alt=\"\" style=\"display:none;width:1px;height:1px;border:0;\" />`\n\n  // Inject before closing body tag, or at end if no body tag\n  if (html.includes('</body>')) {\n    return html.replace('</body>', `${pixel}</body>`)\n  }\n  return html + pixel\n}\n\n/**\n * Rewrite all links in HTML for click tracking\n */\nexport function rewriteLinksForTracking(\n  html: string,\n  recipientId: string,\n  campaignId?: string,\n  excludePatterns: RegExp[] = []\n): string {\n  // Default exclusion patterns\n  const defaultExclusions = [\n    /^mailto:/i,\n    /^tel:/i,\n    /^#/,\n    /^javascript:/i,\n    /unsubscribe/i,\n    /preference/i,\n  ]\n\n  const exclusions = [...defaultExclusions, ...excludePatterns]\n\n  // Match href attributes\n  const hrefRegex = /href=[\"']([^\"']+)[\"']/gi\n\n  return html.replace(hrefRegex, (match, url: string) => {\n    // Check if URL should be excluded\n    for (const pattern of exclusions) {\n      if (pattern.test(url)) {\n        return match\n      }\n    }\n\n    // Skip already-tracked URLs\n    if (url.includes('/api/email/track/')) {\n      return match\n    }\n\n    const trackedUrl = createClickTrackingUrl(recipientId, url, undefined, campaignId)\n    return `href=\"${trackedUrl}\"`\n  })\n}\n\n/**\n * Inject list-unsubscribe headers for email clients\n */\nexport function getUnsubscribeHeaders(subscriberId: string, token?: string): Record<string, string> {\n  const unsubscribeUrl = createUnsubscribeUrl(subscriberId, token)\n\n  return {\n    'List-Unsubscribe': `<${unsubscribeUrl}>`,\n    'List-Unsubscribe-Post': 'List-Unsubscribe=One-Click',\n  }\n}\n\n/**\n * Process HTML email for full tracking\n */\nexport function processEmailForTracking(\n  html: string,\n  recipientId: string,\n  options: {\n    campaignId?: string\n    trackOpens?: boolean\n    trackClicks?: boolean\n    excludeLinkPatterns?: RegExp[]\n  } = {}\n): string {\n  let processed = html\n\n  // Rewrite links for click tracking\n  if (options.trackClicks !== false) {\n    processed = rewriteLinksForTracking(processed, recipientId, options.campaignId, options.excludeLinkPatterns)\n  }\n\n  // Inject open tracking pixel\n  if (options.trackOpens !== false) {\n    processed = injectOpenTrackingPixel(processed, recipientId, options.campaignId)\n  }\n\n  return processed\n}\n\n/**\n * Record an email open event\n */\nexport async function recordEmailOpen(\n  recipientId: string,\n  metadata?: {\n    campaignId?: string\n    ipAddress?: string\n    userAgent?: string\n  }\n): Promise<void> {\n  const now = new Date()\n\n  // Update recipient record\n  await prisma.emailRecipient.update({\n    where: { id: recipientId },\n    data: {\n      openedAt: now,\n      openCount: { increment: 1 },\n    },\n  })\n\n  // Update campaign stats\n  if (metadata?.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: metadata.campaignId },\n      data: {\n        openCount: { increment: 1 },\n        // uniqueOpenCount handled separately with deduplication\n      },\n    })\n  }\n\n  // Update subscriber engagement\n  await prisma.$executeRaw`\n    UPDATE email_subscribers es\n    SET\n      total_opens = total_opens + 1,\n      last_engaged_at = ${now},\n      engagement_score = LEAST(engagement_score + 1, 100)\n    FROM email_recipients er\n    WHERE er.id = ${recipientId}\n    AND es.email = er.email\n  `\n}\n\n/**\n * Record an email click event\n */\nexport async function recordEmailClick(\n  recipientId: string,\n  url: string,\n  metadata?: {\n    campaignId?: string\n    linkId?: string\n    ipAddress?: string\n    userAgent?: string\n  }\n): Promise<void> {\n  const now = new Date()\n\n  // Update recipient record\n  await prisma.emailRecipient.update({\n    where: { id: recipientId },\n    data: {\n      clickedAt: now,\n      clickCount: { increment: 1 },\n    },\n  })\n\n  // Record click in EmailLinkClick if we have a linkId\n  if (metadata?.linkId) {\n    await prisma.emailLinkClick.create({\n      data: {\n        linkId: metadata.linkId,\n        recipientId,\n        clickedAt: now,\n        ipAddress: metadata.ipAddress,\n        userAgent: metadata.userAgent,\n      },\n    })\n\n    // Update link click count\n    await prisma.emailLink.update({\n      where: { id: metadata.linkId },\n      data: {\n        clickCount: { increment: 1 },\n      },\n    })\n  }\n\n  // Update campaign stats\n  if (metadata?.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: metadata.campaignId },\n      data: {\n        clickCount: { increment: 1 },\n      },\n    })\n  }\n\n  // Update subscriber engagement\n  await prisma.$executeRaw`\n    UPDATE email_subscribers es\n    SET\n      total_clicks = total_clicks + 1,\n      last_engaged_at = ${now},\n      engagement_score = LEAST(engagement_score + 2, 100)\n    FROM email_recipients er\n    WHERE er.id = ${recipientId}\n    AND es.email = er.email\n  `\n}\n\n/**\n * Get or create a tracked link\n */\nexport async function getOrCreateTrackedLink(\n  campaignId: string,\n  targetUrl: string\n): Promise<string> {\n  // Check if link exists\n  let link = await prisma.emailLink.findFirst({\n    where: {\n      campaignId,\n      url: targetUrl,\n    },\n  })\n\n  if (!link) {\n    link = await prisma.emailLink.create({\n      data: {\n        campaignId,\n        url: targetUrl,\n        clickCount: 0,\n      },\n    })\n  }\n\n  return link.id\n}\n\n/**\n * Rewrite links with database-tracked IDs\n */\nexport async function rewriteLinksWithTracking(\n  html: string,\n  recipientId: string,\n  campaignId: string,\n  excludePatterns: RegExp[] = []\n): Promise<string> {\n  const defaultExclusions = [\n    /^mailto:/i,\n    /^tel:/i,\n    /^#/,\n    /^javascript:/i,\n    /unsubscribe/i,\n    /preference/i,\n  ]\n\n  const exclusions = [...defaultExclusions, ...excludePatterns]\n\n  // Extract all links first\n  const hrefRegex = /href=[\"']([^\"']+)[\"']/gi\n  const links: string[] = []\n  let match\n\n  while ((match = hrefRegex.exec(html)) !== null) {\n    const url = match[1]\n    let shouldExclude = false\n\n    for (const pattern of exclusions) {\n      if (pattern.test(url)) {\n        shouldExclude = true\n        break\n      }\n    }\n\n    if (!shouldExclude && !url.includes('/api/email/track/')) {\n      links.push(url)\n    }\n  }\n\n  // Create tracked links in batch\n  const linkMap = new Map<string, string>()\n  for (const url of links) {\n    const linkId = await getOrCreateTrackedLink(campaignId, url)\n    linkMap.set(url, linkId)\n  }\n\n  // Replace links with tracked versions\n  return html.replace(hrefRegex, (match, url: string) => {\n    const linkId = linkMap.get(url)\n    if (!linkId) {\n      return match\n    }\n\n    const trackedUrl = createClickTrackingUrl(recipientId, url, linkId, campaignId)\n    return `href=\"${trackedUrl}\"`\n  })\n}\n","/**\n * Email Webhook Handlers\n *\n * Process bounce, complaint, and delivery events from email providers\n */\n\nimport { prisma } from '../db'\nimport type { EmailWebhookEvent, EmailProvider, EmailEventType } from './types'\nimport crypto from 'crypto'\n\n/**\n * Process an email webhook event\n */\nexport async function processEmailWebhookEvent(event: EmailWebhookEvent): Promise<void> {\n  const now = new Date()\n\n  switch (event.type) {\n    case 'bounced':\n    case 'soft_bounced':\n      await handleBounce(event)\n      break\n\n    case 'complained':\n      await handleComplaint(event)\n      break\n\n    case 'delivered':\n      await handleDelivery(event)\n      break\n\n    case 'unsubscribed':\n      await handleUnsubscribe(event)\n      break\n\n    case 'opened':\n    case 'clicked':\n      // These are typically handled by our own tracking endpoints\n      // But we can also process provider-side tracking here\n      break\n\n    case 'dropped':\n    case 'deferred':\n      await handleDropped(event)\n      break\n  }\n\n  // Log the event for debugging/analytics\n  console.log(`Email event: ${event.type} for ${event.email} via ${event.provider}`)\n}\n\n/**\n * Handle bounce events\n */\nasync function handleBounce(event: EmailWebhookEvent): Promise<void> {\n  const isHardBounce = event.bounceType === 'hard'\n\n  // Update subscriber status\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: isHardBounce ? 'BOUNCED' : 'ACTIVE',\n      unsubscribedAt: isHardBounce ? new Date() : undefined,\n    },\n  })\n\n  // Update recipient if we have messageId\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        bouncedAt: new Date(),\n        bounceType: event.bounceType,\n        errorMessage: event.bounceReason,\n      },\n    })\n  } else if (event.messageId) {\n    // Try to find by provider message ID\n    await prisma.emailRecipient.updateMany({\n      where: {\n        email: event.email,\n        providerMessageId: event.messageId,\n      },\n      data: {\n        bouncedAt: new Date(),\n        bounceType: event.bounceType,\n        errorMessage: event.bounceReason,\n      },\n    })\n  }\n\n  // Update campaign bounce count\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        bounceCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle complaint events (spam reports)\n */\nasync function handleComplaint(event: EmailWebhookEvent): Promise<void> {\n  // Mark subscriber as complained - this is serious\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: 'COMPLAINED',\n      unsubscribedAt: new Date(),\n    },\n  })\n\n  // Update recipient - mark as bounced with complaint reason\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        bouncedAt: new Date(),\n        errorMessage: `Spam complaint: ${event.complaintType || 'unknown'}`,\n      },\n    })\n  }\n\n  // Update campaign bounce count (complaints count as bounces)\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        bounceCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle delivery confirmation events\n */\nasync function handleDelivery(event: EmailWebhookEvent): Promise<void> {\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        sentAt: new Date(),\n        status: 'SENT',\n      },\n    })\n  }\n\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        sentCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle unsubscribe events from email client\n */\nasync function handleUnsubscribe(event: EmailWebhookEvent): Promise<void> {\n  await prisma.emailSubscriber.updateMany({\n    where: { email: event.email },\n    data: {\n      status: 'UNSUBSCRIBED',\n      unsubscribedAt: new Date(),\n    },\n  })\n\n  if (event.campaignId) {\n    await prisma.emailCampaign.update({\n      where: { id: event.campaignId },\n      data: {\n        unsubscribeCount: { increment: 1 },\n      },\n    })\n  }\n}\n\n/**\n * Handle dropped/deferred events\n */\nasync function handleDropped(event: EmailWebhookEvent): Promise<void> {\n  if (event.recipientId) {\n    await prisma.emailRecipient.update({\n      where: { id: event.recipientId },\n      data: {\n        status: 'FAILED',\n        errorMessage: event.bounceReason || `Email ${event.type}`,\n      },\n    })\n  }\n}\n\n// ==========================================\n// Provider-specific webhook parsers\n// ==========================================\n\n/**\n * Parse SendGrid webhook event\n */\nexport function parseSendGridWebhook(payload: unknown): EmailWebhookEvent[] {\n  const events: EmailWebhookEvent[] = []\n\n  if (!Array.isArray(payload)) {\n    return events\n  }\n\n  for (const item of payload) {\n    const eventType = mapSendGridEventType(item.event)\n    if (!eventType) continue\n\n    events.push({\n      type: eventType,\n      email: item.email,\n      messageId: item.sg_message_id,\n      timestamp: new Date(item.timestamp * 1000),\n      provider: 'sendgrid',\n      campaignId: item.campaign_id,\n      recipientId: item.recipient_id,\n      bounceType: item.bounce_classification === 'hard' ? 'hard' : 'soft',\n      bounceReason: item.reason,\n      linkUrl: item.url,\n      userAgent: item.useragent,\n      ipAddress: item.ip,\n      raw: item,\n    })\n  }\n\n  return events\n}\n\nfunction mapSendGridEventType(event: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    delivered: 'delivered',\n    bounce: 'bounced',\n    dropped: 'dropped',\n    spamreport: 'complained',\n    unsubscribe: 'unsubscribed',\n    open: 'opened',\n    click: 'clicked',\n    deferred: 'deferred',\n  }\n  return mapping[event] || null\n}\n\n/**\n * Parse Mailgun webhook event\n */\nexport function parseMailgunWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n  const eventData = data['event-data'] as Record<string, unknown>\n\n  if (!eventData) return null\n\n  const eventType = mapMailgunEventType(eventData.event as string)\n  if (!eventType) return null\n\n  const recipient = eventData.recipient as string\n  const message = eventData.message as Record<string, unknown>\n  const headers = message?.headers as Record<string, unknown>\n\n  return {\n    type: eventType,\n    email: recipient,\n    messageId: headers?.['message-id'] as string,\n    timestamp: new Date((eventData.timestamp as number) * 1000),\n    provider: 'mailgun',\n    campaignId: (eventData['user-variables'] as Record<string, string>)?.campaign_id,\n    recipientId: (eventData['user-variables'] as Record<string, string>)?.recipient_id,\n    bounceType: (eventData.severity as string) === 'permanent' ? 'hard' : 'soft',\n    bounceReason: (eventData['delivery-status'] as Record<string, unknown>)?.message as string,\n    linkUrl: eventData.url as string,\n    userAgent: (eventData['client-info'] as Record<string, unknown>)?.['user-agent'] as string,\n    ipAddress: eventData.ip as string,\n    raw: payload,\n  }\n}\n\nfunction mapMailgunEventType(event: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    delivered: 'delivered',\n    failed: 'bounced',\n    complained: 'complained',\n    unsubscribed: 'unsubscribed',\n    opened: 'opened',\n    clicked: 'clicked',\n  }\n  return mapping[event] || null\n}\n\n/**\n * Parse Resend webhook event\n */\nexport function parseResendWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n\n  const eventType = mapResendEventType(data.type as string)\n  if (!eventType) return null\n\n  const emailData = data.data as Record<string, unknown>\n\n  return {\n    type: eventType,\n    email: (emailData.to as string[])?.[0] || '',\n    messageId: emailData.email_id as string,\n    timestamp: new Date(data.created_at as string),\n    provider: 'resend',\n    campaignId: (emailData.tags as Array<{ name: string; value: string }>)?.find((t) => t.name === 'campaign_id')?.value,\n    recipientId: (emailData.tags as Array<{ name: string; value: string }>)?.find((t) => t.name === 'recipient_id')?.value,\n    bounceType: (emailData.bounce as Record<string, unknown>)?.type === 'permanent' ? 'hard' : 'soft',\n    bounceReason: (emailData.bounce as Record<string, unknown>)?.message as string,\n    raw: payload,\n  }\n}\n\nfunction mapResendEventType(type: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    'email.delivered': 'delivered',\n    'email.bounced': 'bounced',\n    'email.complained': 'complained',\n    'email.opened': 'opened',\n    'email.clicked': 'clicked',\n  }\n  return mapping[type] || null\n}\n\n/**\n * Parse AWS SES webhook (via SNS)\n */\nexport function parseSesWebhook(payload: unknown): EmailWebhookEvent | null {\n  const data = payload as Record<string, unknown>\n\n  // SNS wraps the message\n  let message: Record<string, unknown>\n  if (typeof data.Message === 'string') {\n    try {\n      message = JSON.parse(data.Message)\n    } catch {\n      return null\n    }\n  } else {\n    message = data as Record<string, unknown>\n  }\n\n  const notificationType = message.notificationType as string\n  const eventType = mapSesEventType(notificationType)\n  if (!eventType) return null\n\n  const mail = message.mail as Record<string, unknown>\n  const bounce = message.bounce as Record<string, unknown>\n  const complaint = message.complaint as Record<string, unknown>\n  const delivery = message.delivery as Record<string, unknown>\n\n  let email = ''\n  let bounceType: 'hard' | 'soft' | undefined\n  let bounceReason: string | undefined\n\n  if (bounce) {\n    const recipients = bounce.bouncedRecipients as Array<{ emailAddress: string }>\n    email = recipients?.[0]?.emailAddress || ''\n    bounceType = bounce.bounceType === 'Permanent' ? 'hard' : 'soft'\n    bounceReason = bounce.bounceSubType as string\n  } else if (complaint) {\n    const recipients = complaint.complainedRecipients as Array<{ emailAddress: string }>\n    email = recipients?.[0]?.emailAddress || ''\n  } else if (delivery) {\n    const recipients = delivery.recipients as string[]\n    email = recipients?.[0] || ''\n  }\n\n  return {\n    type: eventType,\n    email,\n    messageId: mail?.messageId as string,\n    timestamp: new Date(mail?.timestamp as string || message.timestamp as string),\n    provider: 'ses',\n    campaignId: (mail?.tags as Record<string, string[]>)?.campaign_id?.[0],\n    recipientId: (mail?.tags as Record<string, string[]>)?.recipient_id?.[0],\n    bounceType,\n    bounceReason,\n    complaintType: (complaint?.complaintFeedbackType as string),\n    raw: payload,\n  }\n}\n\nfunction mapSesEventType(type: string): EmailEventType | null {\n  const mapping: Record<string, EmailEventType> = {\n    Delivery: 'delivered',\n    Bounce: 'bounced',\n    Complaint: 'complained',\n    Open: 'opened',\n    Click: 'clicked',\n  }\n  return mapping[type] || null\n}\n\n// ==========================================\n// Webhook signature verification\n// ==========================================\n\n/**\n * Verify SendGrid webhook signature\n */\nexport function verifySendGridWebhook(\n  payload: string,\n  signature: string,\n  timestamp: string,\n  publicKey: string\n): boolean {\n  try {\n    const timestampPayload = timestamp + payload\n    const verify = crypto.createVerify('sha256')\n    verify.update(timestampPayload)\n    return verify.verify(publicKey, signature, 'base64')\n  } catch {\n    return false\n  }\n}\n\n/**\n * Verify Mailgun webhook signature\n */\nexport function verifyMailgunWebhook(\n  timestamp: string,\n  token: string,\n  signature: string,\n  apiKey: string\n): boolean {\n  const hmac = crypto.createHmac('sha256', apiKey)\n  hmac.update(timestamp + token)\n  const expected = hmac.digest('hex')\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))\n}\n\n/**\n * Verify Resend webhook signature\n */\nexport function verifyResendWebhook(\n  payload: string,\n  signature: string,\n  secret: string\n): boolean {\n  const hmac = crypto.createHmac('sha256', secret)\n  hmac.update(payload)\n  const expected = hmac.digest('hex')\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected))\n}\n","/**\n * Email Subscription Management\n *\n * Handles subscribe, unsubscribe, and preference management\n */\n\nimport { prisma } from '../db'\nimport crypto from 'crypto'\n\nconst APP_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n\n/**\n * Generate a secure token for subscription actions\n */\nexport function generateSubscriptionToken(email: string): string {\n  const secret = process.env.ENCRYPTION_KEY || 'default-secret-key'\n  const hmac = crypto.createHmac('sha256', secret)\n  hmac.update(email + Date.now().toString())\n  return hmac.digest('hex')\n}\n\n/**\n * Verify a subscription token\n */\nexport function verifySubscriptionToken(email: string, token: string, maxAgeMs = 7 * 24 * 60 * 60 * 1000): boolean {\n  // For now, we just check if the token exists in the subscriber record\n  // A more robust implementation would include expiration timestamps\n  return token.length === 64 // SHA-256 hex length\n}\n\n/**\n * Subscribe a new email address\n */\nexport async function subscribeEmail(\n  email: string,\n  options: {\n    firstName?: string\n    lastName?: string\n    name?: string\n    source?: string\n    tags?: string[]\n    metadata?: Record<string, unknown>\n    doubleOptIn?: boolean\n    consentIp?: string\n  } = {}\n): Promise<{ success: boolean; subscriber?: unknown; needsConfirmation?: boolean; error?: string }> {\n  const normalizedEmail = email.toLowerCase().trim()\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  if (!emailRegex.test(normalizedEmail)) {\n    return { success: false, error: 'Invalid email address' }\n  }\n\n  try {\n    // Check if already subscribed\n    const existing = await prisma.emailSubscriber.findUnique({\n      where: { email: normalizedEmail },\n    })\n\n    if (existing) {\n      if (existing.status === 'ACTIVE') {\n        return { success: true, subscriber: existing, error: 'Already subscribed' }\n      }\n\n      // Resubscribe if previously unsubscribed\n      if (['UNSUBSCRIBED', 'CLEANED'].includes(existing.status)) {\n        const confirmationToken = options.doubleOptIn ? generateSubscriptionToken(normalizedEmail) : undefined\n\n        const updated = await prisma.emailSubscriber.update({\n          where: { email: normalizedEmail },\n          data: {\n            status: options.doubleOptIn ? 'PENDING' : 'ACTIVE',\n            firstName: options.firstName || existing.firstName,\n            lastName: options.lastName || existing.lastName,\n            name: options.name || existing.name,\n            source: options.source || existing.source,\n            tags: options.tags || existing.tags,\n            metadata: options.metadata ? JSON.parse(JSON.stringify(options.metadata)) : existing.metadata,\n            confirmationToken,\n            consentTimestamp: options.doubleOptIn ? undefined : new Date(),\n            consentIp: options.consentIp,\n            consentSource: options.source,\n            unsubscribedAt: null,\n          },\n        })\n\n        if (options.doubleOptIn && confirmationToken) {\n          await sendConfirmationEmail(normalizedEmail, confirmationToken)\n          return { success: true, subscriber: updated, needsConfirmation: true }\n        }\n\n        return { success: true, subscriber: updated }\n      }\n\n      // Cannot resubscribe bounced or complained\n      if (['BOUNCED', 'COMPLAINED'].includes(existing.status)) {\n        return { success: false, error: 'This email address cannot be resubscribed' }\n      }\n    }\n\n    // Create new subscriber\n    const confirmationToken = options.doubleOptIn ? generateSubscriptionToken(normalizedEmail) : undefined\n\n    const subscriber = await prisma.emailSubscriber.create({\n      data: {\n        email: normalizedEmail,\n        firstName: options.firstName,\n        lastName: options.lastName,\n        name: options.name,\n        status: options.doubleOptIn ? 'PENDING' : 'ACTIVE',\n        source: options.source,\n        tags: options.tags || [],\n        metadata: options.metadata ? JSON.parse(JSON.stringify(options.metadata)) : undefined,\n        confirmationToken,\n        consentTimestamp: options.doubleOptIn ? undefined : new Date(),\n        consentIp: options.consentIp,\n        consentSource: options.source,\n      },\n    })\n\n    if (options.doubleOptIn && confirmationToken) {\n      await sendConfirmationEmail(normalizedEmail, confirmationToken)\n      return { success: true, subscriber, needsConfirmation: true }\n    }\n\n    return { success: true, subscriber }\n  } catch (error) {\n    console.error('Error subscribing email:', error)\n    return { success: false, error: 'Failed to subscribe' }\n  }\n}\n\n/**\n * Confirm email subscription (double opt-in)\n */\nexport async function confirmSubscription(\n  token: string\n): Promise<{ success: boolean; subscriber?: unknown; error?: string }> {\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { confirmationToken: token },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Invalid or expired confirmation token' }\n    }\n\n    if (subscriber.status === 'ACTIVE') {\n      return { success: true, subscriber, error: 'Already confirmed' }\n    }\n\n    const updated = await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        status: 'ACTIVE',\n        confirmedAt: new Date(),\n        consentTimestamp: new Date(),\n        confirmationToken: null,\n      },\n    })\n\n    return { success: true, subscriber: updated }\n  } catch (error) {\n    console.error('Error confirming subscription:', error)\n    return { success: false, error: 'Failed to confirm subscription' }\n  }\n}\n\n/**\n * Unsubscribe an email address\n */\nexport async function unsubscribeEmail(\n  email: string,\n  options: {\n    token?: string\n    reason?: string\n    campaignId?: string\n  } = {}\n): Promise<{ success: boolean; error?: string }> {\n  const normalizedEmail = email.toLowerCase().trim()\n\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { email: normalizedEmail },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    if (subscriber.status === 'UNSUBSCRIBED') {\n      return { success: true, error: 'Already unsubscribed' }\n    }\n\n    await prisma.emailSubscriber.update({\n      where: { email: normalizedEmail },\n      data: {\n        status: 'UNSUBSCRIBED',\n        unsubscribedAt: new Date(),\n        metadata: {\n          ...(subscriber.metadata as Record<string, unknown> || {}),\n          unsubscribeReason: options.reason,\n          unsubscribeCampaignId: options.campaignId,\n        },\n      },\n    })\n\n    // Update campaign unsubscribe count\n    if (options.campaignId) {\n      await prisma.emailCampaign.update({\n        where: { id: options.campaignId },\n        data: {\n          unsubscribeCount: { increment: 1 },\n        },\n      })\n    }\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error unsubscribing email:', error)\n    return { success: false, error: 'Failed to unsubscribe' }\n  }\n}\n\n/**\n * Unsubscribe by subscriber ID\n */\nexport async function unsubscribeById(\n  subscriberId: string,\n  options: {\n    token?: string\n    reason?: string\n    campaignId?: string\n  } = {}\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberId },\n    })\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    return unsubscribeEmail(subscriber.email, options)\n  } catch (error) {\n    console.error('Error unsubscribing by ID:', error)\n    return { success: false, error: 'Failed to unsubscribe' }\n  }\n}\n\n/**\n * Get subscriber preferences\n */\nexport async function getSubscriberPreferences(\n  subscriberIdOrEmail: string\n): Promise<{\n  success: boolean\n  subscriber?: {\n    id: string\n    email: string\n    firstName?: string | null\n    lastName?: string | null\n    status: string\n    tags: string[]\n    preferences: Record<string, unknown>\n  }\n  error?: string\n}> {\n  try {\n    // Try to find by ID first, then by email\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    return {\n      success: true,\n      subscriber: {\n        id: subscriber.id,\n        email: subscriber.email,\n        firstName: subscriber.firstName,\n        lastName: subscriber.lastName,\n        status: subscriber.status,\n        tags: subscriber.tags,\n        preferences: (subscriber.preferences as Record<string, unknown>) || {},\n      },\n    }\n  } catch (error) {\n    console.error('Error getting subscriber preferences:', error)\n    return { success: false, error: 'Failed to get preferences' }\n  }\n}\n\n/**\n * Update subscriber preferences\n */\nexport async function updateSubscriberPreferences(\n  subscriberIdOrEmail: string,\n  preferences: {\n    firstName?: string\n    lastName?: string\n    emailPreferences?: {\n      marketing?: boolean\n      transactional?: boolean\n      productUpdates?: boolean\n      newsletter?: boolean\n      frequency?: 'daily' | 'weekly' | 'monthly'\n    }\n    tags?: string[]\n  }\n): Promise<{ success: boolean; subscriber?: unknown; error?: string }> {\n  try {\n    // Try to find by ID first, then by email\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const currentPrefs = (subscriber.preferences as Record<string, unknown>) || {}\n\n    const updated = await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        firstName: preferences.firstName ?? subscriber.firstName,\n        lastName: preferences.lastName ?? subscriber.lastName,\n        tags: preferences.tags ?? subscriber.tags,\n        preferences: {\n          ...currentPrefs,\n          ...preferences.emailPreferences,\n        },\n      },\n    })\n\n    return { success: true, subscriber: updated }\n  } catch (error) {\n    console.error('Error updating subscriber preferences:', error)\n    return { success: false, error: 'Failed to update preferences' }\n  }\n}\n\n/**\n * Send confirmation email for double opt-in\n */\nasync function sendConfirmationEmail(email: string, token: string): Promise<void> {\n  // Import dynamically to avoid circular dependency\n  const { sendEmail } = await import('./index')\n\n  const confirmUrl = `${APP_URL}/api/email/confirm?token=${token}`\n\n  await sendEmail({\n    to: { email },\n    subject: 'Please confirm your subscription',\n    html: `\n      <!DOCTYPE html>\n      <html>\n      <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      </head>\n      <body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5;\">\n        <div style=\"max-width: 600px; margin: 0 auto; background: white; border-radius: 8px; padding: 40px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\">\n          <h1 style=\"margin: 0 0 20px; color: #333; font-size: 24px;\">Confirm your subscription</h1>\n          <p style=\"margin: 0 0 20px; color: #666; line-height: 1.6;\">\n            Thank you for subscribing! Please click the button below to confirm your email address.\n          </p>\n          <a href=\"${confirmUrl}\" style=\"display: inline-block; background: #0066cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: 600;\">\n            Confirm Subscription\n          </a>\n          <p style=\"margin: 20px 0 0; color: #999; font-size: 14px;\">\n            If you didn't subscribe, you can safely ignore this email.\n          </p>\n        </div>\n      </body>\n      </html>\n    `,\n    text: `\n      Confirm your subscription\n\n      Thank you for subscribing! Please click the link below to confirm your email address:\n\n      ${confirmUrl}\n\n      If you didn't subscribe, you can safely ignore this email.\n    `,\n  })\n}\n\n/**\n * Add tags to a subscriber\n */\nexport async function addSubscriberTags(\n  subscriberIdOrEmail: string,\n  tags: string[]\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const currentTags = new Set(subscriber.tags)\n    tags.forEach((tag) => currentTags.add(tag))\n\n    await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        tags: Array.from(currentTags),\n      },\n    })\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error adding subscriber tags:', error)\n    return { success: false, error: 'Failed to add tags' }\n  }\n}\n\n/**\n * Remove tags from a subscriber\n */\nexport async function removeSubscriberTags(\n  subscriberIdOrEmail: string,\n  tags: string[]\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    let subscriber = await prisma.emailSubscriber.findUnique({\n      where: { id: subscriberIdOrEmail },\n    })\n\n    if (!subscriber) {\n      subscriber = await prisma.emailSubscriber.findUnique({\n        where: { email: subscriberIdOrEmail.toLowerCase().trim() },\n      })\n    }\n\n    if (!subscriber) {\n      return { success: false, error: 'Subscriber not found' }\n    }\n\n    const tagsToRemove = new Set(tags)\n    const newTags = subscriber.tags.filter((tag) => !tagsToRemove.has(tag))\n\n    await prisma.emailSubscriber.update({\n      where: { id: subscriber.id },\n      data: {\n        tags: newTags,\n      },\n    })\n\n    return { success: true }\n  } catch (error) {\n    console.error('Error removing subscriber tags:', error)\n    return { success: false, error: 'Failed to remove tags' }\n  }\n}\n","/**\n * Email Queue Service\n *\n * Async email queue with retry logic, rate limiting, and batch processing.\n * Uses in-memory queue with optional database persistence for reliability.\n */\n\nimport { prisma } from '../db'\nimport { sendEmail, sendBulkEmail, EmailMessage, BulkEmailMessage, EmailSendResult, BulkEmailResult } from './index'\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport type EmailPriority = 'high' | 'normal' | 'low'\nexport type EmailStatus = 'pending' | 'processing' | 'sent' | 'failed' | 'cancelled'\n\nexport interface QueuedEmail {\n  id: string\n  message: EmailMessage\n  priority: EmailPriority\n  status: EmailStatus\n  attempts: number\n  maxAttempts: number\n  scheduledFor?: Date\n  lastAttemptAt?: Date\n  lastError?: string\n  createdAt: Date\n  sentAt?: Date\n  result?: EmailSendResult\n}\n\nexport interface QueueOptions {\n  /** Maximum concurrent sends */\n  concurrency?: number\n  /** Rate limit: max emails per second */\n  rateLimit?: number\n  /** Default max retry attempts */\n  maxAttempts?: number\n  /** Base delay between retries in ms (doubles each attempt) */\n  retryDelay?: number\n  /** Process interval in ms */\n  processInterval?: number\n  /** Enable database persistence */\n  persistToDb?: boolean\n}\n\nexport interface EnqueueOptions {\n  priority?: EmailPriority\n  maxAttempts?: number\n  scheduledFor?: Date\n  /** Unique key to prevent duplicates */\n  deduplicationKey?: string\n}\n\nexport interface QueueStats {\n  pending: number\n  processing: number\n  sent: number\n  failed: number\n  total: number\n  averageProcessingTime?: number\n}\n\n// =============================================================================\n// EMAIL QUEUE CLASS\n// =============================================================================\n\nexport class EmailQueue {\n  private queue: Map<string, QueuedEmail> = new Map()\n  private processing: Set<string> = new Set()\n  private deduplicationKeys: Set<string> = new Set()\n  private isProcessing = false\n  private processTimer: NodeJS.Timeout | null = null\n  private options: Required<QueueOptions>\n  private lastSendTime = 0\n  private sendCount = 0\n  private totalProcessingTime = 0\n  private processedCount = 0\n\n  constructor(options: QueueOptions = {}) {\n    this.options = {\n      concurrency: options.concurrency ?? 5,\n      rateLimit: options.rateLimit ?? 10, // 10 emails/second default\n      maxAttempts: options.maxAttempts ?? 3,\n      retryDelay: options.retryDelay ?? 1000,\n      processInterval: options.processInterval ?? 1000,\n      persistToDb: options.persistToDb ?? false,\n    }\n  }\n\n  /**\n   * Enqueue an email for sending\n   */\n  async enqueue(message: EmailMessage, options: EnqueueOptions = {}): Promise<string> {\n    const id = this.generateId()\n    const now = new Date()\n\n    // Check deduplication\n    if (options.deduplicationKey) {\n      if (this.deduplicationKeys.has(options.deduplicationKey)) {\n        throw new Error(`Duplicate email: ${options.deduplicationKey}`)\n      }\n      this.deduplicationKeys.add(options.deduplicationKey)\n    }\n\n    const queuedEmail: QueuedEmail = {\n      id,\n      message,\n      priority: options.priority ?? 'normal',\n      status: 'pending',\n      attempts: 0,\n      maxAttempts: options.maxAttempts ?? this.options.maxAttempts,\n      scheduledFor: options.scheduledFor,\n      createdAt: now,\n    }\n\n    this.queue.set(id, queuedEmail)\n\n    // Persist to database if enabled\n    if (this.options.persistToDb) {\n      await this.persistEmail(queuedEmail)\n    }\n\n    // Start processing if not already running\n    this.startProcessing()\n\n    return id\n  }\n\n  /**\n   * Enqueue multiple emails\n   */\n  async enqueueBatch(\n    messages: EmailMessage[],\n    options: EnqueueOptions = {}\n  ): Promise<string[]> {\n    const ids: string[] = []\n\n    for (const message of messages) {\n      const id = await this.enqueue(message, options)\n      ids.push(id)\n    }\n\n    return ids\n  }\n\n  /**\n   * Get email status by ID\n   */\n  getStatus(id: string): QueuedEmail | undefined {\n    return this.queue.get(id)\n  }\n\n  /**\n   * Cancel a pending email\n   */\n  cancel(id: string): boolean {\n    const email = this.queue.get(id)\n    if (!email || email.status !== 'pending') {\n      return false\n    }\n\n    email.status = 'cancelled'\n    return true\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getStats(): QueueStats {\n    const stats: QueueStats = {\n      pending: 0,\n      processing: 0,\n      sent: 0,\n      failed: 0,\n      total: this.queue.size,\n    }\n\n    for (const email of this.queue.values()) {\n      switch (email.status) {\n        case 'pending':\n          stats.pending++\n          break\n        case 'processing':\n          stats.processing++\n          break\n        case 'sent':\n          stats.sent++\n          break\n        case 'failed':\n          stats.failed++\n          break\n      }\n    }\n\n    if (this.processedCount > 0) {\n      stats.averageProcessingTime = this.totalProcessingTime / this.processedCount\n    }\n\n    return stats\n  }\n\n  /**\n   * Start queue processing\n   */\n  start(): void {\n    this.startProcessing()\n  }\n\n  /**\n   * Stop queue processing\n   */\n  stop(): void {\n    this.isProcessing = false\n    if (this.processTimer) {\n      clearTimeout(this.processTimer)\n      this.processTimer = null\n    }\n  }\n\n  /**\n   * Clear completed/failed emails from queue\n   */\n  clear(options: { keepPending?: boolean } = {}): number {\n    const { keepPending = true } = options\n    let cleared = 0\n\n    for (const [id, email] of this.queue.entries()) {\n      if (email.status === 'sent' || email.status === 'failed' || email.status === 'cancelled') {\n        this.queue.delete(id)\n        cleared++\n      } else if (!keepPending && email.status === 'pending') {\n        this.queue.delete(id)\n        cleared++\n      }\n    }\n\n    return cleared\n  }\n\n  /**\n   * Retry failed emails\n   */\n  async retryFailed(): Promise<number> {\n    let retriedCount = 0\n\n    for (const email of this.queue.values()) {\n      if (email.status === 'failed' && email.attempts < email.maxAttempts) {\n        email.status = 'pending'\n        email.lastError = undefined\n        retriedCount++\n      }\n    }\n\n    if (retriedCount > 0) {\n      this.startProcessing()\n    }\n\n    return retriedCount\n  }\n\n  // =============================================================================\n  // PRIVATE METHODS\n  // =============================================================================\n\n  private generateId(): string {\n    return `email_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n  }\n\n  private startProcessing(): void {\n    if (this.isProcessing) return\n\n    this.isProcessing = true\n    this.scheduleProcess()\n  }\n\n  private scheduleProcess(): void {\n    if (!this.isProcessing) return\n\n    this.processTimer = setTimeout(async () => {\n      await this.process()\n      this.scheduleProcess()\n    }, this.options.processInterval)\n  }\n\n  private async process(): Promise<void> {\n    // Get pending emails sorted by priority\n    const pending = this.getPendingEmails()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    // Respect rate limiting\n    const now = Date.now()\n    if (now - this.lastSendTime < 1000) {\n      if (this.sendCount >= this.options.rateLimit) {\n        return // Rate limited\n      }\n    } else {\n      this.sendCount = 0\n      this.lastSendTime = now\n    }\n\n    // Process up to concurrency limit\n    const toProcess = pending.slice(0, this.options.concurrency - this.processing.size)\n\n    const promises = toProcess.map(email => this.processEmail(email))\n    await Promise.allSettled(promises)\n  }\n\n  private getPendingEmails(): QueuedEmail[] {\n    const now = new Date()\n    const pending: QueuedEmail[] = []\n\n    for (const email of this.queue.values()) {\n      if (email.status !== 'pending') continue\n      if (this.processing.has(email.id)) continue\n      if (email.scheduledFor && email.scheduledFor > now) continue\n\n      // Check retry delay\n      if (email.lastAttemptAt) {\n        const delay = this.calculateRetryDelay(email.attempts)\n        const nextAttempt = new Date(email.lastAttemptAt.getTime() + delay)\n        if (nextAttempt > now) continue\n      }\n\n      pending.push(email)\n    }\n\n    // Sort by priority (high > normal > low)\n    const priorityOrder: Record<EmailPriority, number> = {\n      high: 0,\n      normal: 1,\n      low: 2,\n    }\n\n    pending.sort((a, b) => {\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority]\n      if (priorityDiff !== 0) return priorityDiff\n      return a.createdAt.getTime() - b.createdAt.getTime()\n    })\n\n    return pending\n  }\n\n  private calculateRetryDelay(attempts: number): number {\n    // Exponential backoff: 1s, 2s, 4s, 8s, etc.\n    return this.options.retryDelay * Math.pow(2, attempts)\n  }\n\n  private async processEmail(email: QueuedEmail): Promise<void> {\n    if (this.processing.has(email.id)) return\n\n    this.processing.add(email.id)\n    email.status = 'processing'\n    const startTime = Date.now()\n\n    try {\n      const result = await sendEmail(email.message)\n\n      email.attempts++\n      email.lastAttemptAt = new Date()\n      email.result = result\n\n      if (result.success) {\n        email.status = 'sent'\n        email.sentAt = new Date()\n        this.sendCount++\n      } else {\n        email.lastError = result.error\n        if (email.attempts >= email.maxAttempts) {\n          email.status = 'failed'\n        } else {\n          email.status = 'pending' // Will retry\n        }\n      }\n\n      // Update stats\n      this.processedCount++\n      this.totalProcessingTime += Date.now() - startTime\n\n      // Update database if persisting\n      if (this.options.persistToDb) {\n        await this.updatePersistedEmail(email)\n      }\n    } catch (error) {\n      email.attempts++\n      email.lastAttemptAt = new Date()\n      email.lastError = error instanceof Error ? error.message : 'Unknown error'\n\n      if (email.attempts >= email.maxAttempts) {\n        email.status = 'failed'\n      } else {\n        email.status = 'pending'\n      }\n    } finally {\n      this.processing.delete(email.id)\n    }\n  }\n\n  private async persistEmail(email: QueuedEmail): Promise<void> {\n    try {\n      await prisma.emailQueueItem.create({\n        data: {\n          id: email.id,\n          message: email.message as never,\n          priority: email.priority,\n          status: email.status,\n          attempts: email.attempts,\n          maxAttempts: email.maxAttempts,\n          scheduledFor: email.scheduledFor,\n          createdAt: email.createdAt,\n        },\n      })\n    } catch (error) {\n      console.error('Failed to persist email to database:', error)\n    }\n  }\n\n  private async updatePersistedEmail(email: QueuedEmail): Promise<void> {\n    try {\n      await prisma.emailQueueItem.update({\n        where: { id: email.id },\n        data: {\n          status: email.status,\n          attempts: email.attempts,\n          lastAttemptAt: email.lastAttemptAt,\n          lastError: email.lastError,\n          sentAt: email.sentAt,\n          result: email.result as never,\n        },\n      })\n    } catch (error) {\n      console.error('Failed to update persisted email:', error)\n    }\n  }\n\n  /**\n   * Load pending emails from database on startup\n   */\n  async loadFromDatabase(): Promise<number> {\n    if (!this.options.persistToDb) return 0\n\n    try {\n      const items = await prisma.emailQueueItem.findMany({\n        where: {\n          status: { in: ['pending', 'processing'] },\n        },\n      })\n\n      for (const item of items) {\n        const queuedEmail: QueuedEmail = {\n          id: item.id,\n          message: item.message as unknown as EmailMessage,\n          priority: item.priority as EmailPriority,\n          status: 'pending', // Reset processing items to pending\n          attempts: item.attempts,\n          maxAttempts: item.maxAttempts,\n          scheduledFor: item.scheduledFor ?? undefined,\n          lastAttemptAt: item.lastAttemptAt ?? undefined,\n          lastError: item.lastError ?? undefined,\n          createdAt: item.createdAt,\n        }\n\n        this.queue.set(item.id, queuedEmail)\n      }\n\n      if (items.length > 0) {\n        this.startProcessing()\n      }\n\n      return items.length\n    } catch (error) {\n      console.error('Failed to load emails from database:', error)\n      return 0\n    }\n  }\n}\n\n// =============================================================================\n// SINGLETON INSTANCE\n// =============================================================================\n\nlet queueInstance: EmailQueue | null = null\n\nexport function getEmailQueue(options?: QueueOptions): EmailQueue {\n  if (!queueInstance) {\n    queueInstance = new EmailQueue(options)\n  }\n  return queueInstance\n}\n\n// =============================================================================\n// CONVENIENCE FUNCTIONS\n// =============================================================================\n\n/**\n * Queue an email for async sending\n */\nexport async function queueEmail(\n  message: EmailMessage,\n  options?: EnqueueOptions\n): Promise<string> {\n  const queue = getEmailQueue()\n  return queue.enqueue(message, options)\n}\n\n/**\n * Queue multiple emails for async sending\n */\nexport async function queueEmails(\n  messages: EmailMessage[],\n  options?: EnqueueOptions\n): Promise<string[]> {\n  const queue = getEmailQueue()\n  return queue.enqueueBatch(messages, options)\n}\n\n/**\n * Queue a high-priority email\n */\nexport async function queueUrgentEmail(\n  message: EmailMessage,\n  options?: Omit<EnqueueOptions, 'priority'>\n): Promise<string> {\n  return queueEmail(message, { ...options, priority: 'high' })\n}\n\n/**\n * Schedule an email for later\n */\nexport async function scheduleEmail(\n  message: EmailMessage,\n  sendAt: Date,\n  options?: EnqueueOptions\n): Promise<string> {\n  return queueEmail(message, { ...options, scheduledFor: sendAt })\n}\n\n/**\n * Get queue status\n */\nexport function getQueueStats(): QueueStats {\n  const queue = getEmailQueue()\n  return queue.getStats()\n}\n\n/**\n * Check email status\n */\nexport function checkEmailStatus(id: string): QueuedEmail | undefined {\n  const queue = getEmailQueue()\n  return queue.getStatus(id)\n}\n","/**\n * Email Service\n *\n * Multi-provider email sending abstraction with tracking support\n */\n\nimport type {\n  EmailProvider,\n  IEmailProvider,\n  EmailMessage,\n  EmailSendResult,\n  BulkEmailMessage,\n  BulkEmailResult,\n  EmailServiceConfig,\n  SmtpConfig,\n  SendGridConfig,\n  ResendConfig,\n  MailgunConfig,\n  SesConfig,\n  EmailAddress,\n} from './types'\nimport { SmtpProvider, SendGridProvider, ResendProvider, MailgunProvider, SesProvider } from './providers'\nimport { parseMergeTags, type MergeTagData } from './merge-tags'\nimport { getEmailSettings, type EmailSettings } from '../settings'\n\nexport * from './types'\nexport * from './merge-tags'\nexport * from './tracking'\nexport * from './webhooks'\nexport * from './subscriptions'\nexport * from './queue'\n\n// Singleton provider instance\nlet providerInstance: IEmailProvider | null = null\nlet currentProviderName: EmailProvider | null = null\n\n/**\n * Create a provider instance based on configuration\n */\nfunction createProvider(settings: EmailSettings): IEmailProvider {\n  switch (settings.provider) {\n    case 'smtp':\n      return new SmtpProvider({\n        host: settings.smtpHost!,\n        port: settings.smtpPort!,\n        secure: settings.smtpSecure,\n        user: settings.smtpUser,\n        pass: settings.smtpPass,\n      })\n\n    case 'sendgrid':\n      return new SendGridProvider({\n        apiKey: settings.sendgridApiKey!,\n      })\n\n    case 'resend':\n      return new ResendProvider({\n        apiKey: settings.resendApiKey!,\n      })\n\n    case 'mailgun':\n      return new MailgunProvider({\n        apiKey: settings.mailgunApiKey!,\n        domain: settings.mailgunDomain!,\n      })\n\n    case 'ses':\n      return new SesProvider({\n        region: settings.sesRegion!,\n        accessKeyId: settings.sesAccessKeyId!,\n        secretAccessKey: settings.sesSecretAccessKey!,\n      })\n\n    default:\n      throw new Error(`Unknown email provider: ${settings.provider}`)\n  }\n}\n\n/**\n * Get the email provider instance\n */\nasync function getProvider(): Promise<IEmailProvider> {\n  const settings = await getEmailSettings()\n\n  // If provider changed, recreate instance\n  if (currentProviderName !== settings.provider) {\n    if (providerInstance?.close) {\n      await providerInstance.close()\n    }\n    providerInstance = null\n    currentProviderName = null\n  }\n\n  if (!providerInstance) {\n    providerInstance = createProvider(settings)\n    currentProviderName = settings.provider\n  }\n\n  return providerInstance\n}\n\n/**\n * Get default from address from settings\n */\nasync function getDefaultFrom(): Promise<EmailAddress> {\n  const settings = await getEmailSettings()\n  return {\n    email: settings.fromEmail || 'noreply@example.com',\n    name: settings.fromName,\n  }\n}\n\n/**\n * Get default reply-to from settings\n */\nasync function getDefaultReplyTo(): Promise<EmailAddress | undefined> {\n  const settings = await getEmailSettings()\n  return settings.replyTo ? { email: settings.replyTo } : undefined\n}\n\n/**\n * Email Service Class\n */\nexport class EmailService {\n  private provider: IEmailProvider | null = null\n  private config: EmailServiceConfig | null = null\n\n  /**\n   * Initialize with explicit configuration (for testing)\n   */\n  initWithConfig(\n    providerType: EmailProvider,\n    providerConfig: SmtpConfig | SendGridConfig | ResendConfig | MailgunConfig | SesConfig,\n    serviceConfig: Partial<EmailServiceConfig>\n  ): void {\n    switch (providerType) {\n      case 'smtp':\n        this.provider = new SmtpProvider(providerConfig as SmtpConfig)\n        break\n      case 'sendgrid':\n        this.provider = new SendGridProvider(providerConfig as SendGridConfig)\n        break\n      case 'resend':\n        this.provider = new ResendProvider(providerConfig as ResendConfig)\n        break\n      case 'mailgun':\n        this.provider = new MailgunProvider(providerConfig as MailgunConfig)\n        break\n      case 'ses':\n        this.provider = new SesProvider(providerConfig as SesConfig)\n        break\n    }\n\n    this.config = {\n      provider: providerType,\n      defaultFrom: serviceConfig.defaultFrom || { email: 'noreply@example.com' },\n      ...serviceConfig,\n    }\n  }\n\n  /**\n   * Get provider (lazy load from settings if not initialized)\n   */\n  private async getProvider(): Promise<IEmailProvider> {\n    if (this.provider) {\n      return this.provider\n    }\n    return getProvider()\n  }\n\n  /**\n   * Send a single email\n   */\n  async send(message: EmailMessage): Promise<EmailSendResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n    if (!message.replyTo) {\n      message.replyTo = this.config?.defaultReplyTo || (await getDefaultReplyTo())\n    }\n\n    return provider.send(message)\n  }\n\n  /**\n   * Send email with merge tags\n   */\n  async sendWithMergeTags(\n    message: Omit<EmailMessage, 'subject' | 'html' | 'text'> & {\n      subjectTemplate: string\n      htmlTemplate?: string\n      textTemplate?: string\n    },\n    data: MergeTagData\n  ): Promise<EmailSendResult> {\n    const subject = parseMergeTags(message.subjectTemplate, data)\n    const html = message.htmlTemplate ? parseMergeTags(message.htmlTemplate, data) : undefined\n    const text = message.textTemplate ? parseMergeTags(message.textTemplate, data) : undefined\n\n    return this.send({\n      ...message,\n      subject,\n      html,\n      text,\n    })\n  }\n\n  /**\n   * Send bulk emails\n   */\n  async sendBulk(message: BulkEmailMessage): Promise<BulkEmailResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n    if (!message.replyTo) {\n      message.replyTo = this.config?.defaultReplyTo || (await getDefaultReplyTo())\n    }\n\n    // Use bulk if available, otherwise send individually\n    if (provider.sendBulk) {\n      return provider.sendBulk(message)\n    }\n\n    // Fallback to individual sends\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const result = await provider.send({\n        ...message,\n        to: recipient.to,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: provider.name,\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  /**\n   * Send bulk emails with per-recipient merge tags\n   */\n  async sendBulkWithMergeTags(\n    message: Omit<BulkEmailMessage, 'subject' | 'html' | 'text'> & {\n      subjectTemplate: string\n      htmlTemplate?: string\n      textTemplate?: string\n    },\n    recipientData: Map<string, MergeTagData>\n  ): Promise<BulkEmailResult> {\n    const provider = await this.getProvider()\n\n    // Apply defaults\n    if (!message.from) {\n      message.from = this.config?.defaultFrom || (await getDefaultFrom())\n    }\n\n    // For bulk with merge tags, we need to send individually to process templates\n    const results: BulkEmailResult['results'] = []\n    let totalSent = 0\n    let totalFailed = 0\n\n    for (const recipient of message.recipients) {\n      const data = recipientData.get(recipient.to.email) || {}\n\n      const subject = parseMergeTags(message.subjectTemplate, data)\n      const html = message.htmlTemplate ? parseMergeTags(message.htmlTemplate, data) : undefined\n      const text = message.textTemplate ? parseMergeTags(message.textTemplate, data) : undefined\n\n      const result = await provider.send({\n        ...message,\n        to: recipient.to,\n        subject,\n        html,\n        text,\n        metadata: { ...message.metadata, ...recipient.metadata },\n      })\n\n      results.push({\n        email: recipient.to.email,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error,\n      })\n\n      if (result.success) {\n        totalSent++\n      } else {\n        totalFailed++\n      }\n    }\n\n    return {\n      success: totalFailed === 0,\n      provider: provider.name,\n      totalSent,\n      totalFailed,\n      results,\n      timestamp: new Date(),\n    }\n  }\n\n  /**\n   * Verify provider configuration\n   */\n  async verify(): Promise<boolean> {\n    const provider = await this.getProvider()\n    return provider.verify()\n  }\n\n  /**\n   * Get current provider name\n   */\n  async getProviderName(): Promise<EmailProvider> {\n    const provider = await this.getProvider()\n    return provider.name\n  }\n\n  /**\n   * Close provider connections\n   */\n  async close(): Promise<void> {\n    if (this.provider?.close) {\n      await this.provider.close()\n    }\n    this.provider = null\n\n    // Also close singleton\n    if (providerInstance?.close) {\n      await providerInstance.close()\n    }\n    providerInstance = null\n    currentProviderName = null\n  }\n}\n\n// Export singleton instance\nexport const emailService = new EmailService()\n\n// Convenience functions\nexport async function sendEmail(message: EmailMessage): Promise<EmailSendResult> {\n  return emailService.send(message)\n}\n\nexport async function sendBulkEmail(message: BulkEmailMessage): Promise<BulkEmailResult> {\n  return emailService.sendBulk(message)\n}\n\nexport async function sendEmailWithMergeTags(\n  message: Omit<EmailMessage, 'subject' | 'html' | 'text'> & {\n    subjectTemplate: string\n    htmlTemplate?: string\n    textTemplate?: string\n  },\n  data: MergeTagData\n): Promise<EmailSendResult> {\n  return emailService.sendWithMergeTags(message, data)\n}\n"],"mappings":"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","names":["formatAddress","formatAddresses","formatAddress","formatAddresses","formatAddress","formatAddress","_","crypto","crypto","match","crypto","crypto","APP_URL","crypto","confirmationToken","sendEmail","sendBulkEmail"]}