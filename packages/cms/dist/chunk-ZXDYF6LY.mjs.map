{"version":3,"sources":["../src/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\n/**\n * Combines class names with Tailwind CSS merge support\n */\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n/**\n * Format cents to currency display\n */\nexport function formatCurrency(cents: number, currency = \"USD\"): string {\n  return new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency,\n  }).format(cents / 100)\n}\n\n/**\n * Format date using Intl\n */\nexport function formatDate(\n  date: Date | string,\n  options: Intl.DateTimeFormatOptions = {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n  }\n): string {\n  return new Intl.DateTimeFormat(\"en-US\", options).format(\n    typeof date === \"string\" ? new Date(date) : date\n  )\n}\n\n/**\n * Format weight from ounces to lb/oz display\n */\nexport function formatWeight(ounces: number): string {\n  const lbs = Math.floor(ounces / 16)\n  const oz = ounces % 16\n  if (lbs === 0) return `${oz} oz`\n  if (oz === 0) return `${lbs} lb`\n  return `${lbs} lb ${oz} oz`\n}\n\n/**\n * Format dimensions (width x height x depth)\n */\nexport function formatDimensions(\n  width: number,\n  height: number,\n  depth: number,\n  unit = \"in\"\n): string {\n  return `${width} x ${height} x ${depth} ${unit}`\n}\n\n/**\n * Format slug from string\n */\nexport function formatSlug(value: string): string {\n  return value\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/(^-|-$)/g, \"\")\n}\n\n/**\n * Generate a random ID\n */\nexport function generateId(length = 12): string {\n  const chars = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n  let result = \"\"\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length))\n  }\n  return result\n}\n\n/**\n * Debounce function\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: NodeJS.Timeout\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(() => fn(...args), delay)\n  }\n}\n\n/**\n * Sleep/delay utility\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\n/**\n * Check if value is empty (null, undefined, empty string, empty array, empty object)\n */\nexport function isEmpty(value: unknown): boolean {\n  if (value === null || value === undefined) return true\n  if (typeof value === \"string\") return value.trim() === \"\"\n  if (Array.isArray(value)) return value.length === 0\n  if (typeof value === \"object\") return Object.keys(value).length === 0\n  return false\n}\n\n/**\n * Truncate string with ellipsis\n */\nexport function truncate(str: string, length: number): string {\n  if (str.length <= length) return str\n  return str.slice(0, length) + \"...\"\n}\n\n/**\n * Capitalize first letter of string\n */\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\n/**\n * Convert object to URL search params\n */\nexport function toSearchParams(\n  obj: Record<string, string | number | boolean | undefined>\n): string {\n  const params = new URLSearchParams()\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      params.set(key, String(value))\n    }\n  }\n  return params.toString()\n}\n\n/**\n * Generate a UUID v4\n * ChatSDK compatibility alias\n */\nexport function generateUUID(): string {\n  return crypto.randomUUID()\n}\n\n/**\n * SWR fetcher utility\n * For use with SWR hooks\n */\nexport async function fetcher<T>(url: string): Promise<T> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    const error = new Error('Failed to fetch') as Error & { status: number }\n    error.status = response.status\n    throw error\n  }\n  return response.json()\n}\n\n/**\n * Fetch with error handlers\n * Drop-in replacement for fetch that handles common error cases\n */\nexport async function fetchWithErrorHandlers(\n  input: RequestInfo | URL,\n  init?: RequestInit\n): Promise<Response> {\n  const response = await fetch(input, init)\n\n  if (!response.ok) {\n    // Clone response to read body for error details\n    const clonedResponse = response.clone()\n    let errorBody: Record<string, unknown> = {}\n    try {\n      errorBody = await clonedResponse.json()\n    } catch {\n      // Ignore JSON parse errors\n    }\n\n    const error = new Error(\n      (errorBody.message as string) || `HTTP ${response.status}`\n    ) as Error & { status: number; code?: string }\n    error.status = response.status\n    error.code = errorBody.code as string\n\n    throw error\n  }\n\n  return response\n}\n\n/**\n * Extract text content from a UIMessage\n * ChatSDK utility for message text extraction\n */\nexport function getTextFromMessage(message: { parts?: Array<{ type: string; text?: string }> }): string {\n  if (!message.parts) return ''\n  return message.parts\n    .filter((part): part is { type: 'text'; text: string } => part.type === 'text' && !!part.text)\n    .map((part) => part.text)\n    .join('\\n')\n}\n\n/**\n * Sanitize text for safe display\n * Removes potentially dangerous characters while preserving content\n */\nexport function sanitizeText(text: string): string {\n  if (!text) return ''\n  // Basic sanitization - remove control characters except newlines/tabs\n  return text\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '')\n    .trim()\n}\n"],"mappings":";AAAA,SAA0B,YAAY;AACtC,SAAS,eAAe;AAKjB,SAAS,MAAM,QAAsB;AAC1C,SAAO,QAAQ,KAAK,MAAM,CAAC;AAC7B;","names":[]}