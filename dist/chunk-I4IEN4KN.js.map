{"version":3,"sources":["/mnt/c/Users/bubun/CascadeProjects/nextjs-cms/dist/chunk-I4IEN4KN.js","../src/lib/workflows/context.ts","../src/lib/workflows/primitive-adapter.ts","../src/lib/workflows/engine.ts"],"names":["primitive"],"mappings":"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;AACH;AASsB;AAKb,EAAA;AACQ,IAAA;AACb,IAAA;AACW,IAAA;AACZ,EAAA;AACH;AAKsB;AAId,EAAA;AACK,IAAA;AACV,EAAA;AAEc,EAAA;AACH,IAAA;AACZ,EAAA;AAEa,EAAA;AACD,IAAA;AACZ,EAAA;AAEO,EAAA;AACQ,IAAA;AACF,IAAA;AACZ,EAAA;AACH;AAKsB;AACN,EAAA;AACL,IAAA;AACI,MAAA;AACT,MAAA;AACF,IAAA;AACD,EAAA;AACH;AAKgB;AAIC,EAAA;AACV,EAAA;AAIU,EAAA;AAEC,EAAA;AACV,IAAA;AACQ,IAAA;AACH,MAAA;AACT,IAAA;AACY,IAAA;AACH,MAAA;AACA,MAAA;AACT,IAAA;AACY,IAAA;AACD,MAAA;AACF,MAAA;AACT,IAAA;AACO,IAAA;AACT,EAAA;AAGU,EAAA;AAMZ;AH2KkB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/mnt/c/Users/bubun/CascadeProjects/nextjs-cms/dist/chunk-I4IEN4KN.js","sourcesContent":[null,"/**\n * Workflow Context & State Management\n *\n * Manages execution context, variable resolution, and state\n * throughout workflow execution.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  WorkflowContext,\n  WorkflowEvent,\n  InputMapping,\n  WorkflowCondition,\n} from './types';\n\n// =============================================================================\n// CONTEXT CREATION\n// =============================================================================\n\n/**\n * Create a new workflow execution context\n */\nexport function createWorkflowContext(\n  workflowId: string,\n  trigger: {\n    type: string;\n    data: unknown;\n    event?: WorkflowEvent;\n  },\n  initialVariables?: Record<string, unknown>\n): WorkflowContext {\n  return {\n    executionId: uuidv4(),\n    workflowId,\n    startedAt: new Date(),\n    trigger,\n    variables: initialVariables || {},\n    nodeOutputs: {},\n    executedNodes: [],\n    errors: [],\n  };\n}\n\n// =============================================================================\n// VARIABLE RESOLUTION\n// =============================================================================\n\n/**\n * Resolve a value from context using path notation\n * Supports: trigger.data.field, variables.name, nodes.nodeId.field\n */\nexport function resolveValue(context: WorkflowContext, path: string): unknown {\n  const parts = path.split('.');\n  let current: unknown = context;\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (typeof current !== 'object') {\n      return undefined;\n    }\n\n    // Handle special prefixes\n    if (part === 'trigger') {\n      current = context.trigger;\n    } else if (part === 'variables') {\n      current = context.variables;\n    } else if (part === 'nodes') {\n      current = context.nodeOutputs;\n    } else if (part === 'event') {\n      current = context.trigger.event;\n    } else {\n      current = (current as Record<string, unknown>)[part];\n    }\n  }\n\n  return current;\n}\n\n/**\n * Resolve input mapping to actual value\n */\nexport function resolveInputMapping(\n  mapping: string | InputMapping,\n  context: WorkflowContext\n): unknown {\n  // Simple string path\n  if (typeof mapping === 'string') {\n    // Check if it's a template string\n    if (mapping.includes('{{')) {\n      return resolveTemplate(mapping, context);\n    }\n    return resolveValue(context, mapping);\n  }\n\n  // Input mapping object\n  switch (mapping.type) {\n    case 'static':\n      return mapping.value;\n\n    case 'reference':\n      return resolveValue(context, mapping.path || mapping.value);\n\n    case 'expression':\n      return evaluateExpression(mapping.value, context);\n\n    case 'template':\n      return resolveTemplate(mapping.value, context);\n\n    default:\n      return mapping.value;\n  }\n}\n\n/**\n * Resolve all input mappings for a node\n */\nexport function resolveNodeInputs(\n  inputMapping: Record<string, string | InputMapping> | undefined,\n  context: WorkflowContext\n): Record<string, unknown> {\n  if (!inputMapping) return {};\n\n  const resolved: Record<string, unknown> = {};\n\n  for (const [key, mapping] of Object.entries(inputMapping)) {\n    resolved[key] = resolveInputMapping(mapping, context);\n  }\n\n  return resolved;\n}\n\n/**\n * Resolve template string with {{path}} placeholders\n */\nexport function resolveTemplate(template: string, context: WorkflowContext): string {\n  return template.replace(/\\{\\{([^}]+)\\}\\}/g, (_, path) => {\n    const value = resolveValue(context, path.trim());\n    return value !== undefined && value !== null ? String(value) : '';\n  });\n}\n\n// =============================================================================\n// EXPRESSION EVALUATION\n// =============================================================================\n\n/**\n * Safely evaluate an expression against context\n * Supports basic operations and context references\n */\nexport function evaluateExpression(expression: string, context: WorkflowContext): unknown {\n  // Create a safe evaluation context\n  const safeContext = {\n    trigger: context.trigger,\n    variables: context.variables,\n    nodes: context.nodeOutputs,\n    event: context.trigger.event,\n    // Helper functions\n    $get: (path: string) => resolveValue(context, path),\n    $len: (arr: unknown) => Array.isArray(arr) ? arr.length : 0,\n    $exists: (path: string) => resolveValue(context, path) !== undefined,\n    $empty: (val: unknown) => val === undefined || val === null || val === '' || (Array.isArray(val) && val.length === 0),\n    $now: () => new Date().toISOString(),\n    $lower: (str: unknown) => typeof str === 'string' ? str.toLowerCase() : str,\n    $upper: (str: unknown) => typeof str === 'string' ? str.toUpperCase() : str,\n    $trim: (str: unknown) => typeof str === 'string' ? str.trim() : str,\n    $number: (val: unknown) => Number(val),\n    $string: (val: unknown) => String(val),\n    $json: (val: unknown) => JSON.stringify(val),\n    $parse: (str: unknown) => typeof str === 'string' ? JSON.parse(str) : str,\n  };\n\n  try {\n    // Create function with safe context\n    const fn = new Function(\n      ...Object.keys(safeContext),\n      `\"use strict\"; return (${expression});`\n    );\n\n    return fn(...Object.values(safeContext));\n  } catch (error) {\n    console.error('[WorkflowContext] Expression evaluation error:', error);\n    return undefined;\n  }\n}\n\n// =============================================================================\n// CONDITION EVALUATION\n// =============================================================================\n\n/**\n * Evaluate a workflow condition\n */\nexport function evaluateCondition(\n  condition: WorkflowCondition,\n  context: WorkflowContext\n): boolean {\n  switch (condition.type) {\n    case 'simple':\n      return evaluateSimpleCondition(condition, context);\n\n    case 'expression':\n      return Boolean(evaluateExpression(condition.expression || 'false', context));\n\n    case 'all':\n      return (condition.conditions || []).every((c) => evaluateCondition(c, context));\n\n    case 'any':\n      return (condition.conditions || []).some((c) => evaluateCondition(c, context));\n\n    case 'none':\n      return !(condition.conditions || []).some((c) => evaluateCondition(c, context));\n\n    default:\n      return true;\n  }\n}\n\n/**\n * Evaluate a simple condition\n */\nfunction evaluateSimpleCondition(\n  condition: WorkflowCondition,\n  context: WorkflowContext\n): boolean {\n  const fieldValue = condition.field ? resolveValue(context, condition.field) : undefined;\n  const compareValue = condition.value;\n\n  switch (condition.operator) {\n    case 'eq':\n      return fieldValue === compareValue;\n\n    case 'neq':\n      return fieldValue !== compareValue;\n\n    case 'gt':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue > compareValue;\n\n    case 'gte':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue >= compareValue;\n\n    case 'lt':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue < compareValue;\n\n    case 'lte':\n      return typeof fieldValue === 'number' && typeof compareValue === 'number' && fieldValue <= compareValue;\n\n    case 'contains':\n      if (typeof fieldValue === 'string' && typeof compareValue === 'string') {\n        return fieldValue.includes(compareValue);\n      }\n      if (Array.isArray(fieldValue)) {\n        return fieldValue.includes(compareValue);\n      }\n      return false;\n\n    case 'startsWith':\n      return typeof fieldValue === 'string' && typeof compareValue === 'string' && fieldValue.startsWith(compareValue);\n\n    case 'endsWith':\n      return typeof fieldValue === 'string' && typeof compareValue === 'string' && fieldValue.endsWith(compareValue);\n\n    case 'in':\n      return Array.isArray(compareValue) && compareValue.includes(fieldValue);\n\n    case 'notIn':\n      return Array.isArray(compareValue) && !compareValue.includes(fieldValue);\n\n    case 'exists':\n      return compareValue ? fieldValue !== undefined && fieldValue !== null : fieldValue === undefined || fieldValue === null;\n\n    default:\n      return true;\n  }\n}\n\n// =============================================================================\n// CONTEXT MUTATION\n// =============================================================================\n\n/**\n * Update context with node output\n */\nexport function setNodeOutput(\n  context: WorkflowContext,\n  nodeId: string,\n  output: unknown\n): WorkflowContext {\n  return {\n    ...context,\n    nodeOutputs: {\n      ...context.nodeOutputs,\n      [nodeId]: output,\n    },\n    executedNodes: [...context.executedNodes, nodeId],\n    currentNodeId: nodeId,\n  };\n}\n\n/**\n * Set a variable in context\n */\nexport function setVariable(\n  context: WorkflowContext,\n  name: string,\n  value: unknown\n): WorkflowContext {\n  return {\n    ...context,\n    variables: {\n      ...context.variables,\n      [name]: value,\n    },\n  };\n}\n\n/**\n * Add an error to context\n */\nexport function addError(\n  context: WorkflowContext,\n  nodeId: string,\n  error: string\n): WorkflowContext {\n  return {\n    ...context,\n    errors: [\n      ...context.errors,\n      {\n        nodeId,\n        error,\n        timestamp: new Date(),\n      },\n    ],\n  };\n}\n\n// =============================================================================\n// LOOP CONTEXT\n// =============================================================================\n\n/**\n * Create iteration context for loop execution\n */\nexport function createIterationContext(\n  context: WorkflowContext,\n  itemVariable: string,\n  item: unknown,\n  indexVariable: string | undefined,\n  index: number\n): WorkflowContext {\n  const variables = {\n    ...context.variables,\n    [itemVariable]: item,\n  };\n\n  if (indexVariable) {\n    variables[indexVariable] = index;\n  }\n\n  return {\n    ...context,\n    variables,\n  };\n}\n\n// =============================================================================\n// CONTEXT SERIALIZATION\n// =============================================================================\n\n/**\n * Serialize context for storage (e.g., for pause/resume)\n */\nexport function serializeContext(context: WorkflowContext): string {\n  return JSON.stringify({\n    ...context,\n    startedAt: context.startedAt.toISOString(),\n    errors: context.errors.map((e) => ({\n      ...e,\n      timestamp: e.timestamp.toISOString(),\n    })),\n  });\n}\n\n/**\n * Deserialize context from storage\n */\nexport function deserializeContext(serialized: string): WorkflowContext {\n  const parsed = JSON.parse(serialized);\n  return {\n    ...parsed,\n    startedAt: new Date(parsed.startedAt),\n    errors: parsed.errors.map((e: { nodeId: string; error: string; timestamp: string }) => ({\n      ...e,\n      timestamp: new Date(e.timestamp),\n    })),\n  };\n}\n\n// =============================================================================\n// CONTEXT UTILITIES\n// =============================================================================\n\n/**\n * Get a summary of context for logging\n */\nexport function getContextSummary(context: WorkflowContext): Record<string, unknown> {\n  return {\n    executionId: context.executionId,\n    workflowId: context.workflowId,\n    triggerType: context.trigger.type,\n    executedNodes: context.executedNodes.length,\n    variableCount: Object.keys(context.variables).length,\n    errorCount: context.errors.length,\n    hasErrors: context.errors.length > 0,\n  };\n}\n\n/**\n * Clone context for branch execution\n */\nexport function cloneContext(context: WorkflowContext): WorkflowContext {\n  return JSON.parse(JSON.stringify(context));\n}\n","/**\n * Primitive Adapter\n *\n * Bridges the workflow engine with the primitive execution system.\n * Handles primitive loading, validation, and execution logging.\n */\n\nimport { prisma } from '../db';\nimport type { Primitive, PrimitiveExecution } from '@prisma/client';\nimport Ajv from 'ajv';\n\n// =============================================================================\n// PRIMITIVE CACHE\n// =============================================================================\n\nconst primitiveCache = new Map<string, Primitive>();\nconst ajv = new Ajv({ allErrors: true, useDefaults: true });\n\n/**\n * Clear primitive cache (useful for testing)\n */\nexport function clearPrimitiveCache(): void {\n  primitiveCache.clear();\n}\n\n// =============================================================================\n// PRIMITIVE LOADING\n// =============================================================================\n\n/**\n * Get a primitive by ID with caching\n */\nexport async function getPrimitive(primitiveId: string): Promise<Primitive | null> {\n  // Check cache\n  if (primitiveCache.has(primitiveId)) {\n    return primitiveCache.get(primitiveId)!;\n  }\n\n  // Load from database\n  const primitive = await prisma.primitive.findUnique({\n    where: { id: primitiveId },\n  });\n\n  if (primitive) {\n    primitiveCache.set(primitiveId, primitive);\n  }\n\n  return primitive;\n}\n\n/**\n * Get a primitive by name\n */\nexport async function getPrimitiveByName(name: string): Promise<Primitive | null> {\n  // Check cache by name\n  for (const primitive of primitiveCache.values()) {\n    if (primitive.name === name) {\n      return primitive;\n    }\n  }\n\n  // Load from database\n  const primitive = await prisma.primitive.findUnique({\n    where: { name },\n  });\n\n  if (primitive) {\n    primitiveCache.set(primitive.id, primitive);\n  }\n\n  return primitive;\n}\n\n/**\n * Get all primitives for a category\n */\nexport async function getPrimitivesByCategory(category: string): Promise<Primitive[]> {\n  return prisma.primitive.findMany({\n    where: {\n      category,\n      enabled: true,\n    },\n    orderBy: { name: 'asc' },\n  });\n}\n\n/**\n * Get all available primitives\n */\nexport async function getAllPrimitives(): Promise<Primitive[]> {\n  return prisma.primitive.findMany({\n    where: { enabled: true },\n    orderBy: { category: 'asc' },\n  });\n}\n\n// =============================================================================\n// INPUT VALIDATION\n// =============================================================================\n\n/**\n * Validate input against primitive's JSON Schema\n */\nexport function validatePrimitiveInput(\n  primitive: Primitive,\n  input: unknown\n): { valid: boolean; errors?: string[] } {\n  const schema = primitive.inputSchema as Record<string, unknown>;\n\n  if (!schema || Object.keys(schema).length === 0) {\n    return { valid: true };\n  }\n\n  try {\n    const validate = ajv.compile(schema);\n    const valid = validate(input);\n\n    if (!valid && validate.errors) {\n      return {\n        valid: false,\n        errors: validate.errors.map(\n          (e) => `${(e as { instancePath?: string }).instancePath || 'input'} ${e.message}`\n        ),\n      };\n    }\n\n    return { valid: true };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [`Schema validation error: ${error instanceof Error ? error.message : 'Unknown'}`],\n    };\n  }\n}\n\n// =============================================================================\n// PRIMITIVE EXECUTION\n// =============================================================================\n\ninterface ExecutionContext {\n  workflowExecutionId?: string;\n  workflowId?: string;\n  userId?: string;\n  agentId?: string;\n}\n\n/**\n * Execute a primitive by ID\n */\nexport async function executePrimitive(\n  primitiveId: string,\n  input: Record<string, unknown>,\n  context?: ExecutionContext\n): Promise<unknown> {\n  const startedAt = new Date();\n  const startTime = Date.now();\n\n  // Load primitive\n  const primitive = await getPrimitive(primitiveId);\n  if (!primitive) {\n    throw new Error(`Primitive not found: ${primitiveId}`);\n  }\n\n  if (!primitive.enabled) {\n    throw new Error(`Primitive is disabled: ${primitive.name}`);\n  }\n\n  // Validate input\n  const validation = validatePrimitiveInput(primitive, input);\n  if (!validation.valid) {\n    throw new Error(`Invalid input: ${validation.errors?.join(', ')}`);\n  }\n\n  let output: unknown;\n  let success = true;\n  let errorMessage: string | undefined;\n\n  try {\n    // Execute the primitive handler\n    output = await executeHandler(primitive, input);\n  } catch (error) {\n    success = false;\n    errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    throw error;\n  } finally {\n    // Log execution\n    const completedAt = new Date();\n    const executionTime = Date.now() - startTime;\n\n    await logPrimitiveExecution({\n      primitiveId,\n      workflowExecutionId: context?.workflowExecutionId,\n      userId: context?.userId,\n      agentId: context?.agentId,\n      input,\n      output,\n      success,\n      error: errorMessage,\n      startedAt,\n      completedAt,\n      executionTime,\n    });\n  }\n\n  return output;\n}\n\n/**\n * Execute a primitive by name\n */\nexport async function executePrimitiveByName(\n  name: string,\n  input: Record<string, unknown>,\n  context?: ExecutionContext\n): Promise<unknown> {\n  const primitive = await getPrimitiveByName(name);\n  if (!primitive) {\n    throw new Error(`Primitive not found: ${name}`);\n  }\n\n  return executePrimitive(primitive.id, input, context);\n}\n\n// =============================================================================\n// HANDLER EXECUTION\n// =============================================================================\n\n/**\n * Execute the primitive handler code\n */\nasync function executeHandler(\n  primitive: Primitive,\n  input: Record<string, unknown>\n): Promise<unknown> {\n  const handler = primitive.handler;\n\n  // Create a sandboxed execution context\n  const context = createExecutionContext(primitive);\n\n  try {\n    // Wrap handler in async function\n    const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    const fn = new AsyncFunction('input', 'context', handler);\n\n    // Execute with timeout\n    const result = await Promise.race([\n      fn(input, context),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Execution timeout')), primitive.timeout)\n      ),\n    ]);\n\n    return result;\n  } catch (error) {\n    console.error(`[PrimitiveAdapter] Handler error for ${primitive.name}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Create execution context for handler\n */\nfunction createExecutionContext(primitive: Primitive): Record<string, unknown> {\n  return {\n    // Primitive metadata\n    primitiveId: primitive.id,\n    primitiveName: primitive.name,\n    primitiveVersion: primitive.version,\n\n    // Utilities\n    log: (...args: unknown[]) => console.log(`[${primitive.name}]`, ...args),\n    error: (...args: unknown[]) => console.error(`[${primitive.name}]`, ...args),\n\n    // HTTP helpers (if needed by handler)\n    fetch: globalThis.fetch,\n\n    // Environment (filtered for security)\n    env: {\n      NODE_ENV: process.env.NODE_ENV,\n    },\n  };\n}\n\n// =============================================================================\n// EXECUTION LOGGING\n// =============================================================================\n\ninterface LogExecutionParams {\n  primitiveId: string;\n  workflowExecutionId?: string;\n  userId?: string;\n  agentId?: string;\n  input: unknown;\n  output: unknown;\n  success: boolean;\n  error?: string;\n  startedAt: Date;\n  completedAt: Date;\n  executionTime: number;\n}\n\n/**\n * Log primitive execution to database\n */\nasync function logPrimitiveExecution(params: LogExecutionParams): Promise<PrimitiveExecution> {\n  return prisma.primitiveExecution.create({\n    data: {\n      primitiveId: params.primitiveId,\n      workflowExecutionId: params.workflowExecutionId,\n      userId: params.userId,\n      agentId: params.agentId,\n      input: params.input as never,\n      output: params.output as never,\n      success: params.success,\n      error: params.error,\n      startedAt: params.startedAt,\n      completedAt: params.completedAt,\n      executionTime: params.executionTime,\n    },\n  });\n}\n\n/**\n * Get execution history for a primitive\n */\nexport async function getPrimitiveExecutionHistory(\n  primitiveId: string,\n  options?: {\n    limit?: number;\n    success?: boolean;\n    workflowExecutionId?: string;\n  }\n): Promise<PrimitiveExecution[]> {\n  return prisma.primitiveExecution.findMany({\n    where: {\n      primitiveId,\n      ...(options?.success !== undefined && { success: options.success }),\n      ...(options?.workflowExecutionId && {\n        workflowExecutionId: options.workflowExecutionId,\n      }),\n    },\n    orderBy: { startedAt: 'desc' },\n    take: options?.limit || 50,\n  });\n}\n\n// =============================================================================\n// PRIMITIVE UTILITIES\n// =============================================================================\n\n/**\n * Get primitive categories\n */\nexport async function getPrimitiveCategories(): Promise<string[]> {\n  const primitives = await prisma.primitive.findMany({\n    where: { enabled: true },\n    select: { category: true },\n    distinct: ['category'],\n  });\n\n  return primitives\n    .map((p: { category: string | null }) => p.category)\n    .filter((c: string | null): c is string => c !== null)\n    .sort();\n}\n\n/**\n * Check if a primitive exists and is enabled\n */\nexport async function isPrimitiveAvailable(primitiveId: string): Promise<boolean> {\n  const primitive = await getPrimitive(primitiveId);\n  return primitive !== null && primitive.enabled;\n}\n\n/**\n * Get primitive input schema for UI rendering\n */\nexport async function getPrimitiveInputSchema(\n  primitiveId: string\n): Promise<Record<string, unknown> | null> {\n  const primitive = await getPrimitive(primitiveId);\n  if (!primitive) return null;\n\n  return primitive.inputSchema as Record<string, unknown>;\n}\n","/**\n * Workflow Execution Engine\n *\n * Executes workflows by traversing nodes, evaluating conditions,\n * and running primitives/actions.\n */\n\nimport { prisma } from '../db';\nimport type { Workflow, WorkflowExecution } from '@prisma/client';\nimport {\n  createWorkflowContext,\n  setNodeOutput,\n  addError,\n  evaluateCondition,\n  resolveNodeInputs,\n  createIterationContext,\n} from './context';\nimport { executePrimitive } from './primitive-adapter';\nimport type {\n  WorkflowContext,\n  WorkflowExecutionResult,\n  NodeExecutionResult,\n  WorkflowTemplateNode,\n  WorkflowTemplateEdge,\n  WorkflowNodeConfig,\n  WorkflowEvent,\n} from './types';\n\n// =============================================================================\n// WORKFLOW EXECUTION\n// =============================================================================\n\ninterface ExecuteWorkflowOptions {\n  triggeredBy: 'manual' | 'schedule' | 'webhook' | 'event' | 'agent';\n  userId?: string;\n  agentId?: string;\n  eventData?: unknown;\n  variables?: Record<string, unknown>;\n}\n\n/**\n * Execute a workflow by ID\n */\nexport async function executeWorkflow(\n  workflowId: string,\n  options: ExecuteWorkflowOptions\n): Promise<WorkflowExecutionResult> {\n  // Load workflow\n  const workflow = await prisma.workflow.findUnique({\n    where: { id: workflowId },\n    include: {\n      workflowNodes: {\n        include: { primitive: true },\n      },\n    },\n  });\n\n  if (!workflow) {\n    throw new Error(`Workflow not found: ${workflowId}`);\n  }\n\n  if (!workflow.enabled) {\n    throw new Error(`Workflow is disabled: ${workflowId}`);\n  }\n\n  return executeWorkflowInstance(workflow, options);\n}\n\n/**\n * Execute a workflow instance\n */\nexport async function executeWorkflowInstance(\n  workflow: Workflow,\n  options: ExecuteWorkflowOptions\n): Promise<WorkflowExecutionResult> {\n  const nodes = workflow.nodes as unknown as WorkflowTemplateNode[];\n  const edges = workflow.edges as unknown as WorkflowTemplateEdge[];\n  const workflowVariables = workflow.variables as Record<string, unknown> | null;\n\n  // Create execution record\n  const execution = await prisma.workflowExecution.create({\n    data: {\n      workflowId: workflow.id,\n      triggeredBy: options.triggeredBy,\n      userId: options.userId,\n      agentId: options.agentId,\n      eventData: options.eventData as never,\n      status: 'RUNNING',\n    },\n  });\n\n  // Create execution context\n  let context = createWorkflowContext(\n    workflow.id,\n    {\n      type: options.triggeredBy,\n      data: options.eventData,\n      event: options.eventData as WorkflowEvent | undefined,\n    },\n    { ...workflowVariables, ...options.variables }\n  );\n\n  // Override executionId to match DB record\n  context = { ...context, executionId: execution.id };\n\n  const nodeResults: NodeExecutionResult[] = [];\n  const startTime = Date.now();\n\n  try {\n    // Find trigger node (starting point)\n    const triggerNode = nodes.find((n) => n.data.nodeType === 'trigger');\n    if (!triggerNode) {\n      throw new Error('No trigger node found in workflow');\n    }\n\n    // Execute from trigger node\n    const result = await executeNode(\n      triggerNode,\n      nodes,\n      edges,\n      context,\n      nodeResults,\n      workflow.id\n    );\n\n    // Update execution record\n    const completedAt = new Date();\n    await prisma.workflowExecution.update({\n      where: { id: execution.id },\n      data: {\n        status: 'COMPLETED',\n        result: result.output as never,\n        completedAt,\n      },\n    });\n\n    // Update workflow lastRunAt\n    await prisma.workflow.update({\n      where: { id: workflow.id },\n      data: { lastRunAt: completedAt },\n    });\n\n    return {\n      executionId: execution.id,\n      workflowId: workflow.id,\n      status: 'COMPLETED',\n      startedAt: execution.startedAt,\n      completedAt,\n      duration: Date.now() - startTime,\n      result: result.output,\n      nodeResults,\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    // Update execution record with error\n    await prisma.workflowExecution.update({\n      where: { id: execution.id },\n      data: {\n        status: 'FAILED',\n        error: errorMessage,\n        completedAt: new Date(),\n      },\n    });\n\n    return {\n      executionId: execution.id,\n      workflowId: workflow.id,\n      status: 'FAILED',\n      startedAt: execution.startedAt,\n      completedAt: new Date(),\n      duration: Date.now() - startTime,\n      error: errorMessage,\n      nodeResults,\n    };\n  }\n}\n\n// =============================================================================\n// NODE EXECUTION\n// =============================================================================\n\n/**\n * Execute a node and its downstream nodes\n */\nasync function executeNode(\n  node: WorkflowTemplateNode,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<{ output: unknown; context: WorkflowContext }> {\n  const nodeStartTime = Date.now();\n  const config = node.data.config as WorkflowNodeConfig | undefined;\n\n  let output: unknown;\n  let updatedContext = context;\n\n  try {\n    // Execute based on node type\n    switch (node.data.nodeType) {\n      case 'trigger':\n        // Trigger nodes just pass through the trigger data\n        output = context.trigger.data;\n        break;\n\n      case 'primitive':\n        output = await executePrimitiveNode(node, config, context, workflowId);\n        break;\n\n      case 'condition':\n        output = await executeConditionNode(node, config, context);\n        break;\n\n      case 'loop':\n        const loopResult = await executeLoopNode(\n          node,\n          config,\n          allNodes,\n          allEdges,\n          context,\n          nodeResults,\n          workflowId\n        );\n        output = loopResult.output;\n        updatedContext = loopResult.context;\n        break;\n\n      case 'delay':\n        output = await executeDelayNode(config);\n        break;\n\n      case 'parallel':\n        output = await executeParallelNode(\n          node,\n          allNodes,\n          allEdges,\n          context,\n          nodeResults,\n          workflowId\n        );\n        break;\n\n      case 'output':\n        // Output nodes collect final results\n        output = resolveNodeInputs(config?.inputMapping, context);\n        break;\n\n      default:\n        output = null;\n    }\n\n    // Update context with node output\n    updatedContext = setNodeOutput(updatedContext, node.id, output);\n\n    // Record success\n    nodeResults.push({\n      nodeId: node.id,\n      success: true,\n      output,\n      duration: Date.now() - nodeStartTime,\n    });\n\n    // Find and execute downstream nodes\n    const outgoingEdges = allEdges.filter((e) => e.source === node.id);\n\n    for (const edge of outgoingEdges) {\n      // Check edge condition if present\n      if (edge.data?.condition) {\n        const conditionMet = evaluateCondition(edge.data.condition, updatedContext);\n        if (!conditionMet) continue;\n      }\n\n      // For condition nodes, check the sourceHandle\n      if (node.data.nodeType === 'condition' && edge.sourceHandle) {\n        const conditionResult = output as boolean;\n        if (edge.sourceHandle === 'true' && !conditionResult) continue;\n        if (edge.sourceHandle === 'false' && conditionResult) continue;\n      }\n\n      const targetNode = allNodes.find((n) => n.id === edge.target);\n      if (targetNode) {\n        const result = await executeNode(\n          targetNode,\n          allNodes,\n          allEdges,\n          updatedContext,\n          nodeResults,\n          workflowId\n        );\n        updatedContext = result.context;\n        // Use last node's output as final output\n        output = result.output;\n      }\n    }\n\n    return { output, context: updatedContext };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    nodeResults.push({\n      nodeId: node.id,\n      success: false,\n      error: errorMessage,\n      duration: Date.now() - nodeStartTime,\n    });\n\n    updatedContext = addError(updatedContext, node.id, errorMessage);\n    throw error;\n  }\n}\n\n// =============================================================================\n// NODE TYPE HANDLERS\n// =============================================================================\n\n/**\n * Execute a primitive node\n */\nasync function executePrimitiveNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  context: WorkflowContext,\n  workflowId: string\n): Promise<unknown> {\n  const primitiveId = node.data.primitiveId;\n  if (!primitiveId) {\n    throw new Error(`Primitive node ${node.id} has no primitive assigned`);\n  }\n\n  // Resolve inputs from context\n  const inputs = resolveNodeInputs(config?.inputMapping, context);\n\n  // Merge with static config\n  const finalInputs = {\n    ...config?.primitiveConfig,\n    ...inputs,\n  };\n\n  // Execute primitive\n  return executePrimitive(primitiveId, finalInputs, {\n    workflowExecutionId: context.executionId,\n    workflowId,\n  });\n}\n\n/**\n * Execute a condition node\n */\nasync function executeConditionNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  context: WorkflowContext\n): Promise<boolean> {\n  if (!config?.condition) {\n    return true;\n  }\n\n  return evaluateCondition(config.condition, context);\n}\n\n/**\n * Execute a loop node\n */\nasync function executeLoopNode(\n  node: WorkflowTemplateNode,\n  config: WorkflowNodeConfig | undefined,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<{ output: unknown[]; context: WorkflowContext }> {\n  if (!config?.loop) {\n    return { output: [], context };\n  }\n\n  const { collection, itemVariable, indexVariable } = config.loop;\n\n  // Get collection from context\n  const items = context.variables[collection] as unknown[];\n  if (!Array.isArray(items)) {\n    throw new Error(`Loop collection \"${collection}\" is not an array`);\n  }\n\n  // Find loop body nodes (nodes connected from this loop node)\n  const loopBodyEdges = allEdges.filter(\n    (e) => e.source === node.id && e.sourceHandle === 'body'\n  );\n\n  const results: unknown[] = [];\n  let currentContext = context;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n\n    // Create iteration context\n    const iterContext = createIterationContext(\n      currentContext,\n      itemVariable,\n      item,\n      indexVariable,\n      i\n    );\n\n    // Execute loop body\n    for (const edge of loopBodyEdges) {\n      const bodyNode = allNodes.find((n) => n.id === edge.target);\n      if (bodyNode) {\n        const result = await executeNode(\n          bodyNode,\n          allNodes,\n          allEdges,\n          iterContext,\n          nodeResults,\n          workflowId\n        );\n        results.push(result.output);\n        // Carry forward context changes (except iteration variables)\n        currentContext = {\n          ...result.context,\n          variables: {\n            ...result.context.variables,\n            [itemVariable]: undefined,\n            ...(indexVariable ? { [indexVariable]: undefined } : {}),\n          },\n        };\n      }\n    }\n  }\n\n  return { output: results, context: currentContext };\n}\n\n/**\n * Execute a delay node\n */\nasync function executeDelayNode(\n  config: WorkflowNodeConfig | undefined\n): Promise<{ delayed: boolean; duration: number }> {\n  if (!config?.delay) {\n    return { delayed: false, duration: 0 };\n  }\n\n  const { duration, unit } = config.delay;\n  let ms = duration;\n\n  switch (unit) {\n    case 'minutes':\n      ms = duration * 60 * 1000;\n      break;\n    case 'hours':\n      ms = duration * 60 * 60 * 1000;\n      break;\n    case 'days':\n      ms = duration * 24 * 60 * 60 * 1000;\n      break;\n    default:\n      ms = duration * 1000;\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, ms));\n\n  return { delayed: true, duration: ms };\n}\n\n/**\n * Execute a parallel node (fan-out)\n */\nasync function executeParallelNode(\n  node: WorkflowTemplateNode,\n  allNodes: WorkflowTemplateNode[],\n  allEdges: WorkflowTemplateEdge[],\n  context: WorkflowContext,\n  nodeResults: NodeExecutionResult[],\n  workflowId: string\n): Promise<unknown[]> {\n  // Find all outgoing edges from parallel node\n  const outgoingEdges = allEdges.filter((e) => e.source === node.id);\n\n  // Execute all branches in parallel\n  const promises = outgoingEdges.map(async (edge) => {\n    const targetNode = allNodes.find((n) => n.id === edge.target);\n    if (!targetNode) return null;\n\n    const result = await executeNode(\n      targetNode,\n      allNodes,\n      allEdges,\n      context,\n      nodeResults,\n      workflowId\n    );\n    return result.output;\n  });\n\n  const results = await Promise.all(promises);\n  return results.filter((r) => r !== null);\n}\n\n// =============================================================================\n// WORKFLOW MANAGEMENT\n// =============================================================================\n\n/**\n * Cancel a running workflow execution\n */\nexport async function cancelWorkflowExecution(executionId: string): Promise<void> {\n  await prisma.workflowExecution.update({\n    where: { id: executionId },\n    data: {\n      status: 'CANCELLED',\n      completedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get workflow execution status\n */\nexport async function getWorkflowExecutionStatus(\n  executionId: string\n): Promise<WorkflowExecution | null> {\n  return prisma.workflowExecution.findUnique({\n    where: { id: executionId },\n  });\n}\n\n/**\n * Get recent workflow executions\n */\nexport async function getWorkflowExecutions(\n  workflowId: string,\n  options?: {\n    limit?: number;\n    status?: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';\n  }\n): Promise<WorkflowExecution[]> {\n  return prisma.workflowExecution.findMany({\n    where: {\n      workflowId,\n      ...(options?.status && { status: options.status }),\n    },\n    orderBy: { startedAt: 'desc' },\n    take: options?.limit || 50,\n  });\n}\n\n// =============================================================================\n// WORKFLOW TRIGGER HELPERS\n// =============================================================================\n\n/**\n * Trigger a workflow manually\n */\nexport async function triggerWorkflowManually(\n  workflowId: string,\n  data?: unknown,\n  userId?: string\n): Promise<WorkflowExecutionResult> {\n  return executeWorkflow(workflowId, {\n    triggeredBy: 'manual',\n    userId,\n    eventData: data,\n  });\n}\n\n/**\n * Trigger a workflow via webhook\n */\nexport async function triggerWorkflowByWebhook(\n  workflowSlug: string,\n  payload: unknown\n): Promise<WorkflowExecutionResult> {\n  const workflow = await prisma.workflow.findUnique({\n    where: { slug: workflowSlug },\n  });\n\n  if (!workflow) {\n    throw new Error(`Workflow not found: ${workflowSlug}`);\n  }\n\n  if (workflow.triggerType !== 'WEBHOOK') {\n    throw new Error(`Workflow ${workflowSlug} is not configured for webhook triggers`);\n  }\n\n  return executeWorkflow(workflow.id, {\n    triggeredBy: 'webhook',\n    eventData: payload,\n  });\n}\n\n/**\n * Find workflows that should run on schedule\n */\nexport async function getScheduledWorkflows(): Promise<Workflow[]> {\n  return prisma.workflow.findMany({\n    where: {\n      enabled: true,\n      triggerType: 'SCHEDULE',\n    },\n  });\n}\n\n/**\n * Check if a workflow should run based on cron schedule\n */\nexport function shouldRunScheduledWorkflow(\n  workflow: Workflow,\n  now: Date = new Date()\n): boolean {\n  const config = workflow.triggerConfig as { cron?: string } | null;\n  if (!config?.cron) return false;\n\n  // Parse cron expression (simplified - for production use a library like cron-parser)\n  // Format: minute hour dayOfMonth month dayOfWeek\n  const [minute, hour, dayOfMonth, month, dayOfWeek] = config.cron.split(' ');\n\n  const matches = (pattern: string, value: number): boolean => {\n    if (pattern === '*') return true;\n    if (pattern.includes(',')) {\n      return pattern.split(',').some((p) => matches(p, value));\n    }\n    if (pattern.includes('-')) {\n      const [start, end] = pattern.split('-').map(Number);\n      return value >= start && value <= end;\n    }\n    if (pattern.includes('/')) {\n      const [, step] = pattern.split('/').map(Number);\n      return value % step === 0;\n    }\n    return parseInt(pattern, 10) === value;\n  };\n\n  return (\n    matches(minute, now.getMinutes()) &&\n    matches(hour, now.getHours()) &&\n    matches(dayOfMonth, now.getDate()) &&\n    matches(month, now.getMonth() + 1) &&\n    matches(dayOfWeek, now.getDay())\n  );\n}\n"]}